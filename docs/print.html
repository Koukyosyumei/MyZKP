<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Book of MyZKP</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="number_theory/index.html"><strong aria-hidden="true">2.</strong> Basics of Number Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="number_theory/subsec1.html"><strong aria-hidden="true">2.1.</strong> Computation Rule and Properties</a></li><li class="chapter-item expanded "><a href="number_theory/subsec2.html"><strong aria-hidden="true">2.2.</strong> Semigroup, Group, Ring, and Field</a></li><li class="chapter-item expanded "><a href="number_theory/subsec3.html"><strong aria-hidden="true">2.3.</strong> Polynomials</a></li><li class="chapter-item expanded "><a href="number_theory/subsec4.html"><strong aria-hidden="true">2.4.</strong> Galois Field</a></li><li class="chapter-item expanded "><a href="number_theory/subsec5.html"><strong aria-hidden="true">2.5.</strong> Elliptic Curve</a></li><li class="chapter-item expanded "><a href="number_theory/subsec6.html"><strong aria-hidden="true">2.6.</strong> Pairing</a></li><li class="chapter-item expanded "><a href="number_theory/subsec7.html"><strong aria-hidden="true">2.7.</strong> Useful Assumptions</a></li></ol></li><li class="chapter-item expanded "><a href="polynomial_commitment/index.html"><strong aria-hidden="true">3.</strong> Basics of Polynomial Commitment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="polynomial_commitment/kzg.html"><strong aria-hidden="true">3.1.</strong> KZG</a></li><li class="chapter-item expanded "><a href="polynomial_commitment/gemini.html"><strong aria-hidden="true">3.2.</strong> Gemini</a></li></ol></li><li class="chapter-item expanded "><a href="zksnark/index.html"><strong aria-hidden="true">4.</strong> Basics of zk-SNARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zksnark/subsec1.html"><strong aria-hidden="true">4.1.</strong> Arithmetization</a></li><li class="chapter-item expanded "><a href="zksnark/subsec2.html"><strong aria-hidden="true">4.2.</strong> Proving Single Polynomial</a></li><li class="chapter-item expanded "><a href="zksnark/subsec3.html"><strong aria-hidden="true">4.3.</strong> Bringing It All Together: SNARK</a></li></ol></li><li class="chapter-item expanded "><a href="zkstark/index.html"><strong aria-hidden="true">5.</strong> Basics of zk-STARKS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkstark/subsec1.html"><strong aria-hidden="true">5.1.</strong> FRI</a></li></ol></li><li class="chapter-item expanded "><a href="zkvm/index.html"><strong aria-hidden="true">6.</strong> Basics of zkVM</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book of MyZKP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Koukyosyumei/MyZKP/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-myzkp-building-zero-knowledge-proof-from-scratch-in-rust"><a class="header" href="#-myzkp-building-zero-knowledge-proof-from-scratch-in-rust">üöÄ MyZKP: Building Zero Knowledge Proof from Scratch in Rust</a></h1>
<pre><code>‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ü¶Ä
‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë  ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó ü¶Ä
‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù 
‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë    ‚ïö‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù    ü¶Ä
‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ü¶Ä    
‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù      ü¶Ä
</code></pre>
<p><strong>MyZKP</strong> is a Rust implementation of zero-knowledge protocols built entirely from scratch! This project serves as an educational resource for understanding and working with zero-knowledge proofs.</p>
<blockquote>
<p>‚ö†Ô∏è <strong>Warning:</strong>
This repository is a work in progress and may contain bugs or inaccuracies. Contributions and feedback are welcome!</p>
</blockquote>
<h2 id="-about-myzkp"><a class="header" href="#-about-myzkp">üìö About MyZKP</a></h2>
<p>MyZKP is a growing library that provides:</p>
<ul>
<li>A step-by-step guide to the theoretical foundations of ZKPs, including number theory, elliptic curves, and field arithmetic.</li>
<li>Implementation of core primitives for ZKP protocols.</li>
<li>A solid base for developers and researchers to learn, experiment, or build their own ZKP-based systems.</li>
</ul>
<p>üí° Whether you're a cryptography enthusiast, a Rustacean, or a student, MyZKP is for you!</p>
<h2 id="-educational-modules"><a class="header" href="#-educational-modules">üìñ Educational Modules</a></h2>
<p><strong>üßÆ Basic of Number Theory</strong></p>
<ul>
<li>üìù <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec1.html">Computation Rule and Properties</a></li>
<li>‚öôÔ∏è <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec2.html">Semigroup, Group, Ring, and Field</a></li>
<li>üî¢ <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec3.html">Polynomials</a></li>
<li>üåê <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec4.html">Galois Field</a></li>
<li>üìà <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec5.html">Elliptic Curve</a></li>
<li>üîó <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec6.html">Pairing</a></li>
<li>ü§î <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec7.html">Useful Assumptions</a></li>
</ul>
<p><strong>üîí Basic of zk-SNARKs</strong></p>
<ul>
<li>‚ö° <a href="https://koukyosyumei.github.io/MyZKP/zksnark/subsec1.html">Arithmetization</a></li>
<li>üõ†Ô∏è <a href="https://koukyosyumei.github.io/MyZKP/zksnark/subsec2.html">Proving Single Polynomial</a></li>
<li>üêç <a href="https://koukyosyumei.github.io/MyZKP/zksnark/subsec3.html">Bringing It All Together: SNARK</a></li>
</ul>
<p><strong>üåü Basic of zk-STARKs</strong></p>
<ul>
<li>‚úçÔ∏è TBD</li>
</ul>
<p><strong>üíª Basic of zkVM</strong></p>
<ul>
<li>‚úçÔ∏è TBD</li>
</ul>
<h2 id="-code-reference"><a class="header" href="#-code-reference">üõ†Ô∏è Code Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Submodule</th><th>Description</th><th>üìÇ Path</th></tr></thead><tbody>
<tr><td><strong>albebra</strong></td><td><code>ring</code></td><td>Defines Ring</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/algebra/ring.rs">ring.rs</a></td></tr>
<tr><td></td><td><code>field</code></td><td>Defines Finite Field</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/algebra/field.rs">field.rs</a></td></tr>
<tr><td></td><td><code>efield</code></td><td>Field Extension (Galois Field)</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/algebra/efield.rs">efield.rs</a></td></tr>
<tr><td></td><td><code>Polynomial</code></td><td>Polynomial Arithmetic</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/algebra/polynomial.rs">polynomial.rs</a></td></tr>
<tr><td></td><td><code>curve</code></td><td>Elliptic curve operations</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/algebra/curve/">curve</a></td></tr>
<tr><td><strong>Arithmetization</strong></td><td><code>r1cs</code></td><td>Rank One Constraint System</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/arithmetization/r1cs.rs">r1cs.rs</a></td></tr>
<tr><td></td><td><code>qap</code></td><td>Quadratic Arithmetic Program</td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/arithmetization/qap.rs">qap.rs</a></td></tr>
<tr><td><strong>zkSNARKs</strong></td><td><code>tutorial_single_polynomial</code></td><td></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/zksnark/tutorial_single_polynomial/">tutorial_single_polynomial</a></td></tr>
<tr><td></td><td><code>tutorial_snark</code></td><td></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/zksnark/tutorial_snark/">tutorial_snark</a></td></tr>
<tr><td></td><td><code>pinocchio</code></td><td><a href="https://dl.acm.org/doi/abs/10.1145/2856449">Pinocchio Protocol</a></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/zksnark/pinocchio.rs">pinocchio.rs</a></td></tr>
</tbody></table>
</div>
<h2 id="-contributions-are-welcome"><a class="header" href="#-contributions-are-welcome">ü§ù Contributions are Welcome!</a></h2>
<p>We welcome your ideas, feedback, and contributions!</p>
<p>üí° Here are ways to contribute:</p>
<ol>
<li><em>Report Issues</em>: Found a bug or have a suggestion? Open an issue!</li>
<li><em>Submit Pull Requests</em>: Have code improvements? Feel free to submit them.</li>
<li><em>Write Documentation</em>: Help us make the educational modules clearer.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-number-theory"><a class="header" href="#basics-of-number-theory">Basics of Number Theory</a></h1>
<p>To effectively understand and implement ZKP protocols, a solid grasp of number theory concepts is essential. Topics such as rings, groups, fields, modular arithmetic, polynomials, elliptic curves, and pairings are foundational to these protocols.</p>
<p>In this tutorial, we‚Äôll cover these fundamental ideas, highlight their key properties, and demonstrate their implementation from scratch in Rust. ü¶Ä Whether you're new to these concepts or looking for a refresher, this section will help you build a strong foundation. If you're already an expert, feel free to skip ahead! üöÄ</p>
<h2 id="-key-concepts-you-will-learn"><a class="header" href="#-key-concepts-you-will-learn">üß† Key Concepts You Will Learn</a></h2>
<ol>
<li>‚ú® <strong>Computational Rules:</strong> Associative and Commutative Properties</li>
<li>üßÆ <strong>Integer Arithmetic:</strong> Modular Operations, Euler‚Äôs Totient Function, and Fermat‚Äôs Little Theorem</li>
<li>üîó <strong>Groups, Rings, and Fields</strong>: Semigroups, Subgroups, Cyclic Groups, Galois Fields, and Field Extensions</li>
<li>üñãÔ∏è <strong>Polynomials:</strong> Basic Operations, Lagrange Interpolation, and Schwartz‚ÄìZippel Lemma</li>
<li>üïäÔ∏è <strong>Elliptic Curves:</strong> Basic Operations, Hasse‚ÄìWeil Theorem, Zeros and Poles of Functions, and Divisors of Functions</li>
<li>‚ôæÔ∏è <strong>Pairings:</strong> Weil Pairing, Ate Pairing, and Miller‚Äôs Algorithm</li>
<li>üîë <strong>Assumptions:</strong> Discrete Logarithm Problem and Knowledge of Exponent Assumption</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computation-rule-and-properties"><a class="header" href="#computation-rule-and-properties">Computation Rule and Properties</a></h1>
<h3 id="definition-binary-operation"><a class="header" href="#definition-binary-operation">Definition: Binary Operation</a></h3>
<hr />
<p><em>A mapping \(\circ: X \times X \rightarrow X\) is a binary operation on \(X\) if for any pair of elements \((x_1, x_2)\) in \(X\), \(x_1 \circ x_2\) is also in \(X\).</em></p>
<hr />
<p><strong>Example:</strong> Addition (+) on the set of integers is a binary operation. For example, \(5 + 3 = 8\), and both \(5, 3, 8\) are integers, staying within the set of integers.</p>
<h3 id="definition-associative-property"><a class="header" href="#definition-associative-property">Definition: Associative Property</a></h3>
<hr />
<p><em>A binary operation \(\circ\) is associative if \((a \circ b) \circ c = a \circ (b \circ c)\) for all \(a, b, c \in X\).</em></p>
<hr />
<p><strong>Example:</strong> Multiplication of real numbers is associative: \((2 \times 3) \times 4 = 2 \times (3 \times 4) = 24\). In a modular context, we also have addition modulo \(n\) being associative. For example, for \(n = 5\), \((2 + 3) \bmod 5 + 4 \bmod 5 = 2 + (3 \bmod 5 + 4) \bmod 5 = 4\).</p>
<h3 id="definition-commutative-property"><a class="header" href="#definition-commutative-property">Definition: Commutative Property</a></h3>
<hr />
<p><em>A binary operation \(\circ\) is commutative if \(a \circ b = b \circ a\) for all \(a, b \in X\).</em></p>
<hr />
<p><strong>Example:</strong> Addition modulo \(n\) is also commutative. For \(n = 7\), \(5 + 3 \bmod 7 = 3 + 5 \bmod 7 = 1\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semigroup-group-ring-and-field"><a class="header" href="#semigroup-group-ring-and-field">Semigroup, Group, Ring, and Field</a></h1>
<h3 id="definition-semigroup"><a class="header" href="#definition-semigroup">Definition: Semigroup</a></h3>
<hr />
<p><em>A pair \((H, \circ)\), where \(H\) is a non-empty set and \(\circ\) is an associative binary operation on \(H\), is called a semigroup.</em></p>
<hr />
<p><strong>Example:</strong> The set of positive integers under multiplication modulo \(n\) forms a semigroup. For instance, with \(n = 6\), the elements \(\{1, 2, 3, 4, 5\}\) under multiplication modulo 6 form a semigroup, since multiplication modulo 6 is associative.</p>
<h3 id="definition-abelian-semigroup"><a class="header" href="#definition-abelian-semigroup">Definition: Abelian Semigroup</a></h3>
<hr />
<p><em>A semigroup whose operation is commutative is called an abelian semigroup.</em></p>
<hr />
<p><strong>Example:</strong> The set of natural numbers under addition modulo \(n\) forms an abelian semigroup. For \(n = 7\), addition modulo 7 is both associative and commutative, so it is an abelian semigroup.</p>
<h3 id="definition-identity-element"><a class="header" href="#definition-identity-element">Definition: Identity Element</a></h3>
<hr />
<p><em>An element \(e \in H\) is an identity element of \(H\) if it satisfies \(e \circ a = a \circ e = a\) for any \(a \in H\).</em></p>
<hr />
<p><strong>Example:</strong> 0 is the identity element for addition modulo \(n\). For example, \(0 + a \bmod 5 = a + 0 \bmod 5 = a\). Similarly, 1 is the identity element for multiplication modulo \(n\). For example, \(1 \times a \bmod 7 = a \times 1 \bmod 7 = a\).</p>
<h3 id="definition-monoid"><a class="header" href="#definition-monoid">Definition: Monoid</a></h3>
<hr />
<p><em>A semigroup with an identity element is called a monoid.</em></p>
<hr />
<p><strong>Example:</strong> The set of non-negative integers under addition modulo \(n\) forms a monoid. For \(n = 5\), the set \(\{0, 1, 2, 3, 4\}\) under addition modulo 5 forms a monoid with 0 as the identity element.</p>
<h3 id="definition-inverse"><a class="header" href="#definition-inverse">Definition: Inverse</a></h3>
<hr />
<p><em>For an element \(a \in H\), an element \(b \in H\) is an inverse of \(a\) if \(a \circ b = b \circ a = e\), where \(e\) is the identity element.</em></p>
<hr />
<p><strong>Example:</strong> In modulo \(n\) arithmetic (addition), the inverse of an element exists if it can cancel itself out to yield the identity element. In the set of integers modulo 7, the inverse of 3 is 5, because \(3 \times 5 \bmod 7 = 1\), where 1 is the identity element for multiplication.</p>
<h3 id="definition-group"><a class="header" href="#definition-group">Definition: Group</a></h3>
<hr />
<p><em>A monoid in which every element has an inverse is called a group.</em></p>
<hr />
<p><strong>Example:</strong> The set of integers modulo a prime \(p\) under multiplication forms a group (Can you prove it?). For instance, in \(\mathbb{Z}/5\mathbb{Z}\), every non-zero element \(\{1 + 5\mathbb{Z}, 2 + 5\mathbb{Z}, 3 + 5\mathbb{Z}, 4 + 5\mathbb{Z}\}\) has an inverse, making it a group.</p>
<h3 id="definition-order-of-a-group"><a class="header" href="#definition-order-of-a-group">Definition: Order of a Group</a></h3>
<hr />
<p><em>The order of a group is the number of elements in the group.</em></p>
<hr />
<p><strong>Example:</strong> The group of integers modulo 4 under addition has order 4, because the set of elements is \(\{0, 1, 2, 3\}\).</p>
<h3 id="definition-ring"><a class="header" href="#definition-ring">Definition: Ring</a></h3>
<hr />
<p><em>A triple \((R, +, \cdot)\) is a ring if \((R, +)\) is an abelian group, \((R, \cdot)\) is a semigroup, and the distributive property holds: \(x \cdot (y + z) = (x \cdot y) + (x \cdot z)\) and \((x + y) \cdot z = (x \cdot z) + (y \cdot z)\) for all \(x, y, z \in R\).</em></p>
<hr />
<p><strong>Example:</strong> The set of integers with usual addition and multiplication modulo \(n\) forms a ring. For example, in \(\mathbb{Z}/6\mathbb{Z}\), addition and multiplication modulo 6 form a ring.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use num_bigint::BigInt;
use num_traits::{One, Zero};
use std::fmt;
use std::ops::{Add, Mul, Neg, Sub};

pub trait Ring:
    Sized
    + Clone
    + PartialEq
    + fmt::Display
    + Add&lt;Output = Self&gt;
    + for&lt;'a&gt; Add&lt;&amp;'a Self, Output = Self&gt;
    + Sub&lt;Output = Self&gt;
    + for&lt;'a&gt; Sub&lt;&amp;'a Self, Output = Self&gt;
    + Mul&lt;Output = Self&gt;
    + for&lt;'a&gt; Mul&lt;&amp;'a Self, Output = Self&gt;
    + Neg&lt;Output = Self&gt;
    + One
    + Zero
{
    // A ring is an algebraic structure with addition and multiplication
    fn add_ref(&amp;self, rhs: &amp;Self) -&gt; Self;
    fn sub_ref(&amp;self, rhs: &amp;Self) -&gt; Self;
    fn mul_ref(&amp;self, rhs: &amp;Self) -&gt; Self;

    // Utility functions
    fn pow&lt;M: Into&lt;BigInt&gt;&gt;(&amp;self, n: M) -&gt; Self;
    fn get_value(&amp;self) -&gt; BigInt;
    fn from_value&lt;M: Into&lt;BigInt&gt;&gt;(value: M) -&gt; Self;
    fn random_element(exclude_elements: &amp;[Self]) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-communicative-ring"><a class="header" href="#definition-communicative-ring">Definition: Communicative Ring</a></h3>
<hr />
<p><em>A ring is called a commutative ring if its multiplication operation is commutative.</em></p>
<hr />
<p><strong>Example</strong> The set of real numbers under usual addition and multiplication forms a commutative ring.</p>
<h3 id="definition-field"><a class="header" href="#definition-field">Definition: Field</a></h3>
<hr />
<p><em>A commutative ring with a multiplicative identity element where every non-zero element has a multiplicative inverse is called a field.</em></p>
<hr />
<p><strong>Example</strong> The set of rational numbers under usual addition and multiplication forms a field.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Field: Ring + Div&lt;Output = Self&gt; + PartialEq + Eq + Hash {
    /// Computes the multiplicative inverse of the element.
    fn inverse(&amp;self) -&gt; Self;
    fn div_ref(&amp;self, other: &amp;Self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-residue-class"><a class="header" href="#definition-residue-class">Definition: Residue Class</a></h3>
<hr />
<p><em>The residue class of \( a \) modulo \( m \), denoted as \( a + m\mathbb{Z} \), is the set \( \{b : b \equiv a \pmod{m}\} \).</em></p>
<hr />
<p><strong>Example:</strong> For \( m = 3 \), the residue class of 2 is \( 2 + 3\mathbb{Z} = \{\ldots, -4, -1, 2, 5, 8, \ldots\} \).</p>
<h3 id="definition-inverse-of-residue-class"><a class="header" href="#definition-inverse-of-residue-class">Definition: Inverse of Residue Class</a></h3>
<hr />
<p><em>We denote the set of all residue classes modulo \( m \) as \( \mathbb{Z} / m\mathbb{Z} \). We say that \( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z} / m\mathbb{Z} \) if and only if there exists a solution for \( ax \equiv 1 \pmod{m} \).</em></p>
<hr />
<p><strong>Example:</strong> In \( \mathbb{Z}/5\mathbb{Z} \), \( 3 + 5\mathbb{Z} \) is invertible because \( \gcd(3, 5) = 1 \) (since \( 3\cdot2 \equiv 1 \pmod{5} \)). However, in \( \mathbb{Z}/6\mathbb{Z} \), \( 3 + 6\mathbb{Z} \) is not invertible because \( \gcd(3, 6) = 3 \neq 1 \).</p>
<h3 id="lemma-221"><a class="header" href="#lemma-221">Lemma 2.2.1</a></h3>
<hr />
<p><em>If \( a \) and \( b \) are coprime, the residues of \( a \), \( 2a \), \( 3a \), ..., \( (b-1)a \) modulo \( b \) are all distinct.</em></p>
<hr />
<p><strong>Proof:</strong> Suppose, for contradiction, that there exist \( x, y \in \{1, 2, \dots, b-1\} \) with \( x \neq y \) such that \( xa \equiv ya \pmod{b} \). Then \( (x-y)a \equiv 0 \pmod{b} \), implying \( b \mid (x-y)a \). Since \( a \) and \( b \) are coprime, we must have \( b \mid (x-y) \). However, \( |x-y| &lt; b \), so this is only possible if \( x = y \), contradicting our assumption. Therefore, all residues must be distinct.</p>
<h3 id="theorem-222"><a class="header" href="#theorem-222">Theorem 2.2.2</a></h3>
<hr />
<p><em>For any integers \( a \) and \( b \), the equation \( ax + by = 1 \) has a solution in integers \( x \) and \( y \) if and only if \( a \) and \( b \) are coprime.</em></p>
<hr />
<p><strong>Proof:</strong></p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> Suppose \( a \) and \( b \) are not coprime, let \( d = \gcd(a,b) &gt; 1 \). Then \( d \mid a \) and \( d \mid b \), so \( d \mid (ax + by) \) for any integers \( x \) and \( y \). Thus, \( ax + by \neq 1 \) for any \( x \) and \( y \).</li>
<li><strong>(\( \Leftarrow \))</strong> Suppose \( a \) and \( b \) are coprime. By the previous lemma, the residues of \( a \), \( 2a \), ..., \( (b-1)a \) modulo \( b \) are all distinct. Therefore, there exists an \( m \in \{1, 2, ..., b-1\} \) such that \( ma \equiv 1 \pmod{b} \). This means there exists an integer \( n \) such that \( ma = bn + 1 \), or equivalently, \( ma - bn = 1 \).</li>
</ul>
<h3 id="theorem-b√©zouts-identity"><a class="header" href="#theorem-b√©zouts-identity">Theorem: B√©zout's Identity</a></h3>
<hr />
<p><em>For any integers \( a \) and \( b \), we have:
\(
a\mathbb{Z} + b \mathbb{Z} = \gcd(a, b)\mathbb{Z}
\)</em></p>
<hr />
<p><strong>Proof:</strong></p>
<p>This statement is equivalent to proving that \( ax + by = c \) has an integer solution if and only if \( c \) is a multiple of \( \gcd(a,b) \).</p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> If \( ax + by = c \) for some integers \( x \) and \( y \), then \( \gcd(a,b) \mid a \) and \( \gcd(a,b) \mid b \), so \( \gcd(a,b) \mid (ax + by) = c \).</li>
<li><strong>(\( \Leftarrow \))</strong> Let \( c = k\gcd(a,b) \) for some integer \( k \). We can write \( a = p\gcd(a,b) \) and \( b = q\gcd(a,b) \), where \( p \) and \( q \) are coprime. By the previous theorem, there exist integers \( m \) and \( n \) such that \( pm + qn = 1 \). Multiplying both sides by \( k\gcd(a,b) \), we get:
\[
akm + bkn = c
\]
Thus, \( x = km \) and \( y = kn \) are integer solutions to \( ax + by = c \).</li>
</ul>
<p>This theorem implies that for any integers \( a \), \( b \), and \( n \), the equation \( ax + by = n \) has an integer solution if and only if \( \gcd(a,b) \mid n \).</p>
<h3 id="theorem-223"><a class="header" href="#theorem-223">Theorem 2.2.3</a></h3>
<hr />
<p><em>\( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z}/m\mathbb{Z} \) if and only if \( \gcd(a,m) = 1 \).</em></p>
<hr />
<p><strong>Proof:</strong></p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> Suppose \( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z}/m\mathbb{Z} \). Then there exists an integer \( x \) such that \( ax \equiv 1 \pmod{m} \). Let \( g = \gcd(a,m) \). Since \( g \mid ax \) and \( g \mid (ax - 1) \), we must have \( g \mid 1 \), so \( g = 1 \).</li>
<li><strong>(\( \Leftarrow \))</strong> Suppose \( \gcd(a,m) = 1 \). By B√©zout's identity, there exist integers \( x \) and \( y \) such that \( ax + my = 1 \). Thus, \( x + m\mathbb{Z} \) is the multiplicative inverse of \( a + m\mathbb{Z} \) in \( \mathbb{Z}/m\mathbb{Z} \).</li>
</ul>
<h3 id="definition-residue-class-ring"><a class="header" href="#definition-residue-class-ring">Definition: Residue Class Ring</a></h3>
<hr />
<p><em>\( (\mathbb{Z} / m \mathbb{Z}, +, \cdot) \) is a commutative ring where \( 1 + m \mathbb{Z} \) is the multiplicative identity element. This ring is called the residue class ring modulo \( m \).</em></p>
<hr />
<p><strong>Example:</strong> \( \mathbb{Z}/4\mathbb{Z} = \{0 + 4\mathbb{Z}, 1 + 4\mathbb{Z}, 2 + 4\mathbb{Z}, 3 + 4\mathbb{Z}\} \).</p>
<h3 id="definition-primitive-residue-class"><a class="header" href="#definition-primitive-residue-class">Definition: Primitive Residue Class</a></h3>
<hr />
<p><em>A residue class \( a + m\mathbb{Z} \) is called primitive if \( \gcd(a, m) = 1 \).</em></p>
<hr />
<p><strong>Example:</strong> In \( \mathbb{Z}/6\mathbb{Z} \), the primitive residue classes are \( 1 + 6\mathbb{Z} \) and \( 5 + 6\mathbb{Z} \).</p>
<h3 id="theorem-224"><a class="header" href="#theorem-224">Theorem 2.2.4</a></h3>
<hr />
<p><em>A residue ring \( \mathbb{Z} / m\mathbb{Z} \) is a field if and only if \( m \) is a prime number.</em></p>
<hr />
<p><strong>Proof:</strong> TBD</p>
<p><strong>Example:</strong> For \( m = 5 \), \( \mathbb{Z}/5\mathbb{Z} = \{0 + 5\mathbb{Z}, 1 + 5\mathbb{Z}, 2 + 5\mathbb{Z}, 3 + 5\mathbb{Z}, 4 + 5\mathbb{Z}\} \) forms a field because 5 is a prime number, and every non-zero element has a multiplicative inverse.</p>
<h3 id="definition-primitive-residue-class-group"><a class="header" href="#definition-primitive-residue-class-group">Definition: Primitive Residue Class Group</a></h3>
<hr />
<p><em>The group of all primitive residue classes modulo \( m \) is called the primitive residue class group, denoted by \( (\mathbb{Z}/m\mathbb{Z})^{\times} \).</em></p>
<hr />
<p><strong>Example:</strong> For \( m = 8 \), the set of all primitive residue classes is \( (\mathbb{Z}/8\mathbb{Z})^{\times} = \{1 + 8\mathbb{Z}, 3 + 8\mathbb{Z}, 5 + 8\mathbb{Z}, 7 + 8\mathbb{Z}\} \). These are the integers less than 8 that are coprime to 8 (i.e., \(\gcd(a, 8) = 1\)).</p>
<p>Contrast this with \( m = 9 \). The primitive residue class group is \((\mathbb{Z}/9\mathbb{Z})^{\times} = \{1 + 9\mathbb{Z}, 2 + 9\mathbb{Z}, 4 + 9\mathbb{Z}, 5 + 9\mathbb{Z}, 7 + 9\mathbb{Z}, 8 + 9\mathbb{Z}\}\), as these are the integers less than 9 that are coprime to 9.</p>
<h3 id="definition-eulers-totient-function"><a class="header" href="#definition-eulers-totient-function">Definition: Euler's Totient Function</a></h3>
<hr />
<p><em>Euler's totient function \(\phi(m)\) is equal to the order of the primitive residue class group modulo \(m\), which is the number of integers less than \(m\) and coprime to \(m\).</em></p>
<hr />
<p><strong>Example:</strong> For \(m = 12\), \(\phi(12) = 4\) because there are 4 integers less than 12 that are coprime to 12: \({1, 5, 7, 11}\).</p>
<p>For \(m = 10\), \(\phi(10) = 4\), as there are also 4 integers less than 10 that are coprime to 10: \({1, 3, 7, 9}\).</p>
<h3 id="definition-order-of-an-element-within-a-group"><a class="header" href="#definition-order-of-an-element-within-a-group">Definition: Order of an Element within a Group</a></h3>
<hr />
<p><em>The order of \(g \in G\) is the smallest natural number \(e\) such that \(g^{e} = 1\). We denote it as \(\text{order}_g(g)\)or \(\text{order } g\).</em></p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/7\mathbb{Z})^{\times}\), the element 3 has order 6 because \(3^6 \bmod 7 = 1\). In other words, \(3 \times 3 \times 3 \times 3 \times 3 \times 3 \bmod 7 = 1\), and 6 is the smallest such exponent.</p>
<h3 id="definition-subgroup"><a class="header" href="#definition-subgroup">Definition: Subgroup</a></h3>
<hr />
<p><em>A subset \(U \subseteq G\) is a subgroup of \(G\) if \(U\) itself is a group under the operation of \(G\).</em></p>
<hr />
<p><strong>Example:</strong> Consider \((\mathbb{Z}/8\mathbb{Z})^{\times} = \{1 + 8\mathbb{Z}, 3+ 8\mathbb{Z}, 5+ 8\mathbb{Z}, 7+ 8\mathbb{Z}\}\) under multiplication modulo 8. The subset \({1+ 8\mathbb{Z}, 7+ 8\mathbb{Z}}\) forms a subgroup because it satisfies the group properties: closed under multiplication, contains the identity element (1), and every element has an inverse (\(7 \times 7 \equiv 1 \bmod 8\)).</p>
<h3 id="definition-subgroup-generated-by-g"><a class="header" href="#definition-subgroup-generated-by-g">Definition: Subgroup Generated by \(g\)</a></h3>
<hr />
<p><em>The set \(\{g^{k} : k \in \mathbb{Z}\}\), for some element \(g \in G\), forms a subgroup of \(G\) and is called the subgroup generated by \(g\), denoted by \(\langle g \rangle\).</em></p>
<hr />
<p><strong>Example:</strong> Consider the group \((\mathbb{Z}/7\mathbb{Z})^{\times} = \{1+ 7\mathbb{Z}, 2+ 7\mathbb{Z}, 3+ 7\mathbb{Z}, 4+ 7\mathbb{Z}, 5+ 7\mathbb{Z}, 6+ 7\mathbb{Z}\}\) under multiplication modulo 7. If we take \(g = 3\), then \(\langle 3 +7\mathbb{Z} \rangle =\) \(\{3^1+7\mathbb{Z}, 3^2+7\mathbb{Z}, 3^3+7\mathbb{Z}, 3^4+7\mathbb{Z}, 3^5+7\mathbb{Z}, 3^6+7\mathbb{Z}\} \bmod 7 =\) \(\{3+7\mathbb{Z}, 2+7\mathbb{Z}, 6+7\mathbb{Z}, 4+7\mathbb{Z}, 5+7\mathbb{Z}, 1+7\mathbb{Z}\}\), which forms a subgroup generated by 3. This subgroup contains all elements of \((\mathbb{Z}/7\mathbb{Z})^{\times}\), making 3 a generator of the entire group.</p>
<p>If \(g\) has a finite order \(e\), we have that \(\langle g \rangle = \{g^{k}: 0 \leq k \leq e\}\), meaning \(e\) is the order of \(\langle g \rangle\).</p>
<h3 id="definition-cyclic-group"><a class="header" href="#definition-cyclic-group">Definition: Cyclic Group</a></h3>
<hr />
<p><em>A group \(G\) is called a cyclic group if there exists an element \(g \in G\) such that \(G = \langle g \rangle\). In this case, \(g\) is called a generator of \(G\).</em></p>
<hr />
<p><strong>Example:</strong> The group \((\mathbb{Z}/6\mathbb{Z})^{\times} = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\) under multiplication modulo 6 is a cyclic group. In this case, both 1 and 5 are generators of the group because \(\langle 5 +6\mathbb{Z} \rangle = \{(5^1 \bmod 6)+6\mathbb{Z} = 5 +6\mathbb{Z}, (5^2 \bmod 6)+6\mathbb{Z} = 1+6\mathbb{Z}\}\). Since 5 generates all the elements of the group, \(G\) is cyclic.</p>
<h3 id="theorem-225"><a class="header" href="#theorem-225">Theorem 2.2.5</a></h3>
<hr />
<p><em>If \(G\) is a finite cyclic group, it has \(\phi(|G|)\)generators, and each generator has order \(|G|\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Consider the group \((\mathbb{Z}/8\mathbb{Z})^{\times} = \{1+8\mathbb{Z}, 3+8\mathbb{Z}, 5+8\mathbb{Z}, 7+8\mathbb{Z}\}\). This group is cyclic, and \(\phi(8) = 4\). The generators of this group are \(\{1+8\mathbb{Z}, 3+8\mathbb{Z}, 5+8\mathbb{Z}, 7+8\mathbb{Z}\}\), each of which generates the entire group when raised to successive powers modulo 8. Each generator has the same order, which is \(|G| = 4\).</p>
<h3 id="theorem-226"><a class="header" href="#theorem-226">Theorem 2.2.6</a></h3>
<hr />
<p><em>If \(G\) is a finite cyclic group, the order of any subgroup of \(G\) divides the order of \(G\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Consider the cyclic group \((\mathbb{Z}/6\mathbb{Z})^{\times} = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\) under multiplication modulo 6. If we take the subgroup \(\langle 5+6\mathbb{Z} \rangle = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\), this is a subgroup of order 2, and 2 divides the order of the original group, which is 6. This theorem generalizes this property: for any subgroup of a cyclic group, its order divides the order of the group.</p>
<h3 id="theorem-fermats-little-theorem"><a class="header" href="#theorem-fermats-little-theorem">Theorem: Fermat's Little Theorem</a></h3>
<hr />
<p><em>If \(\gcd(a, m) = 1\), then \(a^{\phi(m)} \equiv 1 \pmod{m}\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Take \(a = 2\) and \(m = 5\). Since \(\gcd(2, 5) = 1\), Fermat's Little Theorem tells us that \(2^{\phi(5)} = 2^4 \equiv 1 \bmod 5\). Indeed, \(2^4 = 16\) and \(16 \bmod 5 = 1\).</p>
<p>This theorem suggests that \(a^{\phi(m) - 1} + m \mathbb{Z}\) is the inverse residue class of \(a + m \mathbb{Z}\).</p>
<h3 id="theorem-227"><a class="header" href="#theorem-227">Theorem 2.2.7</a></h3>
<hr />
<p><em>The order of any element in a group divides the order of the group.</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> In the group \((\mathbb{Z}/7\mathbb{Z})^{\times}\), consider the element \(3 + 7\mathbb{Z}\). The order of \(3 + 7\mathbb{Z}\) is 6, as \(3^6 \equiv 1 \bmod 7\). The order of the group itself is also 6, and indeed, the order of the element divides the order of the group.</p>
<h3 id="theorem-generalization-of-fermats-little-theorem"><a class="header" href="#theorem-generalization-of-fermats-little-theorem">Theorem: Generalization of Fermat's Little Theorem</a></h3>
<hr />
<p><em>For any element \(g \in G\), we have \(g^{|G|} = 1\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> In the group \((\mathbb{Z}/7\mathbb{Z})^{\times}\), for any element \(g\), such as \(g = 3 + 7\mathbb{Z}\), we have \(3^6 \equiv 1 \bmod 7\). This holds for any \(g \in (\mathbb{Z}/7\mathbb{Z})^{\times}\) because the order of the group is 6. Thus, \(g^{|G|} = 1\) is satisfied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polynomials"><a class="header" href="#polynomials">Polynomials</a></h1>
<h3 id="definition-polynomial"><a class="header" href="#definition-polynomial">Definition: Polynomial</a></h3>
<hr />
<p><em>A univariate polynomial over a commutative ring \(R\) with unity \(1\) is an expression of the form \(f(x) = a_n x^{n} + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0\), where \(x\) is a variable and coefficients \(a_0, \ldots, a_n\) belong to \(R\). The set of all polynomials over \(R\) in the variable \(x\) is denoted as \(R[x]\).</em></p>
<hr />
<p><strong>Example:</strong> In \(\mathbb{Z}[x]\), we have polynomials such as \(2x^3 + x + 1\), \(x\), and \(1\). In \(\mathbb{R}[x]\), we have polynomials like \(\pi x^2 - \sqrt{2}x + e\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A struct representing a polynomial over a finite field.
#[derive(Debug, Clone, PartialEq)]
pub struct Polynomial&lt;F: Field&gt; {
    /// Coefficients of the polynomial in increasing order of degree.
    pub coef: Vec&lt;F&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-degree"><a class="header" href="#definition-degree">Definition: Degree</a></h3>
<hr />
<p><em>The degree of a non-zero polynomial \(f(x) = a_n x^{n} + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0\), denoted as \(\deg f\), is the largest integer \(n\) such that \(a_n \neq 0\). The zero polynomial is defined to have degree \(-1\).</em></p>
<hr />
<p><strong>Example</strong></p>
<ul>
<li>\(\deg(2x^3 + x + 1) = 3\)</li>
<li>\(\deg(x) = 1\)</li>
<li>\(\deg(1) = 0\)</li>
<li>\(\deg(0) = -1\)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    /// Removes trailing zeroes from a polynomial's coefficients.
    fn trim_trailing_zeros(poly: Vec&lt;F&gt;) -&gt; Vec&lt;F&gt; {
        let mut trimmed = poly;
        while trimmed.last() == Some(&amp;F::zero(None)) {
            trimmed.pop();
        }
        trimmed
    }

    /// Returns the degree of the polynomial.
    pub fn degree(&amp;self) -&gt; isize {
        let trimmed = Self::trim_trailing_zeros(self.poly.clone());
        if trimmed.is_empty() {
            -1
        } else {
            (trimmed.len() - 1) as isize
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-sum-of-polynomials"><a class="header" href="#definition-sum-of-polynomials">Definition: Sum of Polynomials</a></h3>
<hr />
<p><em>For polynomials \(f(x) = \sum_{i=0}^n a_i x^i\) and \(g(x) = \sum_{i=0}^m b_i x^i\), their sum is defined as: \((f + g)(x) = \sum_{i=0}^{\max(n,m)} (a_i + b_i) x^i\), where we set \(a_i = 0\) for \(i &gt; n\) and \(b_i = 0\) for \(i &gt; m\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = 2x^2 + 3x + 1\) and \(g(x) = x^3 - x + 4\). Then, \((f + g)(x) = x^3 + 2x^2 + 2x + 5\)</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn add_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        let max_len = std::cmp::max(self.coef.len(), other.coef.len());
        let mut result = Vec::with_capacity(max_len);

        let zero = F::zero();

        for i in 0..max_len {
            let a = self.coef.get(i).unwrap_or(&amp;zero);
            let b = other.coef.get(i).unwrap_or(&amp;zero);
            result.push(a.add_ref(b));
        }
        Polynomial {
            coef: Self::trim_trailing_zeros(result),
        }
    }
}

impl&lt;F: Field&gt; Add for Polynomial&lt;F&gt; {
    type Output = Self;

    fn add(self, other: Self) -&gt; Polynomial&lt;F&gt; {
        self.add_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-product-of-polynomials"><a class="header" href="#definition-product-of-polynomials">Definition: Product of polynomials</a></h3>
<hr />
<p><em>For polynomials \(f(x) = \sum_{i=0}^n a_i x^i\) and \(g(x) = \sum_{j=0}^m b_j x^j\), their product is defined as: \((fg)(x) = \sum_{k=0}^{n+m} c_k x^k\), where \(c_k = \sum_{i+j=k} a_i b_j\)</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x + 1\) and \(g(x) = x^2 - 1\). Then, \((fg)(x) = x^3 + x^2 - x - 1\)</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn mul_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        if self.is_zero() || other.is_zero() {
            return Polynomial::&lt;F&gt;::zero();
        }
        let mut result = vec![F::zero(); (self.degree() + other.degree() + 1) as usize];

        for (i, a) in self.coef.iter().enumerate() {
            for (j, b) in other.coef.iter().enumerate() {
                result[i + j] = result[i + j].add_ref(&amp;a.mul_ref(b));
            }
        }
        Polynomial {
            coef: Polynomial::&lt;F&gt;::trim_trailing_zeros(result),
        }
    }
}

impl&lt;F: Field&gt; Mul&lt;Polynomial&lt;F&gt;&gt; for Polynomial&lt;F&gt; {
    type Output = Self;

    fn mul(self, other: Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        self.mul_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lemma-231"><a class="header" href="#lemma-231">Lemma 2.3.1</a></h3>
<p>Let \(K\) be a field.</p>
<hr />
<p><em>Let \(f, g \in K[x]\) be non-zero polynomials. Then, \(\deg(fg) = \deg f + \deg g\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x^2 + 1\) and \(g(x) = x^3 - x\) in \(\mathbb{R}[x]\). Then, \(\deg(fg) = \deg(x^5 - x^3 + x^2 + 1) = 5 = 2 + 3 = \deg f + \deg g\)</p>
<h3 id="theorem-232"><a class="header" href="#theorem-232">Theorem 2.3.2</a></h3>
<p>We can also define division in the polynomial ring \(K[x]\).</p>
<hr />
<p><em>Let \(f, g \in K[x]\), with \(g \neq 0\). There exist unique polynomials \(q, r \in K[x]\) that satisfy \(f = qg + r\) and either \(\deg r &lt; \deg g\) or \(r = 0\).</em></p>
<hr />
<p><strong>Proof</strong>
TBD</p>
<p>\(q\) is called the quotient of \(f\) divided by \(g\), and \(r\) is called the remainder; we write \(r = f \bmod g\).</p>
<p><strong>Example:</strong> In \(\mathbb{R}[x]\), let \(f(x) = x^3 + 2x^2 - x + 3\) and \(g(x) = x^2 + 1\).  Then \(f = qg + r\) where \(q(x) = x + 2\) and \(r(x) = -3x + 1\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn div_rem_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; (Polynomial&lt;F&gt;, Polynomial&lt;F&gt;) {
        if self.degree() &lt; other.degree() {
            return (Polynomial::zero(), self.clone());
        }

        let mut remainder_coeffs = Self::trim_trailing_zeros(self.coef.clone());
        let divisor_coeffs = Self::trim_trailing_zeros(other.coef.clone());
        let divisor_lead_inv = divisor_coeffs.last().unwrap().inverse();

        let mut quotient = vec![F::zero(); self.degree() as usize - other.degree() as usize + 1];

        while remainder_coeffs.len() &gt;= divisor_coeffs.len() {
            let lead_term = remainder_coeffs.last().unwrap().mul_ref(&amp;divisor_lead_inv);
            let deg_diff = remainder_coeffs.len() - divisor_coeffs.len();
            quotient[deg_diff] = lead_term.clone();

            for i in 0..divisor_coeffs.len() {
                remainder_coeffs[deg_diff + i] = remainder_coeffs[deg_diff + i]
                    .sub_ref(&amp;(lead_term.mul_ref(&amp;divisor_coeffs[i])));
            }
            remainder_coeffs = Self::trim_trailing_zeros(remainder_coeffs);
        }

        (
            Polynomial {
                coef: Self::trim_trailing_zeros(quotient),
            },
            Polynomial {
                coef: remainder_coeffs,
            },
        )
    }
}

impl&lt;F: Field&gt; Div for Polynomial&lt;F&gt; {
    type Output = Self;

    fn div(self, other: Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        self.div_rem_ref(&amp;other).0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="corollary"><a class="header" href="#corollary">Corollary</a></h3>
<hr />
<p><em>Let \(f \in K[x]\) be a non-zero polynomial, and \(a \in K\) such that \(f(a) = 0\). Then, there exists a polynomial \(q \in K[x]\) such that \(f(x) = (x - a)q(x)\). In other words, \((x - a)\) is a factor of \(f(x)\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x^2 + 1 \in (\mathbb{Z}/2\mathbb{Z})[x]\). We have \(f(1) = 1^2 + 1 = 0\) in \(\mathbb{Z}/2\mathbb{Z}\), and indeed: \(x^2 + 1 = (x - 1)^2 = x^2 - 2x + 1 = x^2 + 1\) in \((\mathbb{Z}/2\mathbb{Z})[x]\)</p>
<h3 id="theorem-lagrange-interpolation"><a class="header" href="#theorem-lagrange-interpolation">Theorem: Lagrange Interpolation</a></h3>
<hr />
<p><em>A \(n\)-degre polynomial \(P(x)\) that goes through different \(n + 1\) points \(\{(x_1, y_1), (x_2, y_2), \cdots (x_{n + 1}, y_{n + 1})\}\) is uniquely represented as follows:</em></p>
<p>\[
P(x) = \sum^{n+1}_{i=1} y_i \frac{f_i(x)}{f_i(x_i)}
\]</p>
<p><em>, where \(f_i(x) = \prod_{k \neq i} (x - x_k)\)</em></p>
<hr />
<p><strong>Proof</strong> TBD</p>
<p><strong>Example:</strong> The quadratic polynomial that goes through \(\{(1, 0), (2, 3), (3, 8)\}\) is as follows:</p>
<p>\begin{align*}
P(x) = 0 \frac{(x - 2)(x - 3)}{(1 - 2) (1 - 3)} + 3 \frac{(x - 1)(x - 3)}{(2 - 1) (2 - 3)} + 8 \frac{(x - 1)(x - 2)}{(3 - 1) (3 - 2)} = x^{2} - 1
\end{align*}</p>
<p>Note that Lagrange interpolation finds the lowest degree of interpolating polynomial for the given vector.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    pub fn interpolate(x_values: &amp;[F], y_values: &amp;[F]) -&gt; Polynomial&lt;F&gt; {
        let mut lagrange_polys = vec![];
        let numerators = Polynomial::from_monomials(x_values);

        for j in 0..x_values.len() {
            let mut denominator = F::one();
            for i in 0..x_values.len() {
                if i != j {
                    denominator = denominator * (x_values[j].sub_ref(&amp;x_values[i]));
                }
            }
            let cur_poly = numerators
                .clone()
                .div(Polynomial::from_monomials(&amp;[x_values[j].clone()]) * denominator);
            lagrange_polys.push(cur_poly);
        }

        let mut result = Polynomial { coef: vec![] };
        for (j, lagrange_poly) in lagrange_polys.iter().enumerate() {
            result = result + lagrange_poly.clone() * y_values[j].clone();
        }
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="proposition-homomorphisms-of-lagrange-interpolation"><a class="header" href="#proposition-homomorphisms-of-lagrange-interpolation">Proposition: Homomorphisms of Lagrange Interpolation</a></h3>
<p><em>Let \(L(v)\) and \(L(w)\) be the polynomial resulting from Lagrange Interpolation on the output (\(y\)) vector \(v\) and \(w\) for the same inputs (\(x\)). Then, the following properties hold:</em></p>
<ul>
<li><em>Additivity: \(L(v + w) = L(v) + L(w)\) for any vectors \(v\) and \(w\)</em></li>
<li><em>Scalar multiplication: \(L(\gamma v) = \gamma L(v)\) for any scalar \(\gamma\) and vector \(v\)</em></li>
</ul>
<p><strong>Proof</strong></p>
<p>Let \(v = (v_1, \ldots, v_n)\) and \(w = (w_1, \ldots, w_n)\) be vectors, and \(x_1, \ldots, x_n\) be the interpolation points.</p>
<p>\begin{align*}
L(v + w) &amp;= \sum_{i=1}^n (v_i + w_i) \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \sum_{i=1}^n v_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} + \sum_{i=1}^n w_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = L(v) + L(w) \\
L(\gamma v) &amp;= \sum_{i=1}^n (\gamma v_i) \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \gamma \sum_{i=1}^n v_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \gamma L(v)
\end{align*}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="galois-field"><a class="header" href="#galois-field">Galois Field</a></h1>
<p>We will now discuss the construction of finite fields with \(p^n\) elements, where \(p\) is a prime number and \(n\) is a positive integer. These fields are also known as Galois fields, denoted as \(GF(p^n)\). It is evident that \(\mathbb{Z}/p\mathbb{Z}\) is isomorphic to \(GF(p)\).</p>
<h3 id="definition-irreducible-polynomial"><a class="header" href="#definition-irreducible-polynomial">Definition: Irreducible Polynomial</a></h3>
<hr />
<p><em>A polynomial \(f \in (\mathbb{Z}/p\mathbb{Z})[X]\) of degree \(n\) is called irreducible over \(\mathbb{Z}/p\mathbb{Z}\) if it cannot be factored as a product of two polynomials of lower degree in \((\mathbb{Z}/p\mathbb{Z})[X]\).</em></p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/2\mathbb{Z})[X]\):</p>
<ul>
<li>\(X^2 + X + 1\) is irreducible</li>
<li>\(X^2 + 1 = (X + 1)^2\) is reducible</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IrreduciblePoly&lt;F: Field&gt;: Debug + Clone + Hash {
    fn modulus() -&gt; &amp;'static Polynomial&lt;F&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-residue-class-modulo-a-polynomial"><a class="header" href="#definition-residue-class-modulo-a-polynomial">Definition: Residue Class modulo a Polynomial</a></h3>
<p>To construct \(GF(p^n)\), we use an irreducible polynomial of degree \(n\) over \(\mathbb{Z}/p\mathbb{Z}\).</p>
<hr />
<p><em>For \(f, g \in (\mathbb{Z}/p\mathbb{Z})[X]\), the residue class of \(g \bmod f\) is the set of all polynomials \(h \in (\mathbb{Z}/p\mathbb{Z})[X]\) such that \(h \equiv g \pmod{f}\). This class is denoted as:</em></p>
<p>\[ g + f(\mathbb{Z}/p\mathbb{Z})[X] = \{g + hf : h \in (\mathbb{Z}/p\mathbb{Z})[X]\} \]</p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/2\mathbb{Z})[X]\), with \(f(X) = X^2 + X + 1\), the residue classes \(\bmod f\) are:</p>
<ul>
<li>\(0 + f(\mathbb{Z}/2\mathbb{Z})[X] = \{0, X^2 + X + 1, X^2 + X, X^2 + 1, X^2, X + 1, X, 1\}\)</li>
<li>\(1 + f(\mathbb{Z}/2\mathbb{Z})[X] = \{1, X^2 + X, X^2 + 1, X^2, X + 1, X, 0, X^2 + X + 1\}\)</li>
<li>\(X + f(\mathbb{Z}/2\mathbb{Z})[X] = \{X, X^2 + 1, X^2, X^2 + X + 1, X + 1, 1, X^2 + X, 0\}\)</li>
<li>\((X + 1) + f(\mathbb{Z}/2\mathbb{Z})[X] = \{X + 1, X^2, X^2 + X + 1, X^2 + X, 1, 0, X^2 + 1, X\}\)</li>
</ul>
<p>These four residue classes form \(GF(4)\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt;
    ExtendedFieldElement&lt;M, P&gt;
{
    pub fn new(poly: Polynomial&lt;FiniteFieldElement&lt;M&gt;&gt;) -&gt; Self {
        let result = Self {
            poly: poly,
            _phantom: PhantomData,
        };
        result.reduce()
    }

    fn reduce(&amp;self) -&gt; Self {
        Self {
            poly: &amp;self.poly.reduce() % P::modulus(),
            _phantom: PhantomData,
        }
    }

    pub fn degree(&amp;self) -&gt; isize {
        P::modulus().degree()
    }

    pub fn from_base_field(value: FiniteFieldElement&lt;M&gt;) -&gt; Self {
        Self::new((Polynomial { coef: vec![value] }).reduce()).reduce()
    }
}

impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt; Field
    for ExtendedFieldElement&lt;M, P&gt;
{
    fn inverse(&amp;self) -&gt; Self {
        let mut lm = Polynomial::&lt;FiniteFieldElement&lt;M&gt;&gt;::one();
        let mut hm = Polynomial::zero();
        let mut low = self.poly.clone();
        let mut high = P::modulus().clone();

        while !low.is_zero() {
            let q = &amp;high / &amp;low;
            let r = &amp;high % &amp;low;
            let nm = hm - (&amp;lm * &amp;q);
            high = low;
            hm = lm;
            low = r;
            lm = nm;
        }

        Self::new(hm * high.coef[0].inverse())
    }

    fn div_ref(&amp;self, other: &amp;Self) -&gt; Self {
        self.mul_ref(&amp;other.inverse())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="theorem"><a class="header" href="#theorem">Theorem:</a></h3>
<hr />
<p><em>If \(f \in (\mathbb{Z}/p\mathbb{Z})[X]\) is an irreducible polynomial of degree \(n\), then the residue ring \((\mathbb{Z}/p\mathbb{Z})[X]/(f)\) is a field with \(p^n\) elements, isomorphic to \(GF(p^n)\).</em></p>
<hr />
<p><strong>Proof</strong> (Outline) The irreducibility of \(f\) ensures that \((f)\) is a maximal ideal in \((\mathbb{Z}/p\mathbb{Z})[X]\), making the quotient ring a field. The number of elements is \(p^n\) because there are \(p^n\) polynomials of degree less than \(n\) over \(\mathbb{Z}/p\mathbb{Z}\).</p>
<p>This construction allows us to represent elements of \(GF(p^n)\) as polynomials of degree less than \(n\) over \(\mathbb{Z}/p\mathbb{Z}\). Addition is performed coefficient-wise modulo \(p\), while multiplication is performed modulo the irreducible polynomial \(f\).</p>
<p><strong>Example:</strong> To construct \(GF(8)\), we can use the irreducible polynomial \(f(X) = X^3 + X + 1\) over \(\mathbb{Z}/2\mathbb{Z}\). The elements of \(GF(8)\) are represented by:
\[ \{0, 1, X, X+1, X^2, X^2+1, X^2+X, X^2+X+1\} \]
For instance, multiplication in \(GF(8)\):
\[ (X^2 + 1)(X + 1) = X^3 + X^2 + X + 1 \equiv X^2 \pmod{X^3 + X + 1} \]</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt; Ring
    for ExtendedFieldElement&lt;M, P&gt;
{
    fn add_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly + &amp;other.poly)
    }

    fn mul_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly * &amp;other.poly)
    }

    fn sub_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly - &amp;other.poly)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lemma-schwartz---zippel-lemma"><a class="header" href="#lemma-schwartz---zippel-lemma">Lemma: Schwartz - Zippel Lemma</a></h3>
<hr />
<p><em>Let \(\mathbb{F}\) be a field and \(P: F^m \rightarrow \mathbb{F}\) and \(Q: \mathbb{F}^m \rightarrow \mathbb{F}\) be two distinct multivariate polynomials of total degree at most \(n\). For any finite subset \(\mathbb{S} \subseteq \mathbb{F}\), we have:</em></p>
<p>\begin{align}
Pr_{u \sim \mathbb{S}^{m}}[P(u) = Q(u)] \leq \frac{n}{|\mathbb{S}|}
\end{align}</p>
<p><em>, where \(u\) is drawn uniformly at random from \(\mathbb{S}^m\).</em></p>
<hr />
<p><strong>Proof</strong> TBD</p>
<p>This lemma states that if \(\mathbb{S}\) is sufficiently large and \(n\) is relatively small, the probability that the two different polynomials return the same value for a randomly chosen input is negligibly small. In other words, if we observe \(P(u) = Q(u)\) for a random input \(u\), we can conclude with high probability that \(P\) and \(Q\) are identical polynomials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elliptic-curve"><a class="header" href="#elliptic-curve">Elliptic curve</a></h1>
<h3 id="definition-elliptic-curve"><a class="header" href="#definition-elliptic-curve">Definition: Elliptic Curve</a></h3>
<hr />
<p><em>An elliptic curve \(E\) over a finite field \(\mathbb{F}_{p}\) is defined by the equation:</em></p>
<p>\begin{equation}
y^2 = x^3 + a x + b
\end{equation}</p>
<p><em>, where \(a, b \in \mathbb{F}_{p}\) and the discriminant \(\Delta_{E} = 4a^3 + 27b^2 \neq 0\).</em></p>
<hr />
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait EllipticCurve: Debug + Clone + PartialEq {
    fn get_a() -&gt; BigInt;
    fn get_b() -&gt; BigInt;
}

#[derive(Debug, Clone, PartialEq)]
pub struct EllipticCurvePoint&lt;F: Field, E: EllipticCurve&gt; {
    pub x: Option&lt;F&gt;,
    pub y: Option&lt;F&gt;,
    _phantom: PhantomData&lt;E&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-mathbbf_p-rational-point"><a class="header" href="#definition-mathbbf_p-rational-point">Definition: \(\mathbb{F}_{p}\)-Rational Point</a></h3>
<hr />
<p><em>An \(\mathbb{F}_{p}\)-rational point on an elliptic curve \(E\) is a point \((x, y)\) where both \(x\) and \(y\) are elements of \(\mathbb{F}_{p}\) and satisfy the curve equation, or the point at infinity \(\mathcal{O}\).</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + 3x + 4\) over \(\mathbb{F}_7\), the \(\mathbb{F}_{7}\)-rational points are:
\(\{(0, 2), (0, 5), (1, 1), (1, 6), (2, 2), (2, 5), (5, 1), (5, 6), \mathcal{O}\}\)</p>
<h3 id="definition-the-point-at-infinity"><a class="header" href="#definition-the-point-at-infinity">Definition: The point at infinity</a></h3>
<hr />
<p>The point at infinity denoted \(\mathcal{O}\), is a special point on the elliptic curve that serves as the identity element for the group operation. It can be visualized as the point where all vertical lines on the curve meet.</p>
<hr />
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field, E: EllipticCurve&gt; EllipticCurvePoint&lt;F, E&gt; {
    pub fn point_at_infinity() -&gt; Self {
        EllipticCurvePoint {
            x: None,
            y: None,
            _phantom: PhantomData,
        }
    }

    pub fn is_point_at_infinity(&amp;self) -&gt; bool {
        self.x.is_none() || self.y.is_none()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-addition-on-elliptic-curve"><a class="header" href="#definition-addition-on-elliptic-curve">Definition: Addition on Elliptic Curve</a></h3>
<hr />
<p><em>For an elliptic curve \(E: y^2 = x^3 + ax + b\), the addition of points \(P\) and \(Q\) to get \(R = P + Q\) is defined as follows:</em></p>
<ul>
<li>
<p><em>If \(P = \mathcal{O}\), \(R = Q\).</em></p>
</li>
<li>
<p><em>If \(Q = \mathcal{O}\), \(R = P\).</em></p>
</li>
<li>
<p><em>Otherwise, let \(P = (x_P, y_P), Q = (x_Q, y_Q)\). Then:</em></p>
<ul>
<li><em>If \(y_P = -y_Q\), \(R = \mathcal{O}\)</em></li>
<li><em>If \(y_P \neq -y_Q\), \(R = (x_R = \lambda^2 - x_P - x_Q, y_R = \lambda(x_P - x_R) - y_P)\), where \(\lambda = \)</em> \( \begin{cases}
\frac{y_P - y_Q}{x_P - x_Q} \quad &amp;\hbox{If } (x_P \neq x_Q) \\
\frac{3^{2}_{P} + a}{2y_P} \quad &amp;\hbox{Otherwise}
\end{cases}\)</li>
</ul>
</li>
</ul>
<hr />
<p><strong>Example:</strong> On \(E: y^2 = x^3 + 2x + 3\) over \(\mathbb{F}_{7}\), let \(P = (5, 1)\) and \(Q = (4, 4)\). Then, \(P + Q = (0, 5)\), where \(\lambda = \frac{1 - 4}{5 - 4} \equiv 4 \bmod 7\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field, E: EllipticCurve&gt; EllipticCurvePoint&lt;F, E&gt; {
    pub fn add_ref(&amp;self, other: &amp;Self) -&gt; Self {
        if self.is_point_at_infinity() {
            return other.clone();
        }
        if other.is_point_at_infinity() {
            return self.clone();
        }

        if self.x == other.x &amp;&amp; self.y == other.y {
            return self.double();
        } else if self.x == other.x {
            return Self::point_at_infinity();
        }

        let slope = self.line_slope(&amp;other);
        let x1 = self.x.as_ref().unwrap();
        let y1 = self.y.as_ref().unwrap();
        let x2 = other.x.as_ref().unwrap();
        let y2 = other.y.as_ref().unwrap();

        let new_x = slope.mul_ref(&amp;slope).sub_ref(&amp;x1).sub_ref(&amp;x2);
        let new_y = ((-slope.clone()).mul_ref(&amp;new_x)) + (&amp;slope.mul_ref(&amp;x1).sub_ref(&amp;y1));
        assert!(new_y == -slope.clone() * &amp;new_x + slope.mul_ref(&amp;x2).sub_ref(&amp;y2));

        Self::new(new_x, new_y)
    }
}

impl&lt;F: Field, E: EllipticCurve&gt; Add for EllipticCurvePoint&lt;F, E&gt; {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        self.add_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-mordell-weil-group"><a class="header" href="#definition-mordell-weil-group">Definition: Mordell-Weil Group</a></h3>
<hr />
<p><em>The Mordell-Weil group of an elliptic curve \(E\) is the group of rational points on \(E\) under the addition operation defined above.</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + x + 6\) over \(\mathbb{F}_{11}\), the Mordell-Weil group is the set of all \(\mathbb{F}_{11}\)-rational points on \(E\) with the elliptic curve addition operation.</p>
<h3 id="definition-group-order"><a class="header" href="#definition-group-order">Definition: Group Order</a></h3>
<hr />
<p><em>The group order of an elliptic curve \(E\) over \(\mathbb{F}_{p}\), denoted \(\#E(\mathbb{F}_{p})\), is the number of \(\mathbb{F}_{p}\)-rational points on \(E\), including the point at infinity.</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + x + 6\) over \(\mathbb{F}_{11}\), \(\#E(\mathbb{F}_{11}) = 13\).</p>
<h3 id="theorem-hasse-weil"><a class="header" href="#theorem-hasse-weil">Theorem: Hasse-Weil</a></h3>
<hr />
<p><em>Let \(\#E(\mathbb{F}_{p})\) be the group order of the elliptic curve \(E\) over \(\mathbb{F}_{p}\). Then:</em></p>
<p>\begin{equation}
p + 1 - 2 \sqrt{p} \leq \#E \leq p + 1 + 2 \sqrt{p}
\end{equation}</p>
<hr />
<p><strong>Example:</strong> For an elliptic curve over \(\mathbb{F}_{23}\), the Hasse-Weil theorem guarantees that:</p>
<p>\begin{equation*}
23 + 1 - 2 \sqrt{23} \simeq 14.42 \#E(\mathbb{F}_{23}) \geq 23 + 1 + 2 \sqrt{23} \simeq 33.58
\end{equation*}</p>
<h3 id="definition-point-order"><a class="header" href="#definition-point-order">Definition: Point Order</a></h3>
<p>The order of a point \(P\) on an elliptic curve is the smallest positive integer \(n\) such that \(nP = \mathcal{O}\) (where \(nP\) denotes \(P\) added to itself \(n\) times). We also denote the set of points of order \(n\), also called \textit{torsion} group, by</p>
<p>\begin{equation}
E[n] = \{P \in E: [n]P = \mathcal{O}\}
\end{equation}</p>
<p>Example: On \(E: y^2 = x^3 + 2x + 2\) over \(\mathbb{F}_{17}\), the point \(P = (5, 1)\) has order 18 because \(18P = \mathcal{O}\), and no smaller positive multiple of \(P\) equals \(\mathcal{O}\).</p>
<p>The intuitive view is that if you continue to add points to themselves (doubling, tripling, etc.), the lines drawn between the prior point and the next point will eventually become more vertical. When the line becomes vertical, it does not intersect the elliptic curve at any finite point. In elliptic curve geometry, a vertical line is considered to "intersect" the curve at a special place called the "point at infinity," This point is like a north pole in geographic terms: no matter which direction you go, if the line becomes vertical (reaching infinitely high), it converges to this point.</p>
<h3 id="definition-field-extension"><a class="header" href="#definition-field-extension">Definition: Field Extension</a></h3>
<hr />
<p><em>Let \(F\) and \(L\) be fields. If \(F \subseteq L\) and the operations of \(F\) are the same as those of \(L\), we call \(L\) a field extension of \(F\). This is denoted as \(L/F\).</em></p>
<hr />
<p>A field extension \(L/F\) naturally gives \(L\) the structure of a vector space over \(F\). The dimension of this vector space is called the degree of the extension.</p>
<p><strong>Examples:</strong></p>
<ul>
<li>\(\mathbb{C}/\mathbb{R}\) is a field extension with basis \(\{1, i\}\) and degree 2.</li>
<li>\(\mathbb{R}/\mathbb{Q}\) is an infinite degree extension.</li>
<li>\(\mathbb{Q}(\sqrt{2})/\mathbb{Q}\) is a degree 2 extension with basis \(\{1, \sqrt{2}\}\).</li>
</ul>
<h3 id="definition-algebraic-extension"><a class="header" href="#definition-algebraic-extension">Definition: Algebraic Extension</a></h3>
<hr />
<p><em>A field extension \(L/K\) is called algebraic if every element \(\alpha \in L\) is algebraic over \(K\), i.e., \(\alpha\) is the root of some non-zero polynomial with coefficients in \(K\).</em></p>
<p><em>For an algebraic element \(\alpha \in L\) over \(K\), we denote by \(K(\alpha)\) the smallest field containing both \(K\) and \(\alpha\).</em></p>
<hr />
<p><strong>Example:</strong></p>
<ul>
<li>\(\mathbb{C}/\mathbb{R}\) is algebraic: any \(z = a + bi \in \mathbb{C}\) is a root of \(x^2 - 2ax + (a^2 + b^2) \in \mathbb{R}[x]\).</li>
<li>\(\mathbb{Q}(\sqrt[3]{2})/\mathbb{Q}\) is algebraic: \(\sqrt[3]{2}\) is a root of \(x^3 - 2 \in \mathbb{Q}[x]\).</li>
<li>\(\mathbb{R}/\mathbb{Q}\) is not algebraic (a field extension that is not algebraic is called \textit{transcendental}).</li>
</ul>
<h3 id="definition-field-of-rational-functions"><a class="header" href="#definition-field-of-rational-functions">Definition: Field of Rational Functions</a></h3>
<hr />
<p><em>Let \(K\) be a field and \(X\) be indeterminate. The field of rational functions over \(K\), denoted \(K(X)\), is defined as:</em></p>
<p>\begin{equation*}
K(X) = \left\{ \frac{f(X)}{g(X)} \middle|\ f(X), g(X) \in K[X], g(X) \neq 0 \right\}
\end{equation*}</p>
<p><em>where \(K[X]\) is the ring of polynomials in \(X\) with coefficients in \(K\).</em></p>
<hr />
<p>\(K(X)\) can be viewed as the field obtained by adjoining a letter \(X\) to \(K\). This construction generalizes to multiple variables, e.g., \(K(X,Y)\).</p>
<p>The concept of a function field naturally arises in the context of algebraic curves, particularly elliptic curves. Intuitively, the function field encapsulates the algebraic structure of rational functions on the curve.</p>
<p>We first construct the coordinate ring for an elliptic curve \(E: y^2 = x^3 + ax + b\). Consider functions \(X: E \to K\) and \(Y: E \to K\) that extract the \(x\) and \(y\) coordinates, respectively, from an arbitrary point \(P \in E\). These functions generate the polynomial ring \(K[X,Y]\), subject to the relation \(Y^2 = X^3 + aX + b\).</p>
<p>To put it simply, the function field is a field that consists of all functions that determine the value based on the point on the curve.</p>
<h3 id="definition-coordinate-ring-of-an-elliptic-curve"><a class="header" href="#definition-coordinate-ring-of-an-elliptic-curve">Definition: Coordinate Ring of an Elliptic Curve</a></h3>
<hr />
<p><em>The <strong>coordinate ring</strong> of an elliptic curve \(E: y^2 = x^3 + ax + b\) over a field \(K\) is defined as:</em>
\begin{equation}
K[E] = K[X, Y]/(Y^2 - X^3 - aX - b)
\end{equation}</p>
<hr />
<p>In other words, we can view \(K[E]\) as a ring representing all polynomial functions on \(E\). Recall that \(K[X, Y]\) is the polynomial ring in two variables \(X\) and \(Y\) over the field K, meaning that it contains all polynomials in \(X\) and \(Y\) with coefficients from \(K\). Then, the notation \(K[X, Y]/(Y^2 - X^3 - aX - b)\) denotes the quotient ring obtained by taking \(K[X, Y]\) and "modding out" by the ideal \((Y^2 - X^3 - aX - b)\).</p>
<p><strong>Example</strong> For example, for an elliptic curve \(E: y^2 = x^3 - x\) over \(\mathbb{Q}\), some elements of the coordinate ring \(\mathbb{Q}[E]\) include:</p>
<ul>
<li>Constants: \(3, -2, \frac{1}{7}, \ldots\)</li>
<li>Linear functions: \(X, Y, 2X+3Y, \ldots\)</li>
<li>Quadratic functions: \(X^2, XY, Y^2 (= X^3 - X), \ldots\)</li>
<li>Higher-degree functions: \(X^3, X^2Y, XY^2 (= X^4 - X^2), \ldots\)</li>
</ul>
<h3 id="definition-function-field-of-an-elliptic-curve"><a class="header" href="#definition-function-field-of-an-elliptic-curve">Definition: Function Field of an Elliptic Curve</a></h3>
<p>Then, the function field is defined as follows:</p>
<hr />
<p><em>Let \(E: y^2 = x^3 + ax + b\) be an elliptic curve over a field \(K\). The <strong>function field</strong> of \(E\), denoted \(K(E)\), is defined as:</em>
\begin{equation}
K(E) = \left\{\frac{f}{g} ,\middle|, f, g \in K[E], g \neq 0 \right\}
\end{equation}
<em>where \(K[E] = K[X, Y]/(Y^2 - X^3 - aX - b)\) is the coordinate ring of \(E\).</em></p>
<hr />
<p>\(K(E)\) can be viewed as the field of all rational functions on \(E\).</p>
<h3 id="definition-zeropole-of-a-function"><a class="header" href="#definition-zeropole-of-a-function">Definition: Zero/Pole of a Function</a></h3>
<hr />
<p><em>Let \(h \in K(E)\) be a non-zero function. A point \(P \in E\) is called a <strong>zero</strong> of \(h\) if \(h(P) = 0\).</em></p>
<hr />
<hr />
<p><em>Let \(h \in K(E)\) be a non-zero function. A point \(P \in E\) is called a <strong>pole</strong> of \(h\) if \(h\) is not defined at \(P\) or, equivalently if \(1/h\) has a zero at \(P\).</em></p>
<hr />
<p><strong>Example</strong> Consider the elliptic curve \(E: Y^2 = X^3 - X\) over a field \(K\) of characteristic \(\neq 2, 3\). Let \(P_{-1} = (-1, 0)\), \(P_0 = (0, 0)\), and \(P_1 = (1, 0)\) be the points where \(Y = 0\).</p>
<ul>
<li>The function \(Y \in K(E)\) has three simple zeros: \(P_{-1}\), \(P_0\), and \(P_1\).</li>
<li>The function \(X \in K(E)\) has a double zero at \(P_0\) (since \(P_0 = -P_0\)).</li>
<li>The function \(X - 1 \in K(E)\) has a simple zero at \(P_1\).</li>
<li>The function \(X^2 - 1 \in K(E)\) has two simple zeros at \(P_{-1}\) and \(P_1\).</li>
<li>The function \(\frac{Y}{X} \in K(E)\) has a simple zero at \(P_{-1}\) and a simple pole at \(P_0\).</li>
</ul>
<p>An important property of functions in \(K(E)\) is that they have the same number of zeros and poles when counted with multiplicity. This is a consequence of a more general result known as the Degree-Genus Formula.</p>
<h3 id="theorem-degree-genus-formula-for-elliptic-curves"><a class="header" href="#theorem-degree-genus-formula-for-elliptic-curves">Theorem: Degree-Genus Formula for Elliptic Curves</a></h3>
<hr />
<p><em>Let \(f \in K(E)\) be a non-zero rational function on an elliptic curve \(E\). Then:</em></p>
<p>\begin{equation}
\sum_{P \in E} ord_{P(f)} = 0
\end{equation}</p>
<p><em>, where \(ord_{P(f)}\) denotes the order of \(f\) at \(P\), which is positive for zeros and negative for poles.</em></p>
<hr />
<p>This theorem implies that the total number of zeros (counting multiplicity) equals the total number of poles for any non-zero function in \(K(E)\).</p>
<p>We now introduce a powerful tool for analyzing functions on elliptic curves: the concept of divisors.</p>
<h3 id="definition-divisor-of-a-function-on-an-elliptic-curve"><a class="header" href="#definition-divisor-of-a-function-on-an-elliptic-curve">Definition: Divisor of a Function on an Elliptic Curve</a></h3>
<hr />
<p><em>Let \(E: Y^2 = X^3 + AX + B\) be an elliptic curve over a field \(K\), and let \(f \in K(E)\) be a non-zero rational function on \(E\). The <strong>divisor</strong> of \(f\), denoted \(div(f)\), is defined as:</em>
\begin{equation}
div(f) = \sum_{P \in E} ord_P(f) [P]
\end{equation}
<em>, where \(ord_P(f)\) is the order of \(f\) at \(P\) (positive for zeros, negative for poles), and the sum is taken over all points \(P \in E\), including the point at infinity. This sum has only finitely many non-zero terms.</em></p>
<hr />
<p>Note that this \(\sum_{P \in E}\) is a symbolic summation, and we do not calculate the concrete numerical value of a divisor.</p>
<p><strong>Example</strong> Consider the elliptic curve \(E: Y^2 = X^3 - X\) over \(\mathbb{Q}\).</p>
<ul>
<li>For \(f = X\), we have \(div(X) = 2[(0,0)] - 2[\mathcal{O}]\).</li>
<li>For \(g = Y\), we have \(div(Y) = [(1,0)] + [(0,0)] + [(-1,0)] - 3[\mathcal{O}]\).</li>
<li>For \(h = \frac{X-1}{Y}\), we have \(div(h) = [(1,0)] - [(-1,0)]\).</li>
</ul>
<h3 id="definition-divisor-on-an-elliptic-curve"><a class="header" href="#definition-divisor-on-an-elliptic-curve">Definition: Divisor on an Elliptic Curve</a></h3>
<p>The concept of divisors can be extended to the elliptic curve itself:</p>
<hr />
<p><em>A <strong>divisor</strong> \(D\) on an elliptic curve \(E\) is a formal sum</em>
\begin{equation}
D = \sum_{P \in E} n_P [P]
\end{equation}
<em>where \(n_P \in \mathbb{Z}\) and \(n_P = 0\) for all but finitely many \(P\).</em></p>
<hr />
<p><strong>Example</strong> On the curve \(E: Y^2 = X^3 - X\):</p>
<ul>
<li>\(D_1 = 3[(0,0)] - 2[(1,1)] - [(2,\sqrt{6})]\) is a divisor.</li>
<li>\(D_2 = [(1,0)] + [(-1,0)] - 2[\mathcal{O}]\) is a divisor.</li>
<li>\(D_3 = \sum_{P \in E[2]} [P] - 4[\mathcal{O}]\) is a divisor (where \(E[2]\) are the 2-torsion points).</li>
</ul>
<p>To quantify the properties of divisors, we introduce two important metrics:</p>
<h3 id="definition-degreesum-of-a-divisor"><a class="header" href="#definition-degreesum-of-a-divisor">Definition: Degree/Sum of a Divisor</a></h3>
<hr />
<p><em>The <strong>degree</strong> of a divisor \(D = \sum_{P \in E} n_P [P]\) is defined as:</em>
\begin{equation}
deg(D) = \sum_{P \in E} n_P
\end{equation}</p>
<hr />
<hr />
<p><em>The <strong>sum</strong> of a divisor \(D = \sum_{P \in E} n_P [P]\) is defined as:</em>
\begin{equation}
Sum(D) = \sum_{P \in E} n_P P
\end{equation}
<em>where \(n_P P\) denotes the point addition of \(P\) to itself \(n_P\) times in the group law of \(E\).</em></p>
<hr />
<p><strong>Example</strong> For the divisors in the previous example:</p>
<ul>
<li>\(deg(D_1) = 3 - 2 - 1 = 0\)</li>
<li>\(deg(D_2) = 1 + 1 - 2 = 0\)</li>
<li>\(deg(D_3) = 4 - 4 = 0\)</li>
<li>\(Sum(D_2) = (1,0) + (-1,0) - 2\mathcal{O} = \mathcal{O}\) (since \((1,0)\) and \((-1,0)\) are 2-torsion points)</li>
</ul>
<h3 id="theorem-1"><a class="header" href="#theorem-1">Theorem</a></h3>
<p>The following theorem characterizes divisors of functions and provides a criterion for when a divisor is the divisor of a function:</p>
<hr />
<p><em>Let \(E\) be an elliptic curve over a field \(K\).</em></p>
<ul>
<li><em>If \(f, f' \in K(E)\) are non-zero rational functions on \(E\) with \(div(f) = div(f')\), then there exists a non-zero constant \(c \in K^*\) such that \(f = cf'\).</em></li>
<li><em>A divisor \(D\) on \(E\) is the divisor of a rational function on \(E\) if and only if \(deg(D) = 0\) and \(Sum(D) = \mathcal{O}\).</em></li>
</ul>
<hr />
<p><strong>Example</strong> On \(E: Y^2 = X^3 - X\):</p>
<ul>
<li>The function \(f = \frac{Y}{X}\) has \(div(f) = [(1,0)] + [(-1,0)] - 2[(0,0)]\). Note that \(deg(div(f)) = 0\) and \(Sum(div(f)) = (1,0) + (-1,0) - 2(0,0) = \mathcal{O}\).</li>
<li>The divisor \(D = 2[(1,1)] - [(2,\sqrt{6})] - [(0,0)]\) has \(deg(D) = 0\), but \(Sum(D) \neq \mathcal{O}\). Therefore, \(D\) is not the divisor of any rational function on \(E\).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pairing"><a class="header" href="#pairing">Pairing</a></h1>
<h3 id="definition-pairing"><a class="header" href="#definition-pairing">Definition: Pairing</a></h3>
<hr />
<p><em>Let \(G_1\) and \(G_2\) be cyclic groups under addition, both of prime order \(p\), with generators \(P\) and \(Q\) respectively:</em></p>
<p>\begin{align}
G_1 &amp;= \{0, P, 2P, ..., (p-1)P\} \
G_2 &amp;= \{0, Q, 2Q, ..., (p-1)Q\}
\end{align}</p>
<p><em>Let \(G_T\) be a cyclic group under multiplication, also of order \(p\). A pairing is a map \(e: G_1 \times G_2 \rightarrow G_T\) that satisfies the following bilinear property:</em></p>
<p>\begin{equation}
e(aP, bQ) = e(P, Q)^{ab}
\end{equation} <em>for all \(a, b \in \mathbb{Z}_p\).</em></p>
<hr />
<p>Imagine \(G_1\) represents length, \(G_2\) represents width, and \(G_T\) represents area. The pairing function \(e\) is like calculating the area: If you double the length and triple the width, the area becomes six times larger: \(e(2P, 3Q) = e(P, Q)^{6}\)</p>
<h3 id="definition-the-weil-pairing"><a class="header" href="#definition-the-weil-pairing">Definition: The Weil Pairing</a></h3>
<p>The Weil pairing is one of the bilinear pairings for elliptic curves. We begin with its formal definition.</p>
<hr />
<p><em>Let \(E\) be an elliptic curve and \(n\) be a positive integer. For points \(P, Q \in E[n]\), where \(E[n]\) denotes the \(n\)-torsion subgroup of \(E\), we define the Weil pairing \(e_n(P, Q)\) as follows:</em></p>
<p>Let \(f_P\) and \(f_Q\) be rational functions on \(E\) satisfying:
\begin{align}
div(f_P) &amp;= n[P] - n[\mathcal{O}] \
div(f_Q) &amp;= n[Q] - n[\mathcal{O}]
\end{align}</p>
<p><em>Then, for an arbitrary point \(S \in E\) such that \(S \notin \{\mathcal{O}, P, -Q, P-Q\}\), the Weil pairing is given by:</em></p>
<p>\begin{equation}
e_n(P, Q) = \frac{f_P(Q + S)}{f_P(S)} /\ \frac{f_Q(P - S)}{f_Q(-S)}
\end{equation}</p>
<hr />
<p>We introduce a crucial theorem about a specific rational function on elliptic curves to construct the functions required for the Weil pairing.</p>
<h3 id="theorem-2"><a class="header" href="#theorem-2">Theorem</a></h3>
<hr />
<p><em>Let \(E\) be an elliptic curve over a field \(K\), and let \(P = (x_P, y_P)\) and \(Q = (x_Q, y_Q)\) be non-zero points on \(E\). Define \(\lambda\) as:</em></p>
<p>\begin{equation}
\lambda = \begin{cases}
\hbox{slope of the line through \(P\) and \(Q\)} &amp;\quad \hbox{if \(P \neq Q\)} \\
\hbox{slope of the tangent line to \(E\) at \(P\)} &amp;\quad \hbox{if \(P = Q\)} \\
\infty &amp;\quad \hbox{if the line is vertical}
\end{cases}
\end{equation}</p>
<p><em>Then, the function \(g_{P,Q}: E \to K\) defined by:</em>
\begin{equation}
g_{P,Q} = \begin{cases}
\frac{y - y_P - \lambda(x - x_P)}{x + x_P + x_Q - \lambda^2} &amp;\quad \hbox{if } \lambda \neq \infty \\
x - x_P &amp;\quad \hbox{if } \lambda = \infty
\end{cases}
\end{equation} <em>has the following divisor:</em></p>
<p>\begin{equation}
div(g_{P,Q}) = [P] + [Q] - [P + Q] - [\mathcal{O}]
\end{equation}</p>
<hr />
<p><strong>Proof:</strong> We consider two cases based on the value of \(\lambda\).</p>
<p>Case 1: \(\lambda \neq \infty\)</p>
<p>Let \(y = \lambda x + v\) be the line through \(P\) and \(Q\) (or the tangent line at \(P\) if \(P = Q\)). This line intersects \(E\) at three points: \(P\), \(Q\), and \(-P-Q\). Thus,
\begin{equation}
div(y - \lambda x - v) = [P] + [Q] + [-P - Q] - 3[\mathcal{O}]
\end{equation}
Vertical lines intersect \(E\) at points and their negatives, so:
\begin{equation}
div(x - x_{P+Q}) = [P + Q] + [-P - Q] - 2[\mathcal{O}]
\end{equation}
It follows that \(g_{P,Q} = \frac{y - \lambda x - v}{x - x_{P+Q}}\) has the desired divisor.</p>
<p>Case 2: \(\lambda = \infty\)</p>
<p>In this case, \(P + Q = \mathcal{O}\), so we want \(g_{P,Q}\) to have divisor \([P] + [-P] - 2[\mathcal{O}]\). The function \(x - x_P\) has this divisor.
\end{proof}</p>
<h3 id="theorem-millers-algorithm"><a class="header" href="#theorem-millers-algorithm">Theorem: Miller's Algorithm</a></h3>
<hr />
<p><em>Let \(m \geq 1\) and write its binary expansion as:</em>
\begin{equation}
m = m_0 + m_1 \cdot 2 + m_2 \cdot 2^2 + \cdots + m_{n-1} \cdot 2^{n-1}
\end{equation}
<em>where \(m_i \in \{0, 1\}\) and \(m_{n-1} \neq 0\).</em></p>
<p><em>The following algorithm, using the function \(g_{P,Q}\) defined in the previous theorem, returns a function \(f_P\) whose divisor satisfies:</em></p>
<p>\begin{equation}
div(f_P) = m[P] - m[P] - (m - 1)[\mathcal{O}]
\end{equation}</p>
<p>===========================</p>
<p><strong>Miller's Algorithm</strong></p>
<ol>
<li>Set \(T = P\) and \(f = 1\)</li>
<li><strong>For</strong> \(i \gets n-2 \cdots 0\) <strong>do</strong></li>
<li>¬†¬†¬†¬†Set \(f = f^2 \cdot g_{T, T}\)</li>
<li>¬†¬†¬†¬†Set \(T = 2T\)</li>
<li>¬†¬†¬†¬†<strong>If</strong> \(m_i = 1\) <strong>then</strong></li>
<li>¬†¬†¬†¬†¬†¬†¬†¬†Set \(f = f \cdot g_{T, P}\)</li>
<li>¬†¬†¬†¬†¬†¬†¬†¬†Set \(T = T + P\)</li>
<li>¬†¬†¬†¬†<strong>End if</strong></li>
<li><strong>End for</strong></li>
<li><strong>Return</strong> \(f\)</li>
</ol>
<p>===========================</p>
<hr />
<p><strong>Proof:</strong> TBD</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_lambda&lt;F: Field, E: EllipticCurve&gt;(
    p: &amp;EllipticCurvePoint&lt;F, E&gt;,
    q: &amp;EllipticCurvePoint&lt;F, E&gt;,
    r: &amp;EllipticCurvePoint&lt;F, E&gt;,
) -&gt; F {
    let p_x = p.x.as_ref().unwrap();
    let p_y = p.y.as_ref().unwrap();
    let q_x = q.x.as_ref().unwrap();
    // let q_y = q.y.clone().unwrap();
    let r_x = r.x.as_ref().unwrap();
    let r_y = r.y.as_ref().unwrap();

    if (p == q &amp;&amp; *p_y == F::zero()) || (p != q &amp;&amp; *p_x == *q_x) {
        return r_x.sub_ref(&amp;p_x);
    }
    let slope = p.line_slope(&amp;q);
    let numerator = (r_y.sub_ref(&amp;p_y)).sub_ref(&amp;slope.mul_ref(&amp;(r_x.sub_ref(&amp;p_x))));
    let denominator = r_x
        .add_ref(&amp;p_x)
        .add_ref(&amp;q_x)
        .sub_ref(&amp;slope.mul_ref(&amp;slope));
    return numerator / denominator;
}

pub fn miller&lt;F: Field, E: EllipticCurve&gt;(
    p: &amp;EllipticCurvePoint&lt;F, E&gt;,
    q: &amp;EllipticCurvePoint&lt;F, E&gt;,
    m: &amp;BigInt,
) -&gt; (F, EllipticCurvePoint&lt;F, E&gt;) {
    if p == q {
        return (F::one(), p.clone());
    }

    let mut f = F::one();
    let mut t = p.clone();

    for i in (0..(m.bits() - 1)).rev() {
        f = (f.mul_ref(&amp;f)) * (get_lambda(&amp;t, &amp;t, &amp;q));
        t = t.add_ref(&amp;t);
        if m.bit(i) {
            f = f * (get_lambda(&amp;t, &amp;p, &amp;q));
            t = t.add_ref(&amp;p);
        }
    }

    (f, t)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h1>
<h3 id="assumption-discrete-logarithm-problem"><a class="header" href="#assumption-discrete-logarithm-problem">Assumption: Discrete Logarithm Problem</a></h3>
<hr />
<p><em>Let \(G\) be a finite cyclic group of order \(n\), with \(\gamma\) as its generator and \(1\) as the identity element. For any element \(\alpha \in G\), there is currently no known efficient (polynomial-time) algorithm to compute the smallest non-negative integer \(x\) such that \(\alpha = \gamma^{x}\).</em></p>
<hr />
<p>The Discrete Logarithm Problem can be thought of as a one-way function. It's easy to compute \(g^{x}\) given \(g\) and \(x\), but it's computationally difficult to find \(x\) given \(g\) and \(g^{x}\).</p>
<h3 id="assumption-elliptic-curve-discrete-logarithm-problem"><a class="header" href="#assumption-elliptic-curve-discrete-logarithm-problem">Assumption: Elliptic Curve Discrete Logarithm Problem</a></h3>
<hr />
<p><em>Let \(E\) be an elliptic curve defined over a finite field \(\mathbb{F}_q\), where \(q\) is a prime power. Let \(P\) be a point on \(E\) of point order \(n\), and let \(\langle P \rangle\) be the cyclic subgroup of \(E\) generated by \(P\). For any element \(Q \in \langle P \rangle\), there is currently no known efficient (polynomial-time) algorithm to compute the unique integer \(k\), \(0 \leq k &lt; n\), such that \(Q = kP\).</em></p>
<hr />
<p>This assumption is an elliptic curve version of the Discrete Logarithm Problem.</p>
<h3 id="assumption-knowledge-of-exponent-assumption"><a class="header" href="#assumption-knowledge-of-exponent-assumption">Assumption: Knowledge of Exponent Assumption</a></h3>
<hr />
<p><em>Let \(G\) be a cyclic group of prime order \(q\) with generator \(g \in G\). For any probabilistic polynomial-time algorithm \(\mathcal{A}\) that outputs:</em></p>
<p>\begin{equation}
\mathcal{A}(g, g^x) = (h, h') \quad s.t. \quad h' = h^x
\end{equation}
<em>, there exists an efficient extractor \(\mathcal{E}\) such that:</em>
\begin{equation}
\mathcal{E}(\mathcal{A}, g, g^x) = y \quad s.t. \quad h = g^y
\end{equation}</p>
<hr />
<p>This assumption states that if \(\mathcal{A}\) can compute the pair \((g^y, g^{xy})\) from \((g, g^x)\), then \(\mathcal{A}\) must "know" the value \(y\), in the sense that \(\mathcal{E}\) can extract \(y\) from \(\mathcal{A}\)'s internal state.
The Knowledge of Exponent Assumption is useful for constructing verifiable exponential calculation algorithms. Consider a scenario where Alice has a secret value \(a\), and Bob has a secret value \(b\). Bob wants to obtain \(g^{ab}\). This can be achieved through the following protocol:</p>
<p><strong>Verifiable Exponential Calculation Algorithm</strong></p>
<ol>
<li>Bob sends \((g, g'=g^{b})\) to Alice</li>
<li>Alice sends \((h=g^{a}, h'=g'^{a})\) to Bob</li>
<li>Bob checks \(h^{b} = h'\).</li>
</ol>
<p>Thanks to the Discrete Logarithm Assumption and the Knowledge of Exponent Assumption, the following properties hold:</p>
<ul>
<li>Bob cannot derive \(a\) from \((h, h')\).</li>
<li>Alice cannot derive \(b\) from \((g, g')\).</li>
<li>Alice cannot generate \((t, t')\) such that \(t \neq h\) and \(t^{b} = t'\).</li>
<li>If \(h^{b} = h'\), Bob can conclude that \(h\) is the power of \(g\).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polynomial-commitment"><a class="header" href="#polynomial-commitment">Polynomial Commitment</a></h1>
<p>Good point ‚Äî let‚Äôs start with a short, formal definition of <em>polynomial commitments</em> and then embed that as the intro to the KZG write-up.</p>
<h1 id="polynomial-commitment-definition"><a class="header" href="#polynomial-commitment-definition">Polynomial commitment (definition)</a></h1>
<p>A <strong>polynomial commitment scheme</strong> lets a prover commit to a polynomial \(f(X)\) so that later the prover can (1) reveal the value \(f(u)\) at any point \(u\) together with a <em>short</em> proof (witness), and (2) the verifier can efficiently check that the revealed value is correct relative to the original commitment. A scheme typically provides four algorithms:</p>
<ul>
<li><strong>Setup</strong>\((1^\lambda, D)\): (possibly trusted) produces public parameters \(\text{PK}\) and possibly a secret key \(\text{SK}\). \(D\) is a public upper bound on polynomial degree.</li>
<li><strong>Commit</strong>\((\text{PK}, f)\to C\): the prover computes a short commitment \(C\) to polynomial \(f\).</li>
<li><strong>Open</strong>\((\text{PK}, f, u)\to (y, W)\): the prover computes \(y=f(u)\) and a witness \(W\) that proves \(y\) is the value of \(f\) at \(u\).</li>
<li><strong>Verify</strong>\((\text{PK}, C, u, y, W)\to\{\text{accept},\text{reject}\}\): the verifier checks the witness and either accepts or rejects.</li>
</ul>
<p><strong>Correctness.</strong> For honestly generated keys and honest prover, if \(C\leftarrow\text{Commit}(f)\) and \((y,W)\leftarrow\text{Open}(f,u)\), then \(\text{Verify}(\text{PK},C,u,y,W)\) must accept.</p>
<p><strong>Security properties (informal).</strong></p>
<ul>
<li><strong>Binding:</strong> After publishing \(C\), the committer cannot (except with negligible probability under standard assumptions) produce two different openings \((u,y,W)\) and \((u,y',W')\) with \(y\ne y'\) that both verify. This prevents equivocation.</li>
<li><strong>Hiding (optional):</strong> Some schemes hide the polynomial (or its evaluations) from the verifier; others are not hiding by default. Hiding can be statistical or computational depending on the scheme and added randomness.</li>
<li><strong>Succinctness / efficiency:</strong> Commitments and opening proofs should be short (ideally constant size independent of polynomial degree), and verification should be much cheaper than re-evaluating \(f\) from its coefficients.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kzg"><a class="header" href="#kzg">KZG</a></h1>
<p>Let \(G_1\), \(G_2\), and \(G_T\) be groups such that there exists a bilinear mapping \(e: G_1 \times G_2 \to G_T\). Let \(g_1 \in G_1\) and \(g_2 \in G_2\) be fixed generators.</p>
<p>We want a short commitment to a polynomial over \(\mathbb{F}\) denoted as \(f(X) = \sum_{i=0}^{d} c_{i} x^{i} \in \mathbb{F}_{q}[X]\) with a public maximum degree bound \(D\) such that \(d \leq D\). The prover produces a commitment \(C\) for this polynomial so that it cannot change the polynomial after that. Then, the prover submits a short witness that proves the value \(f(u)\) at a point \(u \in F_q\)</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>A trusted party samples a secret \(\alpha \xleftarrow{\text{random}} \mathbb{F}_{q}\), and publishes a public key \(\mathrm{PK}\):</p>
<p>\begin{align*}
&amp;\mathrm{PK} := (\{g_1^{(\alpha^{i})}\}^{D}_{i=0}, g_2, g^{\alpha}_2)
\end{align*}</p>
<p>The secret key \(\alpha\) should be securely destroyed after the generation of this \(\mathrm{PK}\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PublicKeyKZG {
    pub powers_1: Vec&lt;G1Point&gt;,
    pub powers_2: Vec&lt;G2Point&gt;,
}

pub fn setup_kzg(g1: &amp;G1Point, g2: &amp;G2Point, n: usize) -&gt; PublicKeyKZG {
    let alpha = FqOrder::random_element(&amp;[]);

    let mut powers_1 = Vec::with_capacity(n);
    let mut alpha_power = FqOrder::one();
    for _ in 0..1 + n {
        powers_1.push(g1.mul_ref(alpha_power.clone().get_value()));
        alpha_power = alpha_power * alpha.clone();
    }

    let powers_2 = vec![g2.clone(), g2.mul_ref(alpha.get_value())];

    PublicKeyKZG { powers_1, powers_2 }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="commitment"><a class="header" href="#commitment">Commitment</a></h2>
<p>Given \(f\) with coefficients \(c_i\), compute the commitment:</p>
<p>\[
C = \Pi_{i=0}^{d} (g_1^{(\alpha^{i})})^{c_i} = g_1^{\sum_{i=0}^{d} c_i \alpha^{i}} = g_1^{f(\alpha)}
\]</p>
<p>Because the public key contains \(g_1^{(\alpha^{i})}\), the prover can compute this multi-exponentiation without knowing \(\alpha\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type CommitmentKZG = G1Point;

pub fn commit_kzg(p: &amp;Polynomial&lt;FqOrder&gt;, pk: &amp;PublicKeyKZG) -&gt; CommitmentKZG {
    p.eval_with_powers_on_curve(&amp;pk.powers_1)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="open"><a class="header" href="#open">Open</a></h2>
<p>To open \(f\) at \(u\), define the quotient polynomial:</p>
<p>\begin{align*}
f_u(X) = \frac{f(X) - f(u)}{X - u}
\end{align*}</p>
<p>This \(f_u\) is a polynomial of degree \(\leq d - 1\) (because \(X - u\) divides \(f(X) - f(u)\)). Let \(f_u(x) = \sum_{i=0}^{d-1} c' x^{i}\). The prover then forms the witness:</p>
<p>\begin{align*}
W = \Pi_{i=0}^{d-1} (g_1^{(\alpha^{i})})^{c_{i}'} = g_1^{\sum_{i=0}^{d-1} c'_i \alpha^{i}} = g_1^{f_u(\alpha)}
\end{align*}</p>
<p>Here, the prover can computes \(W\) only using the public key, and \(\alpha\) is not required.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProofKZG {
    pub y: FqOrder,
    pub w: G1Point,
}

pub fn open_kzg(p: &amp;Polynomial&lt;FqOrder&gt;, z: &amp;FqOrder, pk: &amp;PublicKeyKZG) -&gt; ProofKZG {
    let y = p.eval(z);
    let y_poly = Polynomial {
        coef: (&amp;[y.clone()]).to_vec(),
    };

    let q = (p - &amp;y_poly) / Polynomial::&lt;FqOrder&gt;::from_monomials(&amp;[z.clone()]);
    ProofKZG {
        y: y,
        w: q.eval_with_powers_on_curve(&amp;pk.powers_1),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>The verifier is given the public key, the commitment \(C\), the claimed evauation \(y = f(u)\), and the witness \(W\). They check the pairing equation:</p>
<p>\begin{align*}
\frac{e(c, g_2)}{e(g_1, g_2)^{y}} \overset{?}{=} e(W, g_2^{\alpha} \cdot g_2^{-u})
\end{align*}</p>
<p>or equivalently:</p>
<p>\begin{align*}
e(c, g_2) \overset{?}{=} e(g_1, g_2)^{y} \cdot e(W, g_2^{\alpha} \cdot g_2^{-u})
\end{align*}</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn verify_kzg(z: &amp;FqOrder, c: &amp;CommitmentKZG, proof: &amp;ProofKZG, pk: &amp;PublicKeyKZG) -&gt; bool {
    let g1 = &amp;pk.powers_1[0];
    let g2 = &amp;pk.powers_2[0];
    let g2_s = &amp;pk.powers_2[1];
    let g2_z = g2.mul_ref(z.clone().get_value());
    let g2_s_minus_z = g2_s.clone() - g2_z;

    let e1 = optimal_ate_pairing(&amp;proof.w, &amp;g2_s_minus_z);
    let e2 = optimal_ate_pairing(&amp;g1, &amp;g2);
    let e3 = optimal_ate_pairing(&amp;c, &amp;g2);

    e3 == e1 * (e2.pow(proof.y.get_value()))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="why-this-works"><a class="header" href="#why-this-works">Why this works:</a></h3>
<h4 id="correctness"><a class="header" href="#correctness">Correctness</a></h4>
<p>Expand both sides in the target group \(G_T\):</p>
<ul>
<li>\(e(c, g_2) = e(g_1^{f(\alpha)}, g_2) = g_T^{f(\alpha)}\)</li>
<li>\(e(g_1, g_2)^{y} = g_T^{y} = g_T^{f(u)}\)</li>
<li>\(e(W, g_2^{\alpha} \cdot g_2^{-u}) = e(g_1^{f_u(\alpha)}, g_2^{\alpha-u}) = g_T^{f_u(\alpha)\cdot (\alpha - u)}\)</li>
</ul>
<p>So the equality is exactly the exponent identity:</p>
<p>\begin{align*}
f(\alpha) - f(u) = (\alpha - u) f_u(\alpha)
\end{align*}</p>
<p>which holds by the definition of \(f_u(\alpha)\). Thus a correct witness passes verification.</p>
<h4 id="binding"><a class="header" href="#binding">Binding</a></h4>
<p>TBD</p>
<h4 id="hiding"><a class="header" href="#hiding">Hiding</a></h4>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gemini"><a class="header" href="#gemini">Gemini</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-zk-snark"><a class="header" href="#basics-of-zk-snark">Basics of zk-SNARK</a></h1>
<p>zk-SNARK stands for "<strong>Z</strong>ero-<strong>K</strong>nowledge <strong>S</strong>uccinct <strong>N</strong>on-Interactive <strong>AR</strong>gument of <strong>K</strong>nowledge". It's a cryptographic proof protocol that allows one party (the prover) to convince an another party (the verifier) that they possess certain information, without even revealing the information itself.</p>
<p>In this tutorial, we will gradually implement two of the most popular zk-SNARK protocols: <a href="https://dl.acm.org/doi/abs/10.1145/2856449">Pinocchio</a> and <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>. The structure of this guide closely follows the excellent tutorial by, <a href="https://arxiv.org/abs/1906.07221">Petkus, Maksym. "Why and how zk-snark works."</a>, as well as the fantastic eBook <a href="https://www.rareskills.io/zk-book">"The RareSkills Book of Zero Knowledge"</a>.</p>
<h2 id="key-components-of-zk-snarks"><a class="header" href="#key-components-of-zk-snarks">Key Components of zk-SNARKs</a></h2>
<ul>
<li><strong>Zero-Knowledge:</strong> The prover demonstrates the validity of a statement without revealing any additional information.</li>
<li><strong>Succinct:</strong> Proofs are small in size, and verification is computationally efficient.</li>
<li><strong>Non-Interactive:</strong> Requires no back-and-forth between the prover and verifier.</li>
</ul>
<h2 id="how-zk-snarks-work"><a class="header" href="#how-zk-snarks-work">How zk-SNARKs Work</a></h2>
<p>zk-SNARKs rely on polynomial equations as cryptographic puzzles. The prover generates a proof based on these equations, which are designed to be solvable only by someone with the required knowledge. The verifier can easily check the validity of the proof without accessing the underlying data. Randomness plays a key role in ensuring each proof is unique and secure.</p>
<h2 id="applications-of-zk-snarks"><a class="header" href="#applications-of-zk-snarks">Applications of zk-SNARKs</a></h2>
<ul>
<li><strong>Private Transactions:</strong> Users can prove they have sufficient funds without revealing their account balance or transaction history7.</li>
<li><strong>Anonymous Voting:</strong> Voters can prove they've voted without disclosing their choice7.</li>
<li><strong>Blockchain and Smart Contracts:</strong> Enhancing privacy and scalability in blockchain networks.</li>
<li><strong>Identity Verification:</strong> Proving identity without revealing personal information.</li>
<li><strong>Secure Financial Transactions:</strong> Enabling confidential financial operations.</li>
<li><strong>Data Privacy in Healthcare:</strong> Protecting sensitive medical information while allowing necessary verifications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetization"><a class="header" href="#arithmetization">Arithmetization</a></h1>
<p>The ultimate goal of Zero-Knowledge Proofs (ZKP) is to allow the prover to demonstrate their knowledge to the verifier without revealing any additional information. This knowledge typically involves solving complex problems, such as finding a secret input value that corresponds to a given public hash. ZKP protocols usually convert these statements into polynomial constraints. This process is often called <strong>arithmetization</strong>.</p>
<p>To make the protocol flexible, we need to encode this knowledge in a specific format, and one common approach is using Boolean circuits. It's well-known that problems in P (those solvable in polynomial time) and NP (those where the solution can be verified in polynomial time) can be represented as Boolean circuits. This means adopting Boolean circuits allows us to handle both P and NP problems.</p>
<p>However, Boolean circuits are often large and inefficient. Even a simple operation, like adding two 256-bit integers, can require hundreds of Boolean operators. In contrast, arithmetic circuits‚Äîessentially systems of equations involving addition, multiplication, and equality‚Äîoffer a much more compact representation. Additionally, any Boolean circuit can be converted into an arithmetic circuit. For instance, the Boolean expression \(z = x \land y\) can be represented as \(x(x-1) = 0\), \(y(y-1) = 0\), and \(z = xy\) in an arithmetic circuit. Furthermore, as we'll see in this section, converting arithmetic circuits into polynomial constraints allows for much faster evaluation.</p>
<h2 id="rank-1-constraint-system-r1cs"><a class="header" href="#rank-1-constraint-system-r1cs">Rank-1 Constraint System (R1CS)</a></h2>
<p>There are many formats to represent arithmetic circuits, and one of the most popular ones is R1CS (Rank-1 Constraint System), which represents arithmetic circuits as a set of equality constraints, each involving only one multiplication. In an arithmetic circuit, we call the concrete values assigned to the variables within the constraints witness. We first provide the formal definition of R1CS as follows:</p>
<h3 id="definition-r1cs"><a class="header" href="#definition-r1cs">Definition: R1CS</a></h3>
<p>An R1CS structure \(\mathcal{S}\) consists of:</p>
<ul>
<li>Size bounds \(m, d, \ell \in \mathbb{N}\) where \(d &gt; \ell\)</li>
<li>Three matrices \(O, L, R \in \mathbb{F}^{m \times d}\) with at most \(\Omega(\max(m, d))\) non-zero entries in total</li>
</ul>
<p>An R1CS instance includes a public input \(p \in \mathbb{F}^\ell\), while an R1CS witness is a vector \(w \in \mathbb{F}^{d - \ell - 1}\).
A structure-instance tuple \((S, p)\) is satisfied by a witness \(w\) if:
\begin{equation}
(L \cdot v) \circ (R \cdot v) - O \cdot v = \mathbf{0}
\end{equation}
where \(v = (1, w, p) \in \mathbb{F}^d\), \(\cdot\) denotes matrix-vector multiplication, and \(\circ\) is the Hadamard product.</p>
<p>The intuitive interpretation of each matrix is as follows:</p>
<ul>
<li>\(L\): Encodes the left input of each gate</li>
<li>\(R\): Encodes the right input of each gate</li>
<li>\(O\): Encodes the output of each gate</li>
<li>The leading 1 in the assignment vector allows for constant terms</li>
</ul>
<p><strong>Single Multiplication</strong></p>
<p>Let's consider a simple example where we want to prove \(z = x \cdot y\), with \(z = 3690\), \(x = 82\), and \(y = 45\).</p>
<ul>
<li><strong>Assignment vector</strong>: \((1, z, x, y) = (1, 3690, 82, 45)\)</li>
<li><strong>Number of witnesses</strong>: \(m = 4\)</li>
<li><strong>Number of constraints</strong>: \(d = 1\)</li>
</ul>
<p>The R1CS constraint for \(z = x \cdot y\) is satisfied when:</p>
<p>\begin{align*}
&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot v) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot v) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot v \\
=&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix} \\
=&amp; 82 \cdot 45 - 3690 \\
=&amp; 3690 - 3690 \\
=&amp; 0
\end{align*}</p>
<p>This example demonstrates how R1CS encodes a simple multiplication constraint:</p>
<ul>
<li>\(L = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\) selects \(x\) (left input)</li>
<li>\(R = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\) selects \(y\) (right input)</li>
<li>\(O = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}\) selects \(z\) (output)</li>
</ul>
<p><strong>Multiple Constraints</strong></p>
<p>Let's examine a more complex example: \(r = a \cdot b \cdot c \cdot d\). Since R1CS requires that each constraint contain only one multiplication, we need to break this down into multiple constraints:</p>
<p>\begin{align*}
z_1 &amp;= a \cdot b \\
z_2 &amp;= c \cdot d \\
r &amp;= z_1 \cdot z_2
\end{align*}</p>
<p>Note that alternative representations are possible, such as \(z_1 = ab, z_2 = z_1c, r = z_2d\). In this example, we use 7 variables \((r, a, b, c, d, z_1, z_2)\), so the dimension of the assignment vector will be \(m = 8\) (including the constant 1). We have three constraints, so \(n = 3\).
To construct the matrices \(L\), \(R\), and \(O\), we can interpret the constraints as linear combinations:</p>
<p>\begin{align*}
z_1 &amp;= (0 \cdot 1 + 0 \cdot r + 1 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot b \\
z_2 &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 1 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot d \\
r &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 1 \cdot z_1 + 0 \cdot z_2) \cdot z_2
\end{align*}</p>
<p>Thus, we can construct \(L\), \(R\), and \(O\) as follows:</p>
<p>\begin{equation*}
L = \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\end{equation*}
\begin{equation*}
R = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{equation*}
\begin{equation*}
O = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\end{equation*}</p>
<p>Where the columns in each matrix correspond to \((1, r, a, b, c, d, z_1, z_2)\).</p>
<p><strong>Addition with a Constant</strong></p>
<p>Let's examine the case \(z = x \cdot y + 3\). We can represent this as \(-3 + z = x \cdot y\). For the assignment vector \((1, z, x, y)\), we have:</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
-3 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}
\end{align*}</p>
<p>Note that the constant 3 appears in the \(O\) matrix with a negative sign, effectively moving it to the left side of the equation</p>
<p><strong>Multiplication with a Constant</strong></p>
<p>Now, let's consider \(z = 3x^2 + y\). The requirement of "one multiplication per constraint" doesn't apply to multiplication with a constant, as we can treat it as repeated addition.</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 3 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix}
\end{align*}</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;F: Field&gt;(a: &amp;Vec&lt;F&gt;, b: &amp;Vec&lt;F&gt;) -&gt; F {
    let mut result = F::zero();
    for (a_i, b_i) in a.iter().zip(b.iter()) {
        result = result + a_i.clone() * b_i.clone();
    }
    result
}

#[derive(Debug, Clone)]
pub struct R1CS&lt;F: Field&gt; {
    pub left: Vec&lt;Vec&lt;F&gt;&gt;,
    pub right: Vec&lt;Vec&lt;F&gt;&gt;,
    pub out: Vec&lt;Vec&lt;F&gt;&gt;,
    pub m: usize,
    pub d: usize,
}

impl&lt;F: Field&gt; R1CS&lt;F&gt; {
    pub fn new(left: Vec&lt;Vec&lt;F&gt;&gt;, right: Vec&lt;Vec&lt;F&gt;&gt;, out: Vec&lt;Vec&lt;F&gt;&gt;) -&gt; Self {
        let d = left.len();
        let m = if d == 0 { 0 } else { left[0].len() };
        R1CS {
            left,
            right,
            out,
            m,
            d,
        }
    }

    pub fn is_satisfied(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; bool {
        let zero = F::zero();
        self.left
            .iter()
            .zip(self.right.iter())
            .zip(self.out.iter())
            .all(|((l, r), o)| dot(&amp;l, &amp;a) * dot(&amp;r, &amp;a) - dot(&amp;o, &amp;a) == zero)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="quadratic-arithmetic-program-qap"><a class="header" href="#quadratic-arithmetic-program-qap">Quadratic Arithmetic Program (QAP)</a></h2>
<p>Recall that the prover aims to demonstrate knowledge of a witness \(w\) without revealing it. This is equivalent to knowing a vector \(a\) that satisfies \((L \cdot v) \circ (R \cdot v) = O \cdot v\), where \(\circ\) denotes the Hadamard (element-wise) product. However, evaluating this equivalence directly requires \(\Omega(d)\) operations, where \(d\) is the number of rows. To improve efficiency, we can convert this matrix comparison to a polynomial comparison, leveraging the Schwartz-Zippel Lemma, which allows us to check polynomial equality with \(\Omega(1)\) evaluations.</p>
<p><strong>Equivalence of Matrices</strong></p>
<p>Let's consider a simpler example to illustrate this concept. Suppose we want to test the equivalence \(Av = Bu\), where:</p>
<p>\begin{align*}
A = \begin{bmatrix}
2 &amp; 5 \\
3 &amp; 1 \\
\end{bmatrix},
B = \begin{bmatrix}
4 &amp; 1 \\
2 &amp; 3 \\
\end{bmatrix},
v = \begin{bmatrix}
3 \\ 1
\end{bmatrix},
u = \begin{bmatrix}
2 \\ 2
\end{bmatrix}
\end{align*}</p>
<p>The equivalence check can be represented as:</p>
<p>\begin{equation*}
\begin{bmatrix}
2 \\ 3
\end{bmatrix} \cdot 3 + \begin{bmatrix}
5 \\ 1
\end{bmatrix} \cdot 1 = \begin{bmatrix}
4 \\ 2
\end{bmatrix} \cdot 2 + \begin{bmatrix}
1 \\ 3
\end{bmatrix} \cdot 2
\end{equation*}</p>
<p>This matrix-vector equality check is equivalent to the following polynomial equality check:</p>
<p>\begin{equation*}
3 \cdot \lambda([(1, 2), (2, 3)]) + 1 \cdot \lambda([(1, 5), (2, 1)]) = 2 \cdot \lambda([(1, 4), (2, 2)]) + 2 \cdot \lambda([(1, 1), (2, 3)])
\end{equation*}</p>
<p>where \(\lambda\) denotes Lagrange Interpolation. In \(\mathbb{F}_{11}\) (field with 11 elements), we have:</p>
<p>\begin{align*}
\lambda([(1, 2), (2, 3)]) &amp;= x + 1 \\
\lambda([(1, 5), (2, 1)]) &amp;= 7x + 9 \\
\lambda([(1, 4), (2, 2)]) &amp;= 9x + 6 \\
\lambda([(1, 1), (2, 3)]) &amp;= 2x + 10
\end{align*}</p>
<p>The Schwartz-Zippel Lemma states that we need only one evaluation at a random point to check the equivalence of polynomials with high probability.</p>
<p><strong>Back to R1CS</strong></p>
<p>Let's thinks about how we can leverage the above method for the verification of R1CS. First, we can construct the interpolated polynomials for \(L \cdot v\), \(R \cdot v\), and \(O \cdot v\), denoted as \(\ell(x)\), \(r(x)\), and \(o(x)\), repectively, as follows:</p>
<p>\begin{align*}
\ell(x) &amp;= \sum^{d}_{i=1} v_i \ell_i(x) \quad \hbox{,where } \ell_i(x) := \lambda([(1, L_i,_1), (2, L_i,_2), \cdots,(m, L_i,_m)]) \\
r(x) &amp;= \sum^{d} _{i=1} v_i r_i(x) \quad \hbox{,where } r_i(x) := \lambda([(1, R_i,_1), (2, R_i,_2), \cdots,(m, R_i,_m)]) \\
o(x) &amp;= \sum^{d} _{i=1} v_i o_i(x) \quad \hbox{,where } o_i(x) := \lambda([(1, O_i,_1), (2, O_i,_2), \cdots,(m, O_i,_m)])
\end{align*}</p>
<p>However, the homomorphic property for multiplication doesn't hold for Lagrange Interpolation. While \(\ell(x)\), \(r(x)\), and \(o(x)\) are of degree at most \(m-1\), \(\ell(x) \cdot r(x)\) is of degree at most \(2m-2\). Thus, we don't have \(\ell(x) \cdot r(x) = o(x)\).</p>
<p>To address this discrepancy, we introduce a degree \(m\) polynomial \(t(x) = \prod_{i=1}^{m} (x - i)\). Given the constituion of the interpolated equations, we have that \(\forall{x} \in \{1,\cdots, d\}\) \(\ell(x) \cdot r(x) = o(x)\). This implies the following:</p>
<p>\begin{equation}
\forall{x} \in \{1,\cdots, m\} \quad \ell(x) \cdot r(x) - o(x) = 0
\end{equation}</p>
<p>Thus, we can factorize \(\ell(x) \cdot r(x) - o(x)\) into the product of \(t(x)\) and an appripriate polynomial \(h(x)\) such that \(\ell(x) \cdot r(x) - o(x) = t(x)h(x)\).</p>
<p>Then, we can then rewrite the equation as:</p>
<p>\begin{equation}
\ell(x) \cdot r(x) = o(x) + h(x) \cdot t(x)
\end{equation}</p>
<p>This formulation allows us to maintain the desired polynomial relationships while accounting for the degree differences.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct QAP&lt;'a, F: Field&gt; {
    pub r1cs: &amp;'a R1CS&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
}

impl&lt;'a, F: Field&gt; QAP&lt;'a, F&gt; {
    fn new(r1cs: &amp;'a R1CS&lt;F&gt;) -&gt; Self {
        QAP {
            r1cs: r1cs,
            t: Polynomial::&lt;F&gt;::from_monomials(
                &amp;(1..=r1cs.d).map(|i| F::from_value(i)).collect::&lt;Vec&lt;F&gt;&gt;(),
            ),
        }
    }

    fn generate_polynomials(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; (Polynomial&lt;F&gt;, Polynomial&lt;F&gt;, Polynomial&lt;F&gt;) {
        let left_dot_products = self
            .r1cs
            .left
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let right_dot_products = self
            .r1cs
            .right
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let out_dot_products = self
            .r1cs
            .out
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();

        let x = (1..=self.r1cs.m)
            .map(|i| F::from_value(i))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let left_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;left_dot_products);
        let right_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;right_dot_products);
        let out_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;out_dot_products);
        (
            left_interpolated_polynomial,
            right_interpolated_polynomial,
            out_interpolated_polynomial,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proving-single-polynomial"><a class="header" href="#proving-single-polynomial">Proving Single Polynomial</a></h1>
<p>Before dealing with all of \(\ell(x)\), \(r(x)\), and \(o(x)\) at once, we design a protocol that allows the Prover \(\mathcal{A}\) to convince the Verifier \(\mathcal{B}\) that \(\mathcal{A}\) knows a specific polynomial. Let's denote this polynomial of degree \(n\) with coefficients in a finite field as:</p>
<p>\begin{equation}
P(x) = c_0 + c_1 x + c_2 x^{2} + \cdots c_n x^{n}
\end{equation}</p>
<p>Assume \(P(x)\) has \(n\) roots, \(a_1, a_2, \ldots, a_n \in \mathbb{F}\), such that \(P(x) = (x - a_1)(x - a_2)\cdots(x - a_n)\). The Verifier \(\mathcal{B}\) knows \(m &lt; n\) roots of \(P(x)\), namely \(a_1, a_2, \ldots, a_m\). Let \(T(x) = (x - a_1)(x - a_2)\cdots(x - a_m)\). Note that the Prover also knows \(T(x)\).</p>
<p>The Prover's objective is to convince the Verifier that \(\mathcal{A}\) knows a polynomial \(H(x) = \frac{P(x)}{T(x)}\).</p>
<h2 id="first-protocol-naive-approach"><a class="header" href="#first-protocol-naive-approach">First Protocol: Naive Approach</a></h2>
<p>The simplest approach to prove that \(\mathcal{A}\) knows \(H(x)\) is as follows:</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) sends all possible values in \(\mathbb{F}\) to \(\mathcal{A}\).</li>
<li>\(\mathcal{A}\) computes and sends all possible outputs of \(H(x)\) and \(P(x)\).</li>
<li>\(\mathcal{B}\) checks whether \(H(a)T(a) = P(a)\) holds for any \(a\) in \(\mathbb{F}\).</li>
</ul>
<p>This protocol is highly inefficient, requiring \(\mathcal{O}(|\mathbb{F}|)\) evaluations and communications.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover1&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier1&lt;F: Field&gt; {
    pub t: Polynomial&lt;F&gt;,
    pub known_roots: Vec&lt;F&gt;,
}

impl&lt;F: Field&gt; Prover1&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover1 { p, t, h }
    }

    pub fn compute_all_values(&amp;self, modulus: i128) -&gt; (HashMap&lt;F, F&gt;, HashMap&lt;F, F&gt;) {
        let mut h_values = HashMap::new();
        let mut p_values = HashMap::new();

        for i in 0..modulus {
            let x = F::from_value(i);
            h_values.insert(x.clone(), self.h.eval(&amp;x));
            p_values.insert(x.clone(), self.p.eval(&amp;x));
        }

        (h_values, p_values)
    }
}

impl&lt;F: Field&gt; Verifier1&lt;F&gt; {
    pub fn new(known_roots: Vec&lt;F&gt;) -&gt; Self {
        let t = Polynomial::from_monomials(&amp;known_roots);
        Verifier1 { t, known_roots }
    }

    pub fn verify(&amp;self, h_values: &amp;HashMap&lt;F, F&gt;, p_values: &amp;HashMap&lt;F, F&gt;) -&gt; bool {
        for (x, h_x) in h_values {
            let t_x = self.t.eval(x);
            let p_x = p_values.get(x).unwrap();
            if h_x.clone() * t_x != *p_x {
                return false;
            }
        }
        true
    }
}

pub fn naive_protocol&lt;F: Field&gt;(
    prover: &amp;Prover1&lt;F&gt;,
    verifier: &amp;Verifier1&lt;F&gt;,
    modulus: i128,
) -&gt; bool {
    // Step 1: Verifier1 sends all possible values (implicitly done by Prover1 computing all values)

    // Step 2: Prover1 computes and sends all possible outputs
    let (h_values, p_values) = prover.compute_all_values(modulus);

    // Step 3: Verifier1 checks whether H(a)T(a) = P(a) holds for any a in F
    verifier.verify(&amp;h_values, &amp;p_values)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="second-protocol-schwartz-zippel-lemma"><a class="header" href="#second-protocol-schwartz-zippel-lemma">Second Protocol: Schwartz-Zippel Lemma</a></h2>
<p>Instead of evaluating polynomials at all values in \(\mathbb{F}\), we can leverage the Schwartz-Zippel Lemma: if \(H(s) = \frac{P(s)}{T(s)}\) or equivalently \(H(s)T(s) = P(s)\) for a random element \(s\), we can conclude that \(H(x) = \frac{P(x)}{T(x)}\) with high probability. Thus, the Prover \(\mathcal{A}\) only needs to send evaluations of \(P(s)\) and \(H(s)\) for a random input \(s\) received from \(\mathcal{B}\).</p>
<p><strong>Protocol:</strong></p>
<ul>
<li><em>\(\mathcal{B}\) draws random \(s\) from \(\mathbb{F}\) and sends it to \(\mathcal{A}\).</em></li>
<li><em>\(\mathcal{A}\) computes \(h = H(s)\) and \(p = P(s)\) and send them to \(\mathcal{B}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(p = t h\), where \(t\) denotes \(T(s)\).</em></li>
</ul>
<p>This protocol is efficient, requiring only a constant number of evaluations and communications.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover2&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier2&lt;F: Field&gt; {
    pub t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; Prover2&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover2 { p, t, h }
    }

    pub fn compute_values(&amp;self, s: &amp;F) -&gt; (F, F) {
        let h_s = self.h.eval(s);
        let p_s = self.p.eval(s);
        (h_s, p_s)
    }
}

impl&lt;F: Field&gt; Verifier2&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        Verifier2 { t }
    }

    pub fn generate_challenge(&amp;self) -&gt; F {
        F::random_element(&amp;[])
    }

    pub fn verify(&amp;self, s: &amp;F, h: &amp;F, p: &amp;F) -&gt; bool {
        let t_s = self.t.eval(s);
        h.clone() * t_s == *p
    }
}

pub fn schwartz_zippel_protocol&lt;F: Field&gt;(prover: &amp;Prover2&lt;F&gt;, verifier: &amp;Verifier2&lt;F&gt;) -&gt; bool {
    // Step 1: Verifier2 generates a random challenge
    let s = verifier.generate_challenge();

    // Step 2: Prover2 computes and sends h and p
    let (h, p) = prover.compute_values(&amp;s);

    // Step 3: Verifier2 checks whether p = t * h
    verifier.verify(&amp;s, &amp;h, &amp;p)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability:</strong></p>
<p>However, it is vulnerable to a malicious prover who could send an arbitrary value \(h'\) and the corresponding \(p'\) such that \(p' = h't\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simulating a malicious prover
pub struct MaliciousProver2&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; MaliciousProver2&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        MaliciousProver2 { t }
    }

    pub fn compute_malicious_values(&amp;self, s: &amp;F) -&gt; (F, F) {
        let h_prime = F::random_element(&amp;[]);
        let t_s = self.t.eval(s);
        let p_prime = h_prime.clone() * t_s;
        (h_prime, p_prime)
    }
}

pub fn malicious_schwartz_zippel_protocol&lt;F: Field&gt;(
    prover: &amp;MaliciousProver2&lt;F&gt;,
    verifier: &amp;Verifier2&lt;F&gt;,
) -&gt; bool {
    // Step 1: Verifier2 generates a random challenge
    let s = verifier.generate_challenge();

    // Step 2: Malicious Prover2 computes and sends h' and p'
    let (h_prime, p_prime) = prover.compute_malicious_values(&amp;s);

    // Step 3: Verifier2 checks whether p' = t * h'
    verifier.verify(&amp;s, &amp;h_prime, &amp;p_prime)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="third-protocol-discrete-logarithm-assumption"><a class="header" href="#third-protocol-discrete-logarithm-assumption">Third Protocol: Discrete Logarithm Assumption</a></h2>
<p>To address this vulnerability, the Verifier must hide the randomly chosen input \(s\) from the Prover. This can be achieved using the discrete logarithm assumption: it is computationally hard to determine \(s\) from \(\gamma\), where \(\gamma = g^s \bmod q\). Thus, it's safe for the Verifier to send \(\gamma\), as the Prover cannot easily derive \(s\) from it.</p>
<p>An interesting property of polynomial exponentiation is:</p>
<p>\begin{align}
g^{P(x)} &amp;= g^{c_0 + c_1 x + c_2 x^{2} + \cdots c_n x^{n}} = g^{c_0} (g^{x})^{c_1}  (g^{(x^2)})^{c_2} \cdots (g^{(x^n)})^{c_n}
\end{align}</p>
<p>Instead of sending \(s\), the Verifier can send \(g\) and \(\gamma_{i} = g^{(s^i)}\) for \(i = 1, \cdots n\). BE CAREFUL THAT <strong>\(g^{(s^i)} \neq (g^s)^i\)</strong>. The Prover can still evaluate \(g^p = g^{P(s)}\) using these powers of \(g\):</p>
<p>\begin{equation}
g^{p} = g^{P(s)} = g^{c_0} \gamma_{1}^{c_1} \gamma_{2}^{c_2} \cdots \gamma_{n}^{c_n}
\end{equation}</p>
<p>Similarly, the Prover can evaluate \(g^h = g^{H(s)}\). The Verifier can then check \(p = ht \iff g^p = (g^h)^t\).</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly draw \(s\) from \(\mathbb{F}\).</li>
<li><em>\(\mathcal{B}\) computes and sends \(\{\gamma_1, \gamma_2, ..., \gamma_{n}\}\), where \(\gamma_i= g^{(s^{i})}\).</em></li>
<li><em>\(\mathcal{A}\) computes and sends \(u = g^{p}\) and \(v = g^{h}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(u = v^{t}\).</em></li>
</ul>
<p>This approach prevents the Prover from obtaining \(s\) or \(t = T(s)\), making it impossible to send fake \((h', p')\) such that \(p' = h't\).</p>
<p><strong>Implementation:</strong></p>
<p>Suppose we are working in a finite field (\mathbb{F}_q) derived from a prime number (q). It‚Äôs important to note that</p>
<p>\[g^{c_0} \cdot (g^{s^{1} \bmod q})^{c_1} \cdots (g^{s^{n} \bmod q})^{c_n} \bmod q \]</p>
<p>is <strong>not</strong> equal to</p>
<p>\[g^{c_0 + c_1 s^{1} + c_2 s^{2} + \cdots c_n s^{n}} \bmod q\]</p>
<p>However, directly calculating \(s^i\) without taking modulo results in too large values to handle. To address this, we leverage Fermat's Little Theorem, which states that for a prime \(q\):</p>
<p>\[a^{b \bmod q - 1} \bmod q\]</p>
<p>Following this principle, our implementation computes \(s^i\) modulo \(q - 1\) to keep the values manageable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover3&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier3&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    g: F,
}

impl&lt;F: Field&gt; Prover3&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover3 { p, t, h }
    }

    pub fn compute_values(&amp;self, s_powers: &amp;[F]) -&gt; (F, F) {
        let g_p = self.p.eval_with_powers(s_powers);
        let g_h = self.h.eval_with_powers(s_powers);
        (g_p, g_h)
    }
}

impl&lt;F: Field&gt; Verifier3&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let s = F::random_element(&amp;[]);
        let g = F::from_value(generator);
        Verifier3 { t, s, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; Vec&lt;F&gt; {
        let mut s_powers = vec![];
        for i in 0..(max_degree + 1) {
            s_powers.push(
                self.g
                    .pow(self.s.clone().pow_m1(i.to_bigint().unwrap()).get_value()),
            );
        }
        s_powers
    }

    pub fn verify(&amp;self, u: &amp;F, v: &amp;F) -&gt; bool {
        let t_s = self.t.eval_m1(&amp;self.s);
        u == &amp;v.pow(t_s.get_value())
    }
}

pub fn discrete_log_protocol&lt;F: Field&gt;(prover: &amp;Prover3&lt;F&gt;, verifier: &amp;Verifier3&lt;F&gt;) -&gt; bool {
    // Step 1 &amp; 2: Verifier3 generates a challenge
    let max_degree = prover.p.degree();
    let s_powers = verifier.generate_challenge(max_degree as usize);

    // Step 3: Prover3 computes and sends u = g^p and v = g^h
    let (u, v) = prover.compute_values(&amp;s_powers);

    // Step 4: Verifier3 checks whether u = v^t
    verifier.verify(&amp;u, &amp;v)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability:</strong></p>
<p>However, this protocol still has a flaw. Since the Prover can compute \(g^t\) from \(\gamma _1, \cdots \gamma _m\), they could send fake values \(((g^{t})^{z}, g^{z})\) instead of \((g^p, g^h)\) for an arbitrary value \(z\). The verifier's check would still pass, and they could not detect this deception.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simulating a malicious prover
pub struct MaliciousProver3&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; MaliciousProver3&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        MaliciousProver3 { t }
    }

    pub fn compute_malicious_values(&amp;self, s_powers: &amp;[F]) -&gt; (F, F) {
        let g_t = self.t.eval_with_powers(s_powers);
        let z = F::random_element(&amp;[]);
        let g = &amp;s_powers[0];
        let fake_v = g.pow(z.get_value());
        let fake_u = g_t.pow(z.get_value());
        (fake_u, fake_v)
    }
}

pub fn malicious_discrete_log_protocol&lt;F: Field&gt;(
    prover: &amp;MaliciousProver3&lt;F&gt;,
    verifier: &amp;Verifier3&lt;F&gt;,
) -&gt; bool {
    // Step 1 &amp; 2: Verifier3 generates a challenge
    let max_degree = prover.t.degree() as usize;
    let s_powers = verifier.generate_challenge(max_degree as usize);

    // Step 3: Malicious Prover3 computes and sends fake u and v
    let (fake_u, fake_v) = prover.compute_malicious_values(&amp;s_powers);

    // Step 4: Verifier3 checks whether u = v^t (which will pass for the fake values)
    verifier.verify(&amp;fake_u, &amp;fake_v)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="forth-protocol-knowledge-of-exponent-assumption"><a class="header" href="#forth-protocol-knowledge-of-exponent-assumption">Forth Protocol: Knowledge of Exponent Assumption</a></h2>
<p>To address the vulnerability where the verifier \(\mathcal{B}\) cannot distinguish if \(v (= g^h)\) from the prover is a power of \(\gamma_i = g^{(s^i)}\), we can employ the Knowledge of Exponent Assumption. This approach involves the following steps:</p>
<ul>
<li>\(\mathcal{B}\) sends both \(\gamma_i\) and \(\gamma'_i = \gamma_i^r\) for a new random value \(r\).</li>
<li>The prover returns \(a = (\gamma_i)^{c_i}\) and \(a' = (\gamma'_i)^{c_i}\) for \(i = 1, ..., n\).</li>
<li>\(\mathcal{B}\) can conclude that \(a\) is a power of \(\gamma_i\) if \(a^r = a'\).</li>
</ul>
<p>Based on this assumption, we can design an improved protocol:</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly selects \(s\) and <em>\(r\)</em> from field \(\mathbb{F}\).</li>
<li>\(\mathcal{B}\) computes and sends \(\{\gamma_1, \gamma_2, ..., \gamma_{n}\}\) <em>and \(\{\gamma'_1, \gamma'_2, ..., \gamma'_{n}\}\), where \(\gamma_i = g^{(s^i)}\) and \(\gamma' = \gamma_{r} = g^{(s^{i})r}\).</em></li>
<li>\(\mathcal{A}\) computes and sends \(u = g^{p}\), \(v = g^{h}\), <em>and \(w = g^{p'}\), where \(g^{p'} = g^{rP(s)}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(u^{r} = w\).</em></li>
<li>\(\mathcal{B}\) checks whether \(u = v^{t}\).</li>
</ul>
<p>The prover can compute \(g^{p'} = g^{rP(s)} = g^{c_0} (\gamma_{1})'^{c_1} (\gamma'_{2})^{c_2} \cdots (\gamma_{n}')^{c_n}\). This protocol now satisfies the properties of a SNARK: completeness, soundness, and efficiency.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover4&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier4&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    r: F,
    g: F,
}

impl&lt;F: Field&gt; Prover4&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover4 { p, t, h }
    }

    pub fn compute_values(&amp;self, s_powers: &amp;[F], s_prime_powers: &amp;[F]) -&gt; (F, F, F) {
        let g_p = self.p.eval_with_powers(s_powers);
        let g_h = self.h.eval_with_powers(s_powers);
        let g_p_prime = self.p.eval_with_powers(s_prime_powers);
        (g_p, g_h, g_p_prime)
    }
}

impl&lt;F: Field&gt; Verifier4&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let s = F::random_element(&amp;[]);
        let r = F::random_element(&amp;[]);
        let g = F::from_value(generator);
        Verifier4 { t, s, r, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; (Vec&lt;F&gt;, Vec&lt;F&gt;) {
        let mut s_powers = vec![];
        let mut s_prime_powers = vec![];

        for i in 0..(max_degree + 1) {
            s_powers.push(
                self.g
                    .pow(self.s.clone().pow_m1(i.to_bigint().unwrap()).get_value()),
            );
            s_prime_powers.push(s_powers.last().unwrap().pow(self.r.get_value()));
        }

        (s_powers, s_prime_powers)
    }

    pub fn verify(&amp;self, u: &amp;F, v: &amp;F, w: &amp;F) -&gt; bool {
        let t_s = self.t.eval_m1(&amp;self.s);
        let u_r = u.pow(self.r.clone().get_value());

        // Check 1: u^r = w
        let check1 = u_r == *w;

        // Check 2: u = v^t
        let check2 = *u == v.pow(t_s.get_value());

        check1 &amp;&amp; check2
    }
}

pub fn knowledge_of_exponent_protocol&lt;F: Field&gt;(
    prover: &amp;Prover4&lt;F&gt;,
    verifier: &amp;Verifier4&lt;F&gt;,
) -&gt; bool {
    // Step 1 &amp; 2: Verifier4 generates a challenge
    let max_degree = std::cmp::max(prover.p.degree(), prover.h.degree()) as usize;
    let (s_powers, s_prime_powers) = verifier.generate_challenge(max_degree + 1);

    // Step 3: Prover4 computes and sends u = g^p, v = g^h, and w = g^p'
    let (u, v, w) = prover.compute_values(&amp;s_powers, &amp;s_prime_powers);

    // Step 4 &amp; 5: Verifier4 checks whether u^r = w and u = v^t
    verifier.verify(&amp;u, &amp;v, &amp;w)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fifth-protocol-zero-knowledge"><a class="header" href="#fifth-protocol-zero-knowledge">Fifth Protocol: Zero Knowledge</a></h2>
<p>To transform the above protocol into a zk-SNARK, we need to ensure that the verifier cannot learn anything about \(P(x)\) from the prover's information. This is achieved by having the prover obfuscate all information with a random secret value \(\delta\):</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly selects \(s\) and \(r\) from field \(\mathbb{F}\).</li>
<li>\(\mathcal{B}\) computes and sends \(\{\gamma_1, \gamma_2, ..., \gamma_{n}\}\) and \(\{\gamma_1', \gamma'_2, ..., \gamma'_{n}\}\), where \(\gamma_i = g^{(s^{i})}\) and \(\gamma_i' = \gamma_i^{r} = g^{(s^{i})r}\).</li>
<li><em>\(\mathcal{A}\) randomly selects \(\delta\) from field \(\mathbb{F}\).</em></li>
<li><em>\(\mathcal{A}\) computes and sends \(u' = (g^{p})^{\delta}\), \(v' = (g^{h})^{\delta}\), and \(w' = (g^{p'})^{\delta}\).</em></li>
<li>\(\mathcal{B}\) checks whether \(u'^{r} = w'\).</li>
<li>\(\mathcal{B}\) checks whether \(u' = v'^{t}\).</li>
</ul>
<p>By introducing the random value \(\delta\), the verifier can no longer learn anything about \(p\), \(h\), or \(w\), thus achieving zero knowledge.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover5&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier5&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    r: F,
    g: F,
}

impl&lt;F: Field&gt; Prover5&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover5 { p, t, h }
    }

    pub fn compute_values(&amp;self, s_powers: &amp;[F], s_prime_powers: &amp;[F]) -&gt; (F, F, F) {
        let delta = F::random_element(&amp;[]);

        let g_p = self.p.eval_with_powers(s_powers);
        let g_h = self.h.eval_with_powers(s_powers);
        let g_p_prime = self.p.eval_with_powers(s_prime_powers);

        let u_prime = g_p.pow(delta.get_value());
        let v_prime = g_h.pow(delta.get_value());
        let w_prime = g_p_prime.pow(delta.get_value());

        (u_prime, v_prime, w_prime)
    }
}

impl&lt;F: Field&gt; Verifier5&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let s = F::random_element(&amp;[]);
        let r = F::random_element(&amp;[]);
        let g = F::from_value(generator);
        Verifier5 { t, s, r, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; (Vec&lt;F&gt;, Vec&lt;F&gt;) {
        let mut s_powers = vec![];
        let mut s_prime_powers = vec![];

        for i in 0..(max_degree + 1) {
            s_powers.push(
                self.g
                    .pow(self.s.clone().pow_m1(i.to_bigint().unwrap()).get_value()),
            );
            s_prime_powers.push(s_powers.last().unwrap().pow(self.r.get_value()));
        }

        (s_powers, s_prime_powers)
    }

    pub fn verify(&amp;self, u_prime: &amp;F, v_prime: &amp;F, w_prime: &amp;F) -&gt; bool {
        let t_s = self.t.eval_m1(&amp;self.s);
        let u_prime_r = u_prime.pow(self.r.clone().get_value());

        // Check 1: u'^r = w'
        let check1 = u_prime_r == *w_prime;

        // Check 2: u' = v'^t
        let check2 = *u_prime == v_prime.pow(t_s.get_value());

        check1 &amp;&amp; check2
    }
}

pub fn zk_protocol&lt;F: Field&gt;(prover: &amp;Prover5&lt;F&gt;, verifier: &amp;Verifier5&lt;F&gt;) -&gt; bool {
    // Step 1 &amp; 2: Verifier5 generates a challenge
    let max_degree = std::cmp::max(prover.p.degree(), prover.h.degree()) as usize;
    let (s_powers, s_prime_powers) = verifier.generate_challenge(max_degree + 1);

    // Step 3 &amp; 4: Prover5 computes and sends u' = (g^p)^Œ¥, v' = (g^h)^Œ¥, and w' = (g^p')^Œ¥
    let (u_prime, v_prime, w_prime) = prover.compute_values(&amp;s_powers, &amp;s_prime_powers);

    // Step 5 &amp; 6: Verifier5 checks whether u'^r = w' and u' = v'^t
    verifier.verify(&amp;u_prime, &amp;v_prime, &amp;w_prime)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sixth-protocol-non-interactivity"><a class="header" href="#sixth-protocol-non-interactivity">Sixth Protocol: Non-interactivity</a></h2>
<p>The previously described protocol requires each verifier to generate unique random values, which becomes inefficient when a prover needs to demonstrate knowledge to multiple verifiers. To address this, we aim to eliminate the interaction between the prover and verifier. One effective solution is the use of a trusted setup.</p>
<p>Specifically, we let a thrid trusted party generate the secret seeds, which neither the prover nor the verifier can access. However, this prevents the verifier \(\mathcal{B}\) from calculating \(u'^{r}\) to check \(u'^{r} = w'\). Instead, the verifier can use a paring with bilinear mapping; \(u'^{r} = w'\) is equivalent to \(e(u' = (g^{p})^{\delta}, g^{r}) = e(w'=(g^{p'})^{\delta}, g)\).</p>
<p>In this tutorial, we adopt the optimal ate pairing, which is an asynmetric pairing and uses two different cyclic groups derived from elliptic curves; \(e(g_1^a, g_2^b) = e(g_1^{ab}, g_2) = e(b_1, g_2^{ab})\), where \(g_1\) and \(g_2\) are the generators of two different cyclic groups.</p>
<p><strong>Protocol (Trusted Setup):</strong></p>
<ul>
<li><em><strong>Secret Seed:</strong> A trusted third party generates the random values \(s\) and \(r\)</em></li>
<li><em><strong>Proof Key:</strong> Provided to the prover</em>
<ul>
<li><em>\(\{\gamma_1, \gamma_2, ..., \gamma_{n}\}\), where \(\gamma_{i} = g_1^{(s^i)}\)</em></li>
<li><em>\(\{\gamma'_1, \gamma'_2, ..., \gamma'_{n}\}\), where \(\gamma_i' = g_1^{(s^{i})r}\)</em></li>
</ul>
</li>
<li><em><strong>Verification Key:</strong> Distributed to verifiers</em>
<ul>
<li><em>\(g_2^r\)</em></li>
<li><em>\(g_2^t := g_2^{T(s)}\)</em></li>
</ul>
</li>
<li><em>After distribution, the original secret seeds are securely destroyed.</em></li>
</ul>
<p>Then, the non-interactive protocol consists of two main parts: proof generation and verification.</p>
<p><strong>Protocol (Proof):</strong></p>
<ul>
<li><em>\(\mathcal{A}\) receives the proof key</em></li>
<li><em>\(\mathcal{A}\) randomly selects \(\delta\) from field \(\mathbb{F}\).</em></li>
<li><em>\(\mathcal{A}\) broadcast the proof \(\pi = (u' = (g_1^{p})^{\delta}, v' = (g_1^{h})^{\delta}, w' = (g_1^{p'})^{\delta})\)</em></li>
</ul>
<p><strong>Protocol (Verification):</strong></p>
<ul>
<li><em>\(\mathcal{B}\) receives the verification key.</em></li>
<li><em>\(\mathcal{B}\) receives the proof \(\pi\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(e(u', g_2^r) = e(w', g_2)\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(e(u', g_2) = e (v', g_2^t)\).</em></li>
</ul>
<p><strong>Implementation:</strong></p>
<p>This tutorial utilize elliptic curves called <code>BN128</code> for pairing:</p>
<ul>
<li>
<p>First Group:</p>
<ul>
<li>Curve: \(Y^2 = x^3 + 3\) over the finite field \(\mathbb{F}_{q}\), where \(q\) is defined as 21888242871839275222246405745257275088696311157297823662689037894645226208583.</li>
<li>Generator \(\mathscr{g}_1 := (1, 2)\)</li>
</ul>
</li>
<li>
<p>Second Group:</p>
<ul>
<li>Curve: \(Y^2 = x^3 + 3\) over the finite field \(\mathbb{F} _{q^2}\)</li>
<li>Modulus polynomial for \(\mathbb{F} _{q^2}\): \(x^2 + 1\)</li>
<li>Generator \(\mathscr{g}_2\) := (11559732032986387107991004021392285783925812861821192530917403151452391805634x + 10857046999023057135944570762232829481370756359578518086990519993285655852781, 4082367875863433681332203403145435568316851327593401208105741076214120093531x + 8495653923123431417604973247489272438418190587263600148770280649306958101930)</li>
</ul>
</li>
</ul>
<p>The orders of two groups are \(\omega := \) 21888242871839275222246405745257275088548364400416034343698204186575808495617. Thus, we evaluate the polynomials over the finite field \(\mathbb{F}_{\omega}\).</p>
<p>In the context of elliptic curves, the power of a generator corresponds to the multiplication of an elliptic curve point. This property is reflected in the ate pairing on BN128, which satisfies:</p>
<p>\[
e(a  \mathscr{g}_1, b \mathscr{g}_2) =  e(ab \mathscr{g}_1, \mathscr{g}_2) = e(\mathscr{g}_1, ab\mathscr{g}_2)<br />
\]</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProofKey {
    alpha: Vec&lt;G1Point&gt;,
    alpha_prime: Vec&lt;G1Point&gt;,
}

pub struct VerificationKey {
    g_r: G2Point,
    g_t_s: G2Point,
}

pub struct Proof {
    u_prime: G1Point,
    v_prime: G1Point,
    w_prime: G1Point,
}

pub fn setup(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    t: &amp;Polynomial&lt;FqOrder&gt;,
    n: usize,
) -&gt; (ProofKey, VerificationKey) {
    let s = FqOrder::random_element(&amp;[]);
    let r = FqOrder::random_element(&amp;[]);

    let mut alpha = Vec::with_capacity(n);
    let mut alpha_prime = Vec::with_capacity(n);

    let mut s_power = FqOrder::one();
    for _ in 0..1 + n {
        alpha.push(g1.mul_ref(s_power.clone().get_value()));
        alpha_prime.push(g1.mul_ref((s_power.clone() * r.clone()).get_value()));
        s_power = s_power * s.clone();
    }

    let g_r = g2.mul_ref(r.clone().get_value());
    let g_t_s = g2.mul_ref(t.eval(&amp;s).get_value());

    (
        ProofKey { alpha, alpha_prime },
        VerificationKey { g_r, g_t_s },
    )
}

pub fn prove(p: &amp;Polynomial&lt;FqOrder&gt;, t: &amp;Polynomial&lt;FqOrder&gt;, proof_key: &amp;ProofKey) -&gt; Proof {
    let h = p.clone() / t.clone();
    let delta = FqOrder::random_element(&amp;[]);

    let g_p = p.eval_with_powers_on_curve(&amp;proof_key.alpha);
    let g_h = h.eval_with_powers_on_curve(&amp;proof_key.alpha);
    let g_p_prime = p.eval_with_powers_on_curve(&amp;proof_key.alpha_prime);

    Proof {
        u_prime: g_p * delta.get_value(),
        v_prime: g_h * delta.get_value(),
        w_prime: g_p_prime * delta.get_value(),
    }
}

pub fn verify(g2: &amp;G2Point, proof: &amp;Proof, vk: &amp;VerificationKey) -&gt; bool {
    // Check e(u', rG_2) = e(w', G_2)
    let pairing1 = optimal_ate_pairing(&amp;proof.u_prime, &amp;vk.g_r);
    let pairing2 = optimal_ate_pairing(&amp;proof.w_prime, g2);
    let check1 = pairing1 == pairing2;

    // Check e(u', G_2) = e(v', tG_2)
    let pairing3 = optimal_ate_pairing(&amp;proof.u_prime, g2);
    let pairing4 = optimal_ate_pairing(&amp;proof.v_prime, &amp;vk.g_t_s);
    let check2 = pairing3 == pairing4;

    check1 &amp;&amp; check2
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bringing-it-all-together-snark"><a class="header" href="#bringing-it-all-together-snark">Bringing It All Together: SNARK</a></h1>
<p>Let's recap the previous sections. First, the relationship between the inputs and outputs of any program can be expressed as a rank-one constraint system (R1CS) as follows:</p>
<p>\[
(L \cdot v) \circ (R \cdot v) - O \cdot v = 0<br />
\]</p>
<p>, where \(v\) is the concatenation of all inputs, outputs, and intermediate values. This allows us to transform the statement, "I know the input values \(x\) that make the program returns the output values \(y\)", into "I know \(v\), whose outputs components are \(y\), that satisfies the constraint system corresponding to the program".</p>
<p>Then, instead of separately checking each constraint (which corresponds to a row in the R1CS matrix), we can convert this into a more efficient polynomial-equivalence test:</p>
<p>\[
\ell(x) \cdot r(x) = o(x) + h(x) \cdot t(x)
\]</p>
<p>In this tutorial, we use symmetric pairing to formulate each protocol for simplicity, where the first and second arguments are in the same group, while the actual implementation adopts an asymmetric pairing, similar to the final protocol in the previous chapter</p>
<h2 id="first-protocol-naive-approach-1"><a class="header" href="#first-protocol-naive-approach-1">First Protocol: Naive Approach</a></h2>
<p>The simplest protocol, based on the previous chapter, is as follows:</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\) and \(\alpha\).</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha \ell_i(s)},g^{\alpha r_i(s)},g^{\alpha o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}, g^{\alpha}\)</li>
</ul>
</li>
<li>After distribution, the original secret seeds are securely destroyed.</li>
</ul>
<p>Both the proof key and the verification key are publicly available, enabling anyone to generate and verify proofs based on the target program.</p>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Run the program to obtain the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x),\quad r(x) = \sum_{i=1}^{d} v_i r_{i}(x),\quad o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute the quotient polynomial:
<ul>
<li>\(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
</ul>
</li>
<li>Evaluate each polynomial at \(s\).
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v _i} ,\quad g^{r(s)} = \prod^{d} _{i=1} (g^{r_i(s)})^{v_i} ,\quad g^{o(s)} = \prod^{d} _{i=1} (g^{o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate the shifted polynomials at \(s\).
<ul>
<li>\(g^{\alpha \ell(s)} = \prod^{d} _{i=1} (g^{\alpha \ell _i(s)})^{v _i} ,\quad g^{\alpha r(s)} = \prod^{d} _{i=1} (g^{\alpha r _i(s)})^{v _i} ,\quad g^{\alpha o(s)} = \prod^{d} _{i=1} (g^{\alpha o_i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Compute \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><strong>Proof</strong>:
<ul>
<li>\((g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha \ell(s)}, g^{\alpha r(s)}, g^{\alpha o(s)}, g^{h(s)})\)</li>
</ul>
</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse the proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h})\)</li>
<li>Check the polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha}) = e(g^{\ell'}, g),\quad e(g^{r}, g^{\alpha}) = e(g^{r'}, g),\quad e(g^{o}, g^{\alpha}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Verify validity of the proof
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ProofKey1 {
    g1_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_r_i_vec: Vec&lt;G2Point&gt;,
    g1_o_i_vec: Vec&lt;G1Point&gt;,
    g1_alpha_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_alpha_r_i_vec: Vec&lt;G2Point&gt;,
    g1_alpha_o_i_vec: Vec&lt;G1Point&gt;,
    g1_sj_vec: Vec&lt;G1Point&gt;,
}

#[derive(Debug, Clone)]
pub struct VerificationKey1 {
    g1_alpha: G1Point,
    g2_alpha: G2Point,
    g2_t_s: G2Point,
}

#[derive(Debug, Clone)]
pub struct Proof1 {
    g1_ell: G1Point,
    g2_r: G2Point,
    g1_o: G1Point,
    g1_ell_prime: G1Point,
    g2_r_prime: G2Point,
    g1_o_prime: G1Point,
    g1_h: G1Point,
}

pub fn setup(g1: &amp;G1Point, g2: &amp;G2Point, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; (ProofKey1, VerificationKey1) {
    let s = FqOrder::random_element(&amp;[]);
    let alpha = FqOrder::random_element(&amp;[]);

    (
        ProofKey1 {
            g1_ell_i_vec: generate_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s),
            g2_r_i_vec: generate_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s),
            g1_o_i_vec: generate_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s),
            g1_alpha_ell_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s, &amp;alpha),
            g2_alpha_r_i_vec: generate_alpha_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s, &amp;alpha),
            g1_alpha_o_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s, &amp;alpha),
            g1_sj_vec: generate_s_powers(g1, &amp;s, qap.m),
        },
        VerificationKey1 {
            g1_alpha: g1 * alpha.get_value(),
            g2_alpha: g2 * alpha.get_value(),
            g2_t_s: g2 * qap.t.eval(&amp;s).sanitize().get_value(),
        },
    )
}

pub fn prove(assignment: &amp;Vec&lt;FqOrder&gt;, proof_key: &amp;ProofKey1, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; Proof1 {
    Proof1 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment),
        g1_h: get_h(qap, assignment).eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
    }
}

pub fn verify(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    proof: &amp;Proof1,
    verification_key: &amp;VerificationKey1,
) -&gt; bool {
    let pairing1 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_alpha);
    let pairing2 = optimal_ate_pairing(&amp;proof.g1_ell_prime, &amp;g2);
    if pairing1 != pairing2 {
        return false;
    }

    let pairing3 = optimal_ate_pairing(&amp;verification_key.g1_alpha, &amp;proof.g2_r);
    let pairing4 = optimal_ate_pairing(&amp;g1, &amp;proof.g2_r_prime);
    if pairing3 != pairing4 {
        return false;
    }

    let pairing5 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_alpha);
    let pairing6 = optimal_ate_pairing(&amp;proof.g1_o_prime, &amp;g2);
    if pairing5 != pairing6 {
        return false;
    }

    let pairing7 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;proof.g2_r);
    let pairing8 = optimal_ate_pairing(&amp;proof.g1_h, &amp;verification_key.g2_t_s);
    let pairing9 = optimal_ate_pairing(&amp;proof.g1_o, &amp;g2);

    pairing7 == pairing8 * pairing9
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn generate_challenge_vec&lt;F1: Field, F2: Field, E: EllipticCurve&gt;(
    point: &amp;EllipticCurvePoint&lt;F1, E&gt;,
    poly_vec: &amp;[Polynomial&lt;F2&gt;],
    s: &amp;F2,
) -&gt; Vec&lt;EllipticCurvePoint&lt;F1, E&gt;&gt; {
    poly_vec
        .iter()
        .map(|poly| point.mul_ref(poly.eval(s).sanitize().get_value()))
        .collect()
}

pub fn generate_alpha_challenge_vec&lt;F1: Field, F2: Field, E: EllipticCurve&gt;(
    point: &amp;EllipticCurvePoint&lt;F1, E&gt;,
    poly_vec: &amp;[Polynomial&lt;F2&gt;],
    s: &amp;F2,
    alpha: &amp;F2,
) -&gt; Vec&lt;EllipticCurvePoint&lt;F1, E&gt;&gt; {
    poly_vec
        .iter()
        .map(|poly| point.mul_ref((alpha.mul_ref(&amp;poly.eval(s).sanitize())).get_value()))
        .collect()
}

pub fn generate_s_powers&lt;F1: Field, F2: Field, E: EllipticCurve&gt;(
    point: &amp;EllipticCurvePoint&lt;F1, E&gt;,
    s: &amp;F2,
    m: usize,
) -&gt; Vec&lt;EllipticCurvePoint&lt;F1, E&gt;&gt; {
    let mut powers = Vec::with_capacity(m + 1);
    let mut current = F2::one();
    for _ in 0..=m {
        powers.push(point.mul_ref(current.get_value()));
        current = current * s.clone();
    }
    powers
}

pub fn accumulate_curve_points&lt;F1: Field, F2: Field, E: EllipticCurve&gt;(
    g_vec: &amp;[EllipticCurvePoint&lt;F1, E&gt;],
    assignment: &amp;[F2],
) -&gt; EllipticCurvePoint&lt;F1, E&gt; {
    g_vec.iter().zip(assignment.iter()).fold(
        EllipticCurvePoint::&lt;F1, E&gt;::point_at_infinity(),
        |acc, (g, &amp;ref a)| acc + g.mul_ref(a.get_value()),
    )
}

pub fn accumulate_polynomials&lt;F: Field&gt;(
    poly_vec: &amp;[Polynomial&lt;F&gt;],
    assignment: &amp;[F],
) -&gt; Polynomial&lt;F&gt; {
    poly_vec
        .iter()
        .zip(assignment.iter())
        .fold(Polynomial::&lt;F&gt;::zero(), |acc, (poly, &amp;ref a)| {
            acc + poly.clone() * a.clone()
        })
}

pub fn get_h&lt;F: Field&gt;(qap: &amp;QAP&lt;F&gt;, assignment: &amp;Vec&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
    let ell = accumulate_polynomials(&amp;qap.ell_i_vec, assignment);
    let r = accumulate_polynomials(&amp;qap.r_i_vec, assignment);
    let o = accumulate_polynomials(&amp;qap.o_i_vec, assignment);
    (ell * r - o) / qap.t.clone()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability</strong></p>
<p>A critical issue with this protocol is that the checks may pass even if \(g^{\ell}\) is computed not from \(\{g^{\ell_i(s)}\}_{i \in [d]}\) but from \(\{g^{r_i(s)}\} _{i \in [d]}\), \(\{g^{o_i(s)}\} _{i \in [d]}\), or their combinations. The same issue applies to \(g^{r}\) and \(g^{o}\).</p>
<p>For example, if the prover sends \((g^{\ell(s)}, g^{\ell(s)}, g^{o(s)}, g^{\alpha r(s)}, g^{\alpha \ell(s)}, g^{\alpha o(s)}, g^{h(s)})\) as the proof, all the verification checks still pass, even although the proved statement differs from the original one.</p>
<h2 id="second-protocol-non-interchangibility"><a class="header" href="#second-protocol-non-interchangibility">Second Protocol: Non-Interchangibility</a></h2>
<p>To address the interchangeability issue, the next protocol uses distinct the different \(\alpha\)-shift for \(\ell\), \(r\), and \(o\).</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), <em>\(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\)</em>.</li>
<li><strong>Proof Key (for the prover):</strong>
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li><em>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</em></li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key (public):</strong>
<ul>
<li>\(g^{t(s)}\) <em>\(, g^{\alpha_{\ell}},g^{\alpha_{r}},g^{\alpha_{o}}\)</em></li>
</ul>
</li>
<li>After distribution, the original secret seeds are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x),\quad r(x) = \sum_{i=1}^{d} v_i r_{i}(x),\quad o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute the quotient polynomial:
<ul>
<li>\(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
</ul>
</li>
<li>Evaluate each polynomial at \(s\).
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v _i} ,\quad g^{r(s)} = \prod^{d} _{i=1} (g^{r_i(s)})^{v_i} ,\quad g^{o(s)} = \prod^{d} _{i=1} (g^{o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\).
<ul>
<li><em>\(g^{\alpha_{\ell} \ell(s)} = \prod^{d}_{i=1} (g^{\alpha _{\ell} \ell_i(s)})^{v_i} \)</em>, <em>\(g^{\alpha_{r} r(s)} = \prod^{d}_{i=1} (g^{\alpha _{r} r_i(s)})^{v_i} \)</em>, <em>\(g^{\alpha_{o} o(s)} = \prod^{d}_{i=1} (g^{\alpha _{o} o_i(s)})^{v_i} \)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><strong>Proof</strong>:
<ul>
<li>\((g^{\ell(s)}, g^{r(s)}, g^{o(s)},\) <em>\(g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)},\)</em> \(g^{h(s)})\)</li>
</ul>
</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h})\)</li>
<li>Check polynomial restrictions
<ul>
<li><em>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g)\)</em>, \(\quad \) <em>\(e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g)\)</em>, \(\quad \) <em>\(e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ProofKey2 {
    g1_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_r_i_vec: Vec&lt;G2Point&gt;,
    g1_o_i_vec: Vec&lt;G1Point&gt;,
    g1_alpha_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_alpha_r_i_vec: Vec&lt;G2Point&gt;,
    g1_alpha_o_i_vec: Vec&lt;G1Point&gt;,
    g1_sj_vec: Vec&lt;G1Point&gt;,
}

#[derive(Debug, Clone)]
pub struct VerificationKey2 {
    g2_alpha_ell: G2Point,
    g1_alpha_r: G1Point,
    g2_alpha_o: G2Point,
    g2_t_s: G2Point,
}

#[derive(Debug, Clone)]
pub struct Proof2 {
    g1_ell: G1Point,
    g2_r: G2Point,
    g1_o: G1Point,
    g1_ell_prime: G1Point,
    g2_r_prime: G2Point,
    g1_o_prime: G1Point,
    g1_h: G1Point,
}

pub fn setup(g1: &amp;G1Point, g2: &amp;G2Point, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; (ProofKey2, VerificationKey2) {
    let s = FqOrder::random_element(&amp;[]);
    let alpha_ell = FqOrder::random_element(&amp;[]);
    let alpha_r = FqOrder::random_element(&amp;[]);
    let alpha_o = FqOrder::random_element(&amp;[]);

    (
        ProofKey2 {
            g1_ell_i_vec: generate_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s),
            g2_r_i_vec: generate_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s),
            g1_o_i_vec: generate_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s),
            g1_alpha_ell_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s, &amp;alpha_ell),
            g2_alpha_r_i_vec: generate_alpha_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s, &amp;alpha_r),
            g1_alpha_o_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s, &amp;alpha_o),
            g1_sj_vec: generate_s_powers(g1, &amp;s, qap.m),
        },
        VerificationKey2 {
            g2_alpha_ell: g2 * alpha_ell.get_value(),
            g1_alpha_r: g1 * alpha_r.get_value(),
            g2_alpha_o: g2 * alpha_o.get_value(),
            g2_t_s: g2 * qap.t.eval(&amp;s).sanitize().get_value(),
        },
    )
}

pub fn prove(assignment: &amp;Vec&lt;FqOrder&gt;, proof_key: &amp;ProofKey2, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; Proof2 {
    Proof2 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment),
        g1_h: get_h(qap, assignment).eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
    }
}

pub fn verify(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    proof: &amp;Proof2,
    verification_key: &amp;VerificationKey2,
) -&gt; bool {
    let pairing1 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_alpha_ell);
    let pairing2 = optimal_ate_pairing(&amp;proof.g1_ell_prime, &amp;g2);
    if pairing1 != pairing2 {
        return false;
    }

    let pairing3 = optimal_ate_pairing(&amp;verification_key.g1_alpha_r, &amp;proof.g2_r);
    let pairing4 = optimal_ate_pairing(&amp;g1, &amp;proof.g2_r_prime);
    if pairing3 != pairing4 {
        return false;
    }

    let pairing5 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_alpha_o);
    let pairing6 = optimal_ate_pairing(&amp;proof.g1_o_prime, &amp;g2);
    if pairing5 != pairing6 {
        return false;
    }

    let pairing7 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;proof.g2_r);
    let pairing8 = optimal_ate_pairing(&amp;proof.g1_h, &amp;verification_key.g2_t_s);
    let pairing9 = optimal_ate_pairing(&amp;proof.g1_o, &amp;g2);

    pairing7 == pairing8 * pairing9
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability</strong></p>
<p>This protocol resolves interchangeability but does not enforce consistency acros \(\ell\), \(r\), and \(o\). Variables \(v_i\) can still take different values in each polynoimal because verification checks are performed separately.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn inconsistent_variable_attack(
    assignment_ell: &amp;Vec&lt;FqOrder&gt;,
    assignment_r: &amp;Vec&lt;FqOrder&gt;,
    assignment_o: &amp;Vec&lt;FqOrder&gt;,
    proof_key: &amp;ProofKey2,
    qap: &amp;QAP&lt;FqOrder&gt;,
) -&gt; Proof2 {
    let ell = accumulate_polynomials(&amp;qap.ell_i_vec, assignment_ell);
    let r = accumulate_polynomials(&amp;qap.r_i_vec, assignment_r);
    let o = accumulate_polynomials(&amp;qap.o_i_vec, assignment_o);
    let h = (ell * r - o) / qap.t.clone();

    Proof2 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment_ell),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment_r),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment_o),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment_ell),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment_r),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment_o),
        g1_h: h.eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="thrid-protocol-variable-consistency"><a class="header" href="#thrid-protocol-variable-consistency">Thrid Protocol: Variable Consistency</a></h2>
<p>To achive the variable consistency, we employ a checksum mechanism. Specifically, we first draw a new random value \(\beta\) and define the checksum of \(v_i\) as \(g^{\beta(\ell_{i}(s) + r_i(s) + o_i(s))}\). Let \(v _{\ell, i}\), \(v _{r,i}\), \(v _{o,i}\), and \(v _{\beta,i}\) denote the \(i\)-th value of the assignment vectors for \(\ell\), \(r\), \(o\) and the checksum, respectively. If all of them are the same, the following equation holds:</p>
<p>\[
e(g^{v _{\ell, i} \ell_i(s)} g^{v _{r, i} r_i(s)} g^{v _{o, i} o_i(s)}, g^{\beta}) = e(g^{v _{\beta, i} \beta(\ell _{i}(s) + r _{i}(s) + o _{i}(s))}, g)
\]</p>
<p>Unfortunately, this condition is not strictly equivalent. For example, consider the case where \(\ell_i(x) = r_i(x)\). In this scenario, we have:</p>
<p>\begin{align*}
&amp;\beta(v _{\ell, i} \ell_i(s) + v _{r, i} r_i(s) + v _{o, i} o_i(s)) = v _{\beta, i} \beta (\ell _{i}(s) + r _{i}(s) + o _{i}(s)) \\
\iff &amp;\beta(v _{\ell, i} \ell_i(s) + v _{r, i} \ell_i(s) + v _{o, i} o_i(s)) = v _{\beta, i} \beta (2\ell _{i}(s) + o _{i}(s))
\end{align*}</p>
<p>This equation holds for arbitrary \(v _{r,i}\) and \(v _{o,i}\) if we set \(v _{\beta, i} = v _{o, i}\) and \(v _{\ell, i} = 2 v _{o, i} - v _{r, i}\).</p>
<p>To address this issue, we use distinct different \(\beta\) values for \(\ell\), \(r\) and \(o\). The consistency check then verifies the following equation:</p>
<p>\[
e(g^{v _{\ell, i} \ell _{i}(s)}, g^{\beta _{\ell}}) \cdot e(g^{v _{r, i} r _{i}(s)}, g^{\beta _{r}}) \cdot e(g^{v _{o, i} o _{i}(s)}, g^{\beta _{o}}) = e(g^{v _{\beta, i}(\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s))}, g)<br />
\]</p>
<p>The new protocol using the above variable-consistency check is as follows:</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), <em>\(\beta_{\ell}\), \(\beta_{r}\), and \(\beta_{o}\)</em>.</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><em>\(\{g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)}\} _{i \in [d]}\)</em></li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}, g^{\alpha_{\ell}},g^{\alpha_{r}},g^{\alpha_{o}}\) <em>\(, g^{\beta_{\ell}}, g^{\beta_{r}}, g^{\beta_{o}}\)</em></li>
</ul>
</li>
<li>After distribution, the original secret seeds are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x),\quad r(x) = \sum_{i=1}^{d} v_i r_{i}(x),\quad o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute the quotient polynomial:
<ul>
<li>\(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
</ul>
</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v _i} ,\quad g^{r(s)} = \prod^{d} _{i=1} (g^{r_i(s)})^{v_i} ,\quad g^{o(s)} = \prod^{d} _{i=1} (g^{o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha _{\ell} \ell(s)} = \prod^{d} _{i=1} (g^{\alpha _{\ell} \ell _i(s)})^{v _i} ,g^{\alpha _{r} r(s)} = \prod^{d} _{i=1} (g^{\alpha _{r} r _i(s)})^{v _i} ,g^{\alpha _{o} o(s)} = \prod^{d} _{i=1} (g^{\alpha _{o} o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li><em>Evaluate each consistency polynomial at \(s\):</em>
<ul>
<li><em>\(g^{z(s)} = \prod^{d}_{i=1} (g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)})^{v _{i}}\)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><strong>Proof</strong>:
<ul>
<li>\((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) <em>\(g^{z(s)}\)</em> \()\)</li>
</ul>
</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g),\quad e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g),\quad e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g^{\ell}, g^{\beta _{\ell}}) \cdot e(g^{r}, g^{\beta _{r}}) \cdot e(g^{o}, g^{\beta _{o}}) = e(g^{z}, g)\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ProofKey3 {
    g1_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_r_i_vec: Vec&lt;G2Point&gt;,
    g1_o_i_vec: Vec&lt;G1Point&gt;,
    g1_alpha_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_alpha_r_i_vec: Vec&lt;G2Point&gt;,
    g1_alpha_o_i_vec: Vec&lt;G1Point&gt;,
    g1_sj_vec: Vec&lt;G1Point&gt;,
    g1_checksum_vec: Vec&lt;G1Point&gt;,
}

#[derive(Debug, Clone)]
pub struct VerificationKey3 {
    g2_alpha_ell: G2Point,
    g1_alpha_r: G1Point,
    g2_alpha_o: G2Point,
    g2_beta_ell: G2Point,
    g1_beta_r: G1Point,
    g2_beta_o: G2Point,
    g2_t_s: G2Point,
}

#[derive(Debug, Clone)]
pub struct Proof3 {
    g1_ell: G1Point,
    g2_r: G2Point,
    g1_o: G1Point,
    g1_ell_prime: G1Point,
    g2_r_prime: G2Point,
    g1_o_prime: G1Point,
    g1_h: G1Point,
    g1_z: G1Point,
}

pub fn setup(g1: &amp;G1Point, g2: &amp;G2Point, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; (ProofKey3, VerificationKey3) {
    let s = FqOrder::random_element(&amp;[]);
    let alpha_ell = FqOrder::random_element(&amp;[]);
    let alpha_r = FqOrder::random_element(&amp;[]);
    let alpha_o = FqOrder::random_element(&amp;[]);
    let beta_ell = FqOrder::random_element(&amp;[]);
    let beta_r = FqOrder::random_element(&amp;[]);
    let beta_o = FqOrder::random_element(&amp;[]);

    let mut g1_checksum_vec = Vec::with_capacity(qap.d);

    for i in 0..qap.d {
        let ell_i_s = qap.ell_i_vec[i].eval(&amp;s).sanitize();
        let r_i_s = qap.r_i_vec[i].eval(&amp;s).sanitize();
        let o_i_s = qap.o_i_vec[i].eval(&amp;s).sanitize();
        g1_checksum_vec.push(
            g1.mul_ref(
                ((beta_ell.mul_ref(&amp;ell_i_s))
                    .add_ref(&amp;beta_r.mul_ref(&amp;r_i_s))
                    .add_ref(&amp;beta_o.mul_ref(&amp;o_i_s)))
                .get_value(),
            ),
        );
    }

    (
        ProofKey3 {
            g1_ell_i_vec: generate_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s),
            g2_r_i_vec: generate_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s),
            g1_o_i_vec: generate_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s),
            g1_alpha_ell_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s, &amp;alpha_ell),
            g2_alpha_r_i_vec: generate_alpha_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s, &amp;alpha_r),
            g1_alpha_o_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s, &amp;alpha_o),
            g1_sj_vec: generate_s_powers(g1, &amp;s, qap.m),
            g1_checksum_vec: g1_checksum_vec,
        },
        VerificationKey3 {
            g2_alpha_ell: g2 * alpha_ell.get_value(),
            g1_alpha_r: g1 * alpha_r.get_value(),
            g2_alpha_o: g2 * alpha_o.get_value(),
            g2_beta_ell: g2 * beta_ell.get_value(),
            g1_beta_r: g1 * beta_r.get_value(),
            g2_beta_o: g2 * beta_o.get_value(),
            g2_t_s: g2 * qap.t.eval(&amp;s).sanitize().get_value(),
        },
    )
}

pub fn prove(assignment: &amp;Vec&lt;FqOrder&gt;, proof_key: &amp;ProofKey3, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; Proof3 {
    Proof3 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment),
        g1_h: get_h(qap, assignment).eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
        g1_z: accumulate_curve_points(&amp;proof_key.g1_checksum_vec, assignment),
    }
}

pub fn verify(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    proof: &amp;Proof3,
    verification_key: &amp;VerificationKey3,
) -&gt; bool {
    let pairing1 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_alpha_ell);
    let pairing2 = optimal_ate_pairing(&amp;proof.g1_ell_prime, &amp;g2);
    if pairing1 != pairing2 {
        return false;
    }

    let pairing3 = optimal_ate_pairing(&amp;verification_key.g1_alpha_r, &amp;proof.g2_r);
    let pairing4 = optimal_ate_pairing(&amp;g1, &amp;proof.g2_r_prime);
    if pairing3 != pairing4 {
        return false;
    }

    let pairing5 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_alpha_o);
    let pairing6 = optimal_ate_pairing(&amp;proof.g1_o_prime, &amp;g2);
    if pairing5 != pairing6 {
        return false;
    }

    let pairing7 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;proof.g2_r);
    let pairing8 = optimal_ate_pairing(&amp;proof.g1_h, &amp;verification_key.g2_t_s);
    let pairing9 = optimal_ate_pairing(&amp;proof.g1_o, &amp;g2);

    if pairing7 != pairing8 * pairing9 {
        return false;
    }

    let pairing10 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_beta_ell);
    let pairing11 = optimal_ate_pairing(&amp;verification_key.g1_beta_r, &amp;proof.g2_r);
    let pairing12 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_beta_o);
    let pairing13 = optimal_ate_pairing(&amp;proof.g1_z, &amp;g2);

    pairing10 * pairing11 * pairing12 == pairing13
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability</strong></p>
<p>Despite these checks, the protocol is vulnerable to <strong>malleability</strong>. Specifically, a malicious prover can exploit the polynomial restriction check to introduce arbitrary constants, altering the proof witout detection.</p>
<p>Recall that the verifier validates whether the submitted \(g^{\ell}\) is actually calculated by \(\{g^{\ell _i(s)}\} _{i \in [d]}\) by checking \(e(g^{\ell}, g^{\alpha _{\ell}}) = e(g^{\ell'}, g)\). However, this process is not sound. Recall that the verification key is publicaly available, and the prover knows both of \(g^{\alpha _{\ell}}\) and \(g^{\beta _{\ell}}\). Here, suppose the prover submits \(g^{\ell} g^{c}\) and \(g^{\ell'} (g^{\alpha _{\ell}})^{c}\) insteads of \(g^{\ell}\) and \(g^{\ell'}\), where \(c\) is a constatn value. Then, the polynomial restriction check still passes:</p>
<p>\[
e(g^{\ell} g^{c}, g^{\alpha _{\ell}}) = e(g^{\alpha _{\ell} \ell + \alpha _{\ell} c}, g) = e(g^{\ell'}g^{\alpha _{\ell}c}, g) = e(g^{\ell'} (g^{\alpha _{\ell}})^{c}, g)
\]</p>
<p>In addition, if the prover submits \(g^{z} (g^{\beta _{\ell}})^{c}\) as the checksum, it also passes the polynomial checksum verification:</p>
<p>\[
e(g^{\ell} g^{c}, g^{\beta _{\ell}}) \cdot e(g^{r}, g^{\beta _{r}}) \cdot e(g^{o}, g^{\beta _{o}}) = e(g^{z} (g^{\beta _{\ell}})^{c}, g)
\]</p>
<p>This phenomenon also can occur for \(r\) and \(o\).</p>
<h2 id="forth-protocol-non-malleability"><a class="header" href="#forth-protocol-non-malleability">Forth Protocol: Non-Malleability</a></h2>
<p>One way to surrogate the above malleability is hiding \(g^{\beta _{\ell}}\), \(g^{\beta _{r}}\), and \(g^{\beta _{o}}\) by powering them with a new random value \(\eta\).</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), \(\beta_{\ell}\), \(\beta_{r}\), \(\beta_{o}\), and <em>\(\eta\)</em>.</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>\(\{g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)}\} _{i \in [d]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}, g^{\alpha_{\ell}},g^{\alpha_{r}},g^{\alpha_{o}}\) <em>\(,g^{\eta}, g^{\beta_{\ell} \eta}, g^{\beta_{r} \eta}, g^{\beta_{o} \eta}\)</em></li>
</ul>
</li>
<li>After distribution, the original secret seeds are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x),\quad r(x) = \sum_{i=1}^{d} v_i r_{i}(x),\quad o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute the quotient polynomial:
<ul>
<li>\(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
</ul>
</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v _i} ,\quad g^{r(s)} = \prod^{d} _{i=1} (g^{r_i(s)})^{v_i} ,\quad g^{o(s)} = \prod^{d} _{i=1} (g^{o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha _{\ell} \ell(s)} = \prod^{d} _{i=1} (g^{\alpha _{\ell} \ell _i(s)})^{v _i} ,g^{\alpha _{r} r(s)} = \prod^{d} _{i=1} (g^{\alpha _{r} r _i(s)})^{v _i} ,g^{\alpha _{o} o(s)} = \prod^{d} _{i=1} (g^{\alpha _{o} o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each consistency polynomial at \(s\):
<ul>
<li>\(g^{z(s)} = \prod^{d}_{i=1} (g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)})^{v _{i}}\)</li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><strong>Proof</strong>:
<ul>
<li>\((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) \(g^{z(s)}\) \()\)</li>
</ul>
</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g),\quad e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g),\quad e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g^{\ell}, g^{\beta _{\ell} \eta}) \cdot e(g^{r}, g^{\beta _{r} \eta}) \cdot e(g^{o}, g^{\beta _{o} \eta}) = e(g^{z}, g^{\eta})\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ProofKey4 {
    g1_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_r_i_vec: Vec&lt;G2Point&gt;,
    g1_o_i_vec: Vec&lt;G1Point&gt;,
    g1_alpha_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_alpha_r_i_vec: Vec&lt;G2Point&gt;,
    g1_alpha_o_i_vec: Vec&lt;G1Point&gt;,
    g1_sj_vec: Vec&lt;G1Point&gt;,
    g1_checksum_vec: Vec&lt;G1Point&gt;,
}

#[derive(Debug, Clone)]
pub struct VerificationKey4 {
    g2_alpha_ell: G2Point,
    g1_alpha_r: G1Point,
    g2_alpha_o: G2Point,
    g2_beta_ell_eta: G2Point,
    g1_beta_r_eta: G1Point,
    g2_beta_o_eta: G2Point,
    g2_t_s: G2Point,
    g2_eta: G2Point,
}

#[derive(Debug, Clone)]
pub struct Proof4 {
    g1_ell: G1Point,
    g2_r: G2Point,
    g1_o: G1Point,
    g1_ell_prime: G1Point,
    g2_r_prime: G2Point,
    g1_o_prime: G1Point,
    g1_h: G1Point,
    g1_z: G1Point,
}

pub fn setup(g1: &amp;G1Point, g2: &amp;G2Point, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; (ProofKey4, VerificationKey4) {
    let s = FqOrder::random_element(&amp;[]);
    let alpha_ell = FqOrder::random_element(&amp;[]);
    let alpha_r = FqOrder::random_element(&amp;[]);
    let alpha_o = FqOrder::random_element(&amp;[]);
    let beta_ell = FqOrder::random_element(&amp;[]);
    let beta_r = FqOrder::random_element(&amp;[]);
    let beta_o = FqOrder::random_element(&amp;[]);
    let eta = FqOrder::random_element(&amp;[]);

    let mut g1_checksum_vec = Vec::with_capacity(qap.d);

    for i in 0..qap.d {
        let ell_i_s = qap.ell_i_vec[i].eval(&amp;s).sanitize();
        let r_i_s = qap.r_i_vec[i].eval(&amp;s).sanitize();
        let o_i_s = qap.o_i_vec[i].eval(&amp;s).sanitize();
        g1_checksum_vec.push(
            g1.mul_ref(
                ((beta_ell.mul_ref(&amp;ell_i_s))
                    .add_ref(&amp;beta_r.mul_ref(&amp;r_i_s))
                    .add_ref(&amp;beta_o.mul_ref(&amp;o_i_s)))
                .get_value(),
            ),
        );
    }

    (
        ProofKey4 {
            g1_ell_i_vec: generate_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s),
            g2_r_i_vec: generate_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s),
            g1_o_i_vec: generate_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s),
            g1_alpha_ell_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.ell_i_vec, &amp;s, &amp;alpha_ell),
            g2_alpha_r_i_vec: generate_alpha_challenge_vec(g2, &amp;qap.r_i_vec, &amp;s, &amp;alpha_r),
            g1_alpha_o_i_vec: generate_alpha_challenge_vec(g1, &amp;qap.o_i_vec, &amp;s, &amp;alpha_o),
            g1_sj_vec: generate_s_powers(g1, &amp;s, qap.m),
            g1_checksum_vec: g1_checksum_vec,
        },
        VerificationKey4 {
            g2_alpha_ell: g2 * alpha_ell.get_value(),
            g1_alpha_r: g1 * alpha_r.get_value(),
            g2_alpha_o: g2 * alpha_o.get_value(),
            g2_beta_ell_eta: (g2 * beta_ell.get_value()) * eta.get_value(),
            g1_beta_r_eta: (g1 * beta_r.get_value()) * eta.get_value(),
            g2_beta_o_eta: (g2 * beta_o.get_value()) * eta.get_value(),
            g2_t_s: g2 * qap.t.eval(&amp;s).sanitize().get_value(),
            g2_eta: g2 * eta.get_value(),
        },
    )
}

pub fn prove(assignment: &amp;Vec&lt;FqOrder&gt;, proof_key: &amp;ProofKey4, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; Proof4 {
    Proof4 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment),
        g1_h: get_h(qap, assignment).eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
        g1_z: accumulate_curve_points(&amp;proof_key.g1_checksum_vec, assignment),
    }
}

pub fn verify(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    proof: &amp;Proof4,
    verification_key: &amp;VerificationKey4,
) -&gt; bool {
    let pairing1 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_alpha_ell);
    let pairing2 = optimal_ate_pairing(&amp;proof.g1_ell_prime, &amp;g2);
    if pairing1 != pairing2 {
        return false;
    }

    let pairing3 = optimal_ate_pairing(&amp;verification_key.g1_alpha_r, &amp;proof.g2_r);
    let pairing4 = optimal_ate_pairing(&amp;g1, &amp;proof.g2_r_prime);
    if pairing3 != pairing4 {
        return false;
    }

    let pairing5 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_alpha_o);
    let pairing6 = optimal_ate_pairing(&amp;proof.g1_o_prime, &amp;g2);
    if pairing5 != pairing6 {
        return false;
    }

    let pairing7 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;proof.g2_r);
    let pairing8 = optimal_ate_pairing(&amp;proof.g1_h, &amp;verification_key.g2_t_s);
    let pairing9 = optimal_ate_pairing(&amp;proof.g1_o, &amp;g2);

    if pairing7 != pairing8 * pairing9 {
        return false;
    }

    let pairing10 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_beta_ell_eta);
    let pairing11 = optimal_ate_pairing(&amp;verification_key.g1_beta_r_eta, &amp;proof.g2_r);
    let pairing12 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_beta_o_eta);
    let pairing13 = optimal_ate_pairing(&amp;proof.g1_z, &amp;verification_key.g2_eta);

    pairing10 * pairing11 * pairing12 == pairing13
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fifth-protocol-pinocchio"><a class="header" href="#fifth-protocol-pinocchio">Fifth Protocol: Pinocchio</a></h2>
<p>The above protocol requires 13 expensive pairing operations. To make it faster, Pinocchio protocl randomizes the generators.</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), \(\beta\), \(\eta\), <em>\(\rho _{\ell}\), and \(\rho _{r}\), and set \(\rho _{o} = \rho _{\ell} \rho _{r}\)</em>.</li>
<li><strong>Randized Generators:</strong> <em>\(g _{\ell} = g^{\rho _{\ell}}\), \(g _{r} = g^{\rho _{r}}\), and \(g _{o} = g^{\rho _{o}}\)</em></li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li><em>\(\{g_{\ell}^{\ell_i(s)},g_{r}^{r_i(s)},g_{o}^{o_i(s)}\}_{i\in[d]}\)</em></li>
<li><em>\(\{g_{\ell}^{\alpha_{\ell} \ell_i(s)},g_{r}^{\alpha_{r} r_i(s)},g_{o}^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</em></li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><em>\(\{g _{\ell}^{\beta \ell _{i}(s)} \cdot g _{r}^{\beta r _{i}(s)} \cdot g _{o}^{\beta o _{i}(s)}\} _{i \in [d]}\)</em></li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li><em>\(g _{o}^{t(s)}\)</em> \(, g^{\alpha _{\ell}}, g^{\alpha _{r}}, g^{\alpha _{o}}, g^{\eta}\) <em>\(,g^{\beta \eta}\)</em></li>
</ul>
</li>
<li>After distribution, the original secret seeds are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x),\quad r(x) = \sum_{i=1}^{d} v_i r_{i}(x),\quad o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute the quotient polynomial:
<ul>
<li>\(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
</ul>
</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g _{\ell}^{\ell_i(s)})^{v _i} ,\quad g^{r(s)} = \prod^{d} _{i=1} (g _{r}^{r_i(s)})^{v_i} ,\quad g^{o(s)} = \prod^{d} _{i=1} (g _{o}^{o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha _{\ell} \ell(s)} = \prod^{d} _{i=1} (g _{\ell}^{\alpha _{\ell} \ell _i(s)})^{v _i} ,g^{\alpha _{r} r(s)} = \prod^{d} _{i=1} (g _{r}^{\alpha _{r} r _i(s)})^{v _i} ,g^{\alpha _{o} o(s)} = \prod^{d} _{i=1} (g _{o}^{\alpha _{o} o _i(s)})^{v _i} \)</li>
</ul>
</li>
<li>Evaluate each consistency polynomial at \(s\):
<ul>
<li><em>\(g^{z(s)} = \prod^{d}_{i=1} (g _{\ell}^{\beta \ell _{i}(s)} \cdot g _{r}^{\beta r _{i}(s)} \cdot g _{o}^{\beta o _{i}(s)})^{v _{i}}\)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li><strong>Proof</strong>:
<ul>
<li>\((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) \(g^{z(s)}\) \()\)</li>
</ul>
</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g _{\ell}^{\ell}, g _{r}^r, g _{o}^o, g _{\ell}^{\ell'}, g _{r}^{r'}, g _{o}^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li><em>\(e(g _{\ell}^{\ell}, g^{\alpha _{\ell}}) = e(g _{\ell}^{\ell'}, g)\)</em>, <em>\(e(g _{r}^{r}, g^{\alpha _{r}}) = e(g _{r}^{r'}, g)\)</em>, <em>\(e(g _{o}^{o}, g^{\alpha _{o}}) = e(g _{o}^{o'}, g)\)</em></li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g _{\ell}^{\ell} \cdot g _{r}^{r} \cdot g _{o}^{o}, g^{\beta \eta}) = e(g^{z}, g^{\eta})\)</em></li>
<li>(Alternative for the asymmetric pairing: <em>\(e(g _{\ell}^{\ell} \cdot g _{o}^{o}, g^{\beta \eta}) \cdot e(g^{\beta \eta}, g _{r}^{r}) = e(g^{z}, g^{\eta})\)</em>)</li>
</ul>
</li>
<li>Validity check
<ul>
<li><em>\(e(g _{\ell}^{\ell}, g _{r}^{r}) = e(g _{o}^t,g^h) \cdot e(g _{o}^o, g)\)</em></li>
</ul>
</li>
</ul>
<p>This protocol reduces two pairing operations when using symmetric pairings. However, with asymmetric pairings, one additional pairing is required because \(g _{r}^{r}\) is derived from the generator of the second group, \(\mathscr{g} _2\), while \(g _{\ell}^{\ell}\) annd \(g _{o}^{o}\) are derived from the generator of the first group, \(\mathscr{g} _1\).</p>
<p><strong>Implementation</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ProofKey5 {
    g1_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_r_i_vec: Vec&lt;G2Point&gt;,
    g1_o_i_vec: Vec&lt;G1Point&gt;,
    g1_alpha_ell_i_vec: Vec&lt;G1Point&gt;,
    g2_alpha_r_i_vec: Vec&lt;G2Point&gt;,
    g1_alpha_o_i_vec: Vec&lt;G1Point&gt;,
    g1_sj_vec: Vec&lt;G1Point&gt;,
    g1_checksum_vec: Vec&lt;G1Point&gt;,
}

#[derive(Debug, Clone)]
pub struct VerificationKey5 {
    g2_alpha_ell: G2Point,
    g1_alpha_r: G1Point,
    g2_alpha_o: G2Point,
    g1_beta_eta: G1Point,
    g2_beta_eta: G2Point,
    g2_t_s: G2Point,
    g2_eta: G2Point,
}

#[derive(Debug, Clone)]
pub struct Proof5 {
    g1_ell: G1Point,
    g2_r: G2Point,
    g1_o: G1Point,
    g1_ell_prime: G1Point,
    g2_r_prime: G2Point,
    g1_o_prime: G1Point,
    g1_h: G1Point,
    g1_z: G1Point,
}

pub fn setup(g1: &amp;G1Point, g2: &amp;G2Point, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; (ProofKey5, VerificationKey5) {
    let s = FqOrder::random_element(&amp;[]);
    let alpha_ell = FqOrder::random_element(&amp;[]);
    let alpha_r = FqOrder::random_element(&amp;[]);
    let alpha_o = FqOrder::random_element(&amp;[]);
    let beta = FqOrder::random_element(&amp;[]);
    let eta = FqOrder::random_element(&amp;[]);
    let rho_ell = FqOrder::random_element(&amp;[]);
    let rho_r = FqOrder::random_element(&amp;[]);
    let rho_o = rho_ell.mul_ref(&amp;rho_r);

    let g1_ell = g1 * rho_ell.get_value();
    let g1_r = g1 * rho_r.get_value();
    let g2_r = g2 * rho_r.get_value();
    let g1_o = g1 * rho_o.get_value();
    let g2_o = g2 * rho_o.get_value();

    let mut g1_checksum_vec = Vec::with_capacity(qap.d);

    for i in 0..qap.d {
        let ell_i_s = qap.ell_i_vec[i].eval(&amp;s).sanitize();
        let r_i_s = qap.r_i_vec[i].eval(&amp;s).sanitize();
        let o_i_s = qap.o_i_vec[i].eval(&amp;s).sanitize();
        g1_checksum_vec.push(
            &amp;g1_ell * beta.mul_ref(&amp;ell_i_s).get_value()
                + &amp;g1_r * beta.mul_ref(&amp;r_i_s).get_value()
                + &amp;g1_o * beta.mul_ref(&amp;o_i_s).get_value(),
        );
    }

    (
        ProofKey5 {
            g1_ell_i_vec: generate_challenge_vec(&amp;g1_ell, &amp;qap.ell_i_vec, &amp;s),
            g2_r_i_vec: generate_challenge_vec(&amp;g2_r, &amp;qap.r_i_vec, &amp;s),
            g1_o_i_vec: generate_challenge_vec(&amp;g1_o, &amp;qap.o_i_vec, &amp;s),
            g1_alpha_ell_i_vec: generate_alpha_challenge_vec(
                &amp;g1_ell,
                &amp;qap.ell_i_vec,
                &amp;s,
                &amp;alpha_ell,
            ),
            g2_alpha_r_i_vec: generate_alpha_challenge_vec(&amp;g2_r, &amp;qap.r_i_vec, &amp;s, &amp;alpha_r),
            g1_alpha_o_i_vec: generate_alpha_challenge_vec(&amp;g1_o, &amp;qap.o_i_vec, &amp;s, &amp;alpha_o),
            g1_sj_vec: generate_s_powers(&amp;g1, &amp;s, qap.m),
            g1_checksum_vec: g1_checksum_vec,
        },
        VerificationKey5 {
            g2_alpha_ell: g2 * alpha_ell.get_value(),
            g1_alpha_r: g1 * alpha_r.get_value(),
            g2_alpha_o: g2 * alpha_o.get_value(),
            g1_beta_eta: g1 * beta.get_value() * eta.get_value(),
            g2_beta_eta: g2 * beta.get_value() * eta.get_value(),
            g2_t_s: g2_o * qap.t.eval(&amp;s).sanitize().get_value(),
            g2_eta: g2 * eta.get_value(),
        },
    )
}

pub fn prove(assignment: &amp;Vec&lt;FqOrder&gt;, proof_key: &amp;ProofKey5, qap: &amp;QAP&lt;FqOrder&gt;) -&gt; Proof5 {
    Proof5 {
        g1_ell: accumulate_curve_points(&amp;proof_key.g1_ell_i_vec, assignment),
        g2_r: accumulate_curve_points(&amp;proof_key.g2_r_i_vec, assignment),
        g1_o: accumulate_curve_points(&amp;proof_key.g1_o_i_vec, assignment),
        g1_ell_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_ell_i_vec, assignment),
        g2_r_prime: accumulate_curve_points(&amp;proof_key.g2_alpha_r_i_vec, assignment),
        g1_o_prime: accumulate_curve_points(&amp;proof_key.g1_alpha_o_i_vec, assignment),
        g1_h: get_h(qap, assignment).eval_with_powers_on_curve(&amp;proof_key.g1_sj_vec),
        g1_z: accumulate_curve_points(&amp;proof_key.g1_checksum_vec, assignment),
    }
}

pub fn verify(
    g1: &amp;G1Point,
    g2: &amp;G2Point,
    proof: &amp;Proof5,
    verification_key: &amp;VerificationKey5,
) -&gt; bool {
    let pairing1 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;verification_key.g2_alpha_ell);
    let pairing2 = optimal_ate_pairing(&amp;proof.g1_ell_prime, &amp;g2);
    if pairing1 != pairing2 {
        return false;
    }

    let pairing3 = optimal_ate_pairing(&amp;verification_key.g1_alpha_r, &amp;proof.g2_r);
    let pairing4 = optimal_ate_pairing(&amp;g1, &amp;proof.g2_r_prime);
    if pairing3 != pairing4 {
        return false;
    }

    let pairing5 = optimal_ate_pairing(&amp;proof.g1_o, &amp;verification_key.g2_alpha_o);
    let pairing6 = optimal_ate_pairing(&amp;proof.g1_o_prime, &amp;g2);
    if pairing5 != pairing6 {
        return false;
    }

    let pairing7 = optimal_ate_pairing(&amp;proof.g1_ell, &amp;proof.g2_r);
    let pairing8 = optimal_ate_pairing(&amp;proof.g1_h, &amp;verification_key.g2_t_s);
    let pairing9 = optimal_ate_pairing(&amp;proof.g1_o, &amp;g2);

    if pairing7 != pairing8 * pairing9 {
        return false;
    }

    let pairing10 = optimal_ate_pairing(
        &amp;proof.g1_ell.add_ref(&amp;proof.g1_o),
        &amp;verification_key.g2_beta_eta,
    );
    let pairing11 = optimal_ate_pairing(&amp;verification_key.g1_beta_eta, &amp;proof.g2_r);
    let pairing12 = optimal_ate_pairing(&amp;proof.g1_z, &amp;verification_key.g2_eta);

    pairing10 * pairing11 == pairing12
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-zk-stark"><a class="header" href="#basics-of-zk-stark">Basics of zk-STARK</a></h1>
<p>zk-Stark stands for <strong>S</strong>calable <strong>T</strong>ransparent <strong>AR</strong>gument of <strong>K</strong>nowledge. Its key properties are:</p>
<ul>
<li><strong>Scalability</strong>: Prover time grows as \(\mathcal{O}(T\log{T})\) and verifier time as \(\mathcal{O}(\log{T})\), where \(T\) is the cost of executing the statement being proven.</li>
<li><strong>Transparency</strong>: Unlike many SNARK systems, zk‚ÄëSTARKs require no trusted setup.</li>
<li><strong>Post‚ÄëQuantum Security</strong>: Security depends solely on the collision and preimage resistance of cryptographic hash functions, making zk‚ÄëSTARKs resilient against quantum‚Äëcomputing attacks.</li>
</ul>
<p>In this tutorial, we will unpack and implement the fundamental building blocks of zk‚ÄëSTARKs. Our presentation draws heavily on the <a href="https://aszepieniec.github.io/stark-anatomy/">Anatomy of a STARK</a> guide by Alan Szepieniec and the <a href="https://starkware.co/stark-101/">STARK 101</a> series from StarkWare.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>The Fast Reed-Solomon IOP of Proximity (FRI) is a powerful interactive proof system that allows a verifier to efficiently check if a claimed polynomial has a degree bounded by some value \(d\), without the prover needing to reveal the entire polynomial.</p>
<h2 id="core-concept"><a class="header" href="#core-concept">Core Concept</a></h2>
<p>At its heart, FRI employs a clever divide-and-conquer strategy. The prover commits to the evaluation of the polynomial over a large domain. The protocol then iteratively "folds" the polynomial into a new polynomial of roughly half the degree. This process continues until the degree is so small that the verifier can directly check the degree bound by querying the remaining evaluations. The logarithmic communication complexity, scaling as \(\mathcal{O}(\log{d})\), arises from this halving of the degree in each round.</p>
<h2 id="mathematical-foundation"><a class="header" href="#mathematical-foundation">Mathematical Foundation</a></h2>
<p>Consider a polynomial \(f(X) = \sum^{d}_{i=0} c_i X^{i}\), where \(d\) is the maximum degree. This polynomial can be divided into two parts:</p>
<p>\[f(X) = f_E(X^2) + X \cdot f_O(X^2)\]</p>
<p>, where</p>
<ul>
<li>\(f_E(X^2) = \frac{f(X) + f(-X)}{2} = \sum_{i=0}^{\frac{d + 1}{2} - 1} c_{2i} X^{2i} \)</li>
<li>\(f_O(X^2) = \frac{f(X) - f(-X)}{2X} = \sum_{i=0}^{\frac{d + 1}{2} - 1} c_{2i + 1} X^{2i} \)</li>
</ul>
<p>The crucial step in FRI is the prover's construction of a new "folded" polynomial with respect to \(Y = X^2\):</p>
<p>\[f^{*}(Y) = f_{E}(Y) + \alpha \cdot f_{O}(Y)\]</p>
<p>Here, \(\alpha\) is a random value provided by the verifier. Notice that while \(f(X)\) has degree \(d\), <strong>the new polynomial \(f^{*}(Y)\) has degree approximately \(\frac{d}{2}\)</strong>. This degree reduction is the engine of FRI's efficiency.</p>
<p>Let \(D \subset \mathbb{F}_{p} \) be a multiplicative subgroup of even order \(N\), and let \(\omega\) be a generator of \(D\). The prover commits to the evaluations of \(f(x)\) at all elements of \(D\), i.e., the codewords \(\{f(\omega^{i})\}_{i=0}^{N - 1}\).</p>
<p>For any \(i \in {0, 1, \dots \frac{N}{2}-1}\), we have the following relationship:</p>
<p>\begin{align*}
f^{*}(w^{2i}) &amp;= \frac{f(\omega^{i}) + f(- \omega^{i})}{2} + \alpha \cdot \frac{f(\omega^{i}) - f(- \omega^{i})}{2\omega^{i}} \\
&amp;= \frac{1}{2} \{(1 + \alpha \omega^{-i}) \cdot f(\omega^{i}) + (1 - \alpha \omega^{-i}) \cdot f(- \omega^{i})\}
\end{align*}</p>
<p>Since \(\omega\) has order \(N\), we have that \(\omega^{\frac{N}{2}} = -1\) and \(f(- \omega^{i}) = f(\omega^{\frac{N}{2} + i})\). Thus, we can rewrite the above as</p>
<p>\[f^{*}(\omega^{2i}) = \frac{1}{2} \left( (1 + \alpha \omega^{-i}) \cdot f(\omega^{i}) + (1 - \alpha \omega^{-i}) \cdot f(\omega^{\frac{N}{2} + i}) \right)\]</p>
<p>In addition, consider the following three points:</p>
<ul>
<li>A: \((\omega^{i}, f(\omega^{i}))\)</li>
<li>B: \((\omega^{\frac{N}{2} + i}, f(\omega^{\frac{N}{2} + i}))\)</li>
<li>C: \((\alpha, f^{*}(\omega^{2i}))\)</li>
</ul>
<p><strong>These three points lie on a straight line if and only if \(f^{*}(\omega^{2i})\) is correctly computed</strong> from \(f(\omega^{i})\) and \(f(\omega^{\frac{N}{2} + i})\). We can see it by applying the Lagrance interpolation for A and B:</p>
<p>\begin{align*}
y &amp;= f(\omega^{i}) \cdot \frac{x - \omega^{\frac{N}{2} + i}}{\omega^{i} - \omega^{\frac{N}{2} + i}} + f(\omega^{\frac{N}{2} + i}) \cdot \frac{x - \omega^{i}}{\omega^{\frac{N}{2} + i} - \omega^{i}} \\
&amp;= f(\omega^{i}) \cdot \frac{x + \omega^{i}}{\omega^{i} + \omega^{i}} + f(\omega^{\frac{N}{2} + i}) \cdot \frac{x - \omega^{i}}{-\omega^{i} - \omega^{i}} \\
&amp;= \frac{1}{2} \left( (1 + x \omega^{-i}) f(\omega^{i}) + (1 - x \omega^{-i}) f(\omega^{\frac{N}{2} + i}) \right)
\end{align*}</p>
<h2 id="fri-protocol-interactive"><a class="header" href="#fri-protocol-interactive">FRI Protocol (Interactive)</a></h2>
<p>The FRI protocol proceeds in rounds:</p>
<ol>
<li>
<p><strong>Commitment Phase</strong></p>
<ul>
<li>The prover computes the evaluations of the initial polynomial \(f(X)\) over the subgroup \(D\) of size \(N\), forming the codeword \(\{f(\omega^{i})\}_{i=0}^{N - 1}\).</li>
<li>The verifier sends a random value \(\alpha\) to the prover.</li>
<li>The prover computes the evaluations of the folded polynomial \(f^{*}(x)\) over the subgroup \(D^2\), forming the other codeword \(\{f^{*}(w^{2i})\}_{i=0}^{\frac{N}{2} - 1}\)</li>
<li>The prover commits to these codewords by sending their Merkle roots to the verifier. The prover cannot change codewords after this commitment.</li>
</ul>
</li>
<li>
<p><strong>Interactive Query Phase</strong></p>
<ul>
<li>The verifier randomly samples an index \(i \leftarrow \{0, \dots, \frac{N}{2} - 1\}\).</li>
<li>The prover reveals the values \(f(\omega^{i})\), \(f(\omega^{\frac{N}{2} + i})\), and \(f^{*}(\omega^{2i})\) along with their Merkle authentication paths.</li>
<li>The verifier checks the Merkle paths to ensure the revealed values are consistent with the previously sent Merkle roots.</li>
<li>The verifier performs the collinearity check: verifies if the point \((\alpha, f^{*}(\omega^{2i}))\) lies on the line defined by \((\omega^{i}, f(\omega^{i}))\) and \((\omega^{\frac{N}{2} + i}, f(\omega^{\frac{N}{2} + i}))\).</li>
</ul>
</li>
<li>
<p><strong>Degree Reduction</strong></p>
<ul>
<li>If the collinearity check passes, the verifier is convinced that the folded polynomial \(f^{*}(X)\) was correctly derived. The protocol then repeats with \(f^{*}(X)\) and the subgroup \(D^2\). The size of the subgroup and the effective degree of the polynomial are roughly halved in each round.</li>
</ul>
</li>
</ol>
<p>This process continues for \(\log_2{d}\) rounds. At the final round, the remaining polynomial is a constant function, and the verifier can directly query all the remaining evaluation points to verify the degree bound. Note that with each successive round \(j\), the size of the domain \(D^{j}\) is halved. If \(d = 2^{n}\) and \(N = 8d = 2^{3+n}\), the size of the domain after \(\log_2{d} = n\) rounds is only \(8\).</p>
<h2 id="fri-protocol-non-interactive"><a class="header" href="#fri-protocol-non-interactive">FRI Protocol (Non-Interactive)</a></h2>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
