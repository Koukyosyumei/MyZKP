<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Book of MyZKP</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="number_theory/index.html"><strong aria-hidden="true">2.</strong> Basics of Number Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="number_theory/subsec1.html"><strong aria-hidden="true">2.1.</strong> Computation Rule and Properties</a></li><li class="chapter-item expanded "><a href="number_theory/subsec2.html"><strong aria-hidden="true">2.2.</strong> Semigroup, Group, Ring, and Field</a></li><li class="chapter-item expanded "><a href="number_theory/subsec3.html"><strong aria-hidden="true">2.3.</strong> Polynomials</a></li><li class="chapter-item expanded "><a href="number_theory/subsec4.html"><strong aria-hidden="true">2.4.</strong> Galois Field</a></li><li class="chapter-item expanded "><a href="number_theory/subsec5.html"><strong aria-hidden="true">2.5.</strong> Elliptic Curve</a></li><li class="chapter-item expanded "><a href="number_theory/subsec6.html"><strong aria-hidden="true">2.6.</strong> Pairing</a></li><li class="chapter-item expanded "><a href="number_theory/subsec7.html"><strong aria-hidden="true">2.7.</strong> Useful Assumptions</a></li></ol></li><li class="chapter-item expanded "><a href="zksnark/index.html"><strong aria-hidden="true">3.</strong> Basics of zk-SNARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zksnark/subsec2.html"><strong aria-hidden="true">3.1.</strong> Arithmetization</a></li><li class="chapter-item expanded "><a href="zksnark/subsec3.html"><strong aria-hidden="true">3.2.</strong> Proving Single Polynomial</a></li><li class="chapter-item expanded "><a href="zksnark/subsec4.html"><strong aria-hidden="true">3.3.</strong> Bringing It All Together</a></li></ol></li><li class="chapter-item expanded "><a href="zkstark/index.html"><strong aria-hidden="true">4.</strong> Basics of zk-STARKS</a></li><li class="chapter-item expanded "><a href="zkvm/index.html"><strong aria-hidden="true">5.</strong> Basics of zkVM</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book of MyZKP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Koukyosyumei/MyZKP/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-myzkp-building-zero-knowledge-proof-from-scratch-in-rust"><a class="header" href="#-myzkp-building-zero-knowledge-proof-from-scratch-in-rust">🚀 MyZKP: Building Zero Knowledge Proof from Scratch in Rust</a></h1>
<pre><code>███╗   ███╗  ██╗   ██╗  ███████╗  ██╗  ██╗  ██████╗   🦀
████╗ ████║  ╚██╗ ██╔╝  ╚══███╔╝  ██║ ██╔╝  ██╔══██╗ 🦀
██╔████╔██║   ╚████╔╝     ███╔╝   █████╔╝   ██████╔╝ 
██║╚██╔╝██║    ╚██╔╝     ███╔╝    ██╔═██╗   ██╔═══╝    🦀
██║ ╚═╝ ██║     ██║     ███████╗  ██║  ██╗  ██║    🦀    
╚═╝     ╚═╝     ╚═╝     ╚══════╝  ╚═╝  ╚═╝  ╚═╝      🦀
</code></pre>
<p><strong>MyZKP</strong> is a Rust implementation of zero-knowledge protocols built entirely from scratch! This project serves as an educational resource for understanding and working with zero-knowledge proofs.</p>
<blockquote>
<p>⚠️ <strong>Warning:</strong>
This repository is a work in progress and may contain bugs or inaccuracies. Contributions and feedback are welcome!</p>
</blockquote>
<h2 id="index"><a class="header" href="#index">Index</a></h2>
<p><strong>🧮 Basic of Number Theory</strong></p>
<ul>
<li>📝 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec1.html">Computation Rule and Properties</a></li>
<li>⚙️ <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec2.html">Semigroup, Group, Ring, and Field</a></li>
<li>🔢 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec3.html">Polynomials</a></li>
<li>🌐 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec4.html">Galois Field</a></li>
<li>📈 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec5.html">Elliptic Curve</a></li>
<li>🔗 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec6.html">Pairing</a></li>
<li>🤔 <a href="https://koukyosyumei.github.io/MyZKP/number_theory/subsec7.html">Useful Assumptions</a></li>
</ul>
<p><strong>🔒 Basic of zk-SNARKs</strong></p>
<ul>
<li>⚡ <a href="https://koukyosyumei.github.io/MyZKP/zksnark/subsec2.html">Arithmetization</a></li>
<li>🛠️ <a href="https://koukyosyumei.github.io/MyZKP/zksnark/subsec3.html">Proving Single Polynomial</a></li>
</ul>
<p><strong>🌟 Basic of zk-STARKs</strong></p>
<ul>
<li>✍️ TBD</li>
</ul>
<p><strong>💻 Basic of zkVM</strong></p>
<ul>
<li>✍️ TBD</li>
</ul>
<h2 id="-code-reference"><a class="header" href="#-code-reference">🛠️ Code Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>📂 File Path</th></tr></thead><tbody>
<tr><td><strong>Ring</strong></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/ring.rs">ring.rs</a></td></tr>
<tr><td><strong>Field</strong></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/field.rs">field.rs</a></td></tr>
<tr><td><strong>Extended Field</strong></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/efield.rs">efield.rs</a></td></tr>
<tr><td><strong>Polynomial</strong></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/polynomial.rs">polynomial.rs</a></td></tr>
<tr><td><strong>Elliptic Curve</strong></td><td><a href="https://github.com/Koukyosyumei/MyZKP/tree/main/myzkp/src/modules/curve.rs">curve.rs</a></td></tr>
<tr><td><strong>zkSNARKs</strong></td><td>✍️ Coming soon</td></tr>
</tbody></table>
</div>
<h2 id="-contributions-are-welcome"><a class="header" href="#-contributions-are-welcome">✨ <strong>Contributions are Welcome!</strong></a></h2>
<p>Feel free to submit issues or pull requests to enhance the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-number-theory"><a class="header" href="#basics-of-number-theory">Basics of Number Theory</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computation-rule-and-properties"><a class="header" href="#computation-rule-and-properties">Computation Rule and Properties</a></h1>
<h3 id="definition-binary-operation"><a class="header" href="#definition-binary-operation">Definition: Binary Operation</a></h3>
<hr />
<p><em>A mapping \(\circ: X \times X \rightarrow X\) is a binary operation on \(X\) if for any pair of elements \((x_1, x_2)\) in \(X\), \(x_1 \circ x_2\) is also in \(X\).</em></p>
<hr />
<p><strong>Example:</strong> Addition (+) on the set of integers is a binary operation. For example, \(5 + 3 = 8\), and both \(5, 3, 8\) are integers, staying within the set of integers.</p>
<h3 id="definition-associative-property"><a class="header" href="#definition-associative-property">Definition: Associative Property</a></h3>
<hr />
<p><em>A binary operation \(\circ\) is associative if \((a \circ b) \circ c = a \circ (b \circ c)\) for all \(a, b, c \in X\).</em></p>
<hr />
<p><strong>Example:</strong> Multiplication of real numbers is associative: \((2 \times 3) \times 4 = 2 \times (3 \times 4) = 24\). In a modular context, we also have addition modulo \(n\) being associative. For example, for \(n = 5\), \((2 + 3) \bmod 5 + 4 \bmod 5 = 2 + (3 \bmod 5 + 4) \bmod 5 = 4\).</p>
<h3 id="definition-commutative-property"><a class="header" href="#definition-commutative-property">Definition: Commutative Property</a></h3>
<hr />
<p><em>A binary operation \(\circ\) is commutative if \(a \circ b = b \circ a\) for all \(a, b \in X\).</em></p>
<hr />
<p><strong>Example:</strong> Addition modulo \(n\) is also commutative. For \(n = 7\), \(5 + 3 \bmod 7 = 3 + 5 \bmod 7 = 1\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semigroup-group-ring-and-field"><a class="header" href="#semigroup-group-ring-and-field">Semigroup, Group, Ring, and Field</a></h1>
<h3 id="definition-semigroup"><a class="header" href="#definition-semigroup">Definition: Semigroup</a></h3>
<hr />
<p><em>A pair \((H, \circ)\), where \(H\) is a non-empty set and \(\circ\) is an associative binary operation on \(H\), is called a semigroup.</em></p>
<hr />
<p><strong>Example:</strong> The set of positive integers under multiplication modulo \(n\) forms a semigroup. For instance, with \(n = 6\), the elements \(\{1, 2, 3, 4, 5\}\) under multiplication modulo 6 form a semigroup, since multiplication modulo 6 is associative.</p>
<h3 id="definition-abelian-semigroup"><a class="header" href="#definition-abelian-semigroup">Definition: Abelian Semigroup</a></h3>
<hr />
<p><em>A semigroup whose operation is commutative is called an abelian semigroup.</em></p>
<hr />
<p><strong>Example:</strong> The set of natural numbers under addition modulo \(n\) forms an abelian semigroup. For \(n = 7\), addition modulo 7 is both associative and commutative, so it is an abelian semigroup.</p>
<h3 id="definition-identity-element"><a class="header" href="#definition-identity-element">Definition: Identity Element</a></h3>
<hr />
<p><em>An element \(e \in H\) is an identity element of \(H\) if it satisfies \(e \circ a = a \circ e = a\) for any \(a \in H\).</em></p>
<hr />
<p><strong>Example:</strong> 0 is the identity element for addition modulo \(n\). For example, \(0 + a \bmod 5 = a + 0 \bmod 5 = a\). Similarly, 1 is the identity element for multiplication modulo \(n\). For example, \(1 \times a \bmod 7 = a \times 1 \bmod 7 = a\).</p>
<h3 id="definition-monoid"><a class="header" href="#definition-monoid">Definition: Monoid</a></h3>
<hr />
<p><em>A semigroup with an identity element is called a monoid.</em></p>
<hr />
<p><strong>Example:</strong> The set of non-negative integers under addition modulo \(n\) forms a monoid. For \(n = 5\), the set \(\{0, 1, 2, 3, 4\}\) under addition modulo 5 forms a monoid with 0 as the identity element.</p>
<h3 id="definition-inverse"><a class="header" href="#definition-inverse">Definition: Inverse</a></h3>
<hr />
<p><em>For an element \(a \in H\), an element \(b \in H\) is an inverse of \(a\) if \(a \circ b = b \circ a = e\), where \(e\) is the identity element.</em></p>
<hr />
<p><strong>Example:</strong> In modulo \(n\) arithmetic (addition), the inverse of an element exists if it can cancel itself out to yield the identity element. In the set of integers modulo 7, the inverse of 3 is 5, because \(3 \times 5 \bmod 7 = 1\), where 1 is the identity element for multiplication.</p>
<h3 id="definition-group"><a class="header" href="#definition-group">Definition: Group</a></h3>
<hr />
<p><em>A monoid in which every element has an inverse is called a group.</em></p>
<hr />
<p><strong>Example:</strong> The set of integers modulo a prime \(p\) under multiplication forms a group (Can you prove it?). For instance, in \(\mathbb{Z}/5\mathbb{Z}\), every non-zero element \(\{1 + 5\mathbb{Z}, 2 + 5\mathbb{Z}, 3 + 5\mathbb{Z}, 4 + 5\mathbb{Z}\}\) has an inverse, making it a group.</p>
<h3 id="definition-order-of-a-group"><a class="header" href="#definition-order-of-a-group">Definition: Order of a Group</a></h3>
<hr />
<p><em>The order of a group is the number of elements in the group.</em></p>
<hr />
<p><strong>Example:</strong> The group of integers modulo 4 under addition has order 4, because the set of elements is \(\{0, 1, 2, 3\}\).</p>
<h3 id="definition-ring"><a class="header" href="#definition-ring">Definition: Ring</a></h3>
<hr />
<p><em>A triple \((R, +, \cdot)\) is a ring if \((R, +)\) is an abelian group, \((R, \cdot)\) is a semigroup, and the distributive property holds: \(x \cdot (y + z) = (x \cdot y) + (x \cdot z)\) and \((x + y) \cdot z = (x \cdot z) + (y \cdot z)\) for all \(x, y, z \in R\).</em></p>
<hr />
<p><strong>Example:</strong> The set of integers with usual addition and multiplication modulo \(n\) forms a ring. For example, in \(\mathbb{Z}/6\mathbb{Z}\), addition and multiplication modulo 6 form a ring.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use num_bigint::BigInt;
use num_traits::{One, Zero};
use std::fmt;
use std::ops::{Add, Mul, Neg, Sub};

pub trait Ring:
    Sized
    + Clone
    + PartialEq
    + fmt::Display
    + Add&lt;Output = Self&gt;
    + for&lt;'a&gt; Add&lt;&amp;'a Self, Output = Self&gt;
    + Sub&lt;Output = Self&gt;
    + for&lt;'a&gt; Sub&lt;&amp;'a Self, Output = Self&gt;
    + Mul&lt;Output = Self&gt;
    + for&lt;'a&gt; Mul&lt;&amp;'a Self, Output = Self&gt;
    + Neg&lt;Output = Self&gt;
    + One
    + Zero
{
    // A ring is an algebraic structure with addition and multiplication
    fn add_ref(&amp;self, rhs: &amp;Self) -&gt; Self;
    fn sub_ref(&amp;self, rhs: &amp;Self) -&gt; Self;
    fn mul_ref(&amp;self, rhs: &amp;Self) -&gt; Self;

    // Utility functions
    fn pow&lt;M: Into&lt;BigInt&gt;&gt;(&amp;self, n: M) -&gt; Self;
    fn get_value(&amp;self) -&gt; BigInt;
    fn from_value&lt;M: Into&lt;BigInt&gt;&gt;(value: M) -&gt; Self;
    fn random_element(exclude_elements: &amp;[Self]) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-communicative-ring"><a class="header" href="#definition-communicative-ring">Definition: Communicative Ring</a></h3>
<hr />
<p><em>A ring is called a commutative ring if its multiplication operation is commutative.</em></p>
<hr />
<p><strong>Example</strong> The set of real numbers under usual addition and multiplication forms a commutative ring.</p>
<h3 id="definition-field"><a class="header" href="#definition-field">Definition: Field</a></h3>
<hr />
<p><em>A commutative ring with a multiplicative identity element where every non-zero element has a multiplicative inverse is called a field.</em></p>
<hr />
<p><strong>Example</strong> The set of rational numbers under usual addition and multiplication forms a field.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Field: Ring + Div&lt;Output = Self&gt; + PartialEq + Eq + Hash {
    /// Computes the multiplicative inverse of the element.
    fn inverse(&amp;self) -&gt; Self;
    fn div_ref(&amp;self, other: &amp;Self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-residue-class"><a class="header" href="#definition-residue-class">Definition: Residue Class</a></h3>
<hr />
<p><em>The residue class of \( a \) modulo \( m \), denoted as \( a + m\mathbb{Z} \), is the set \( \{b : b \equiv a \pmod{m}\} \).</em></p>
<hr />
<p><strong>Example:</strong> For \( m = 3 \), the residue class of 2 is \( 2 + 3\mathbb{Z} = \{\ldots, -4, -1, 2, 5, 8, \ldots\} \).</p>
<h3 id="definition-inverse-of-residue-class"><a class="header" href="#definition-inverse-of-residue-class">Definition: Inverse of Residue Class</a></h3>
<hr />
<p><em>We denote the set of all residue classes modulo \( m \) as \( \mathbb{Z} / m\mathbb{Z} \). We say that \( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z} / m\mathbb{Z} \) if and only if there exists a solution for \( ax \equiv 1 \pmod{m} \).</em></p>
<hr />
<p><strong>Example:</strong> In \( \mathbb{Z}/5\mathbb{Z} \), \( 3 + 5\mathbb{Z} \) is invertible because \( \gcd(3, 5) = 1 \) (since \( 3\cdot2 \equiv 1 \pmod{5} \)). However, in \( \mathbb{Z}/6\mathbb{Z} \), \( 3 + 6\mathbb{Z} \) is not invertible because \( \gcd(3, 6) = 3 \neq 1 \).</p>
<h3 id="lemma-221"><a class="header" href="#lemma-221">Lemma 2.2.1</a></h3>
<hr />
<p><em>If \( a \) and \( b \) are coprime, the residues of \( a \), \( 2a \), \( 3a \), ..., \( (b-1)a \) modulo \( b \) are all distinct.</em></p>
<hr />
<p><strong>Proof:</strong> Suppose, for contradiction, that there exist \( x, y \in \{1, 2, \dots, b-1\} \) with \( x \neq y \) such that \( xa \equiv ya \pmod{b} \). Then \( (x-y)a \equiv 0 \pmod{b} \), implying \( b \mid (x-y)a \). Since \( a \) and \( b \) are coprime, we must have \( b \mid (x-y) \). However, \( |x-y| &lt; b \), so this is only possible if \( x = y \), contradicting our assumption. Therefore, all residues must be distinct.</p>
<h3 id="theorem-222"><a class="header" href="#theorem-222">Theorem 2.2.2</a></h3>
<hr />
<p><em>For any integers \( a \) and \( b \), the equation \( ax + by = 1 \) has a solution in integers \( x \) and \( y \) if and only if \( a \) and \( b \) are coprime.</em></p>
<hr />
<p><strong>Proof:</strong></p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> Suppose \( a \) and \( b \) are not coprime, let \( d = \gcd(a,b) &gt; 1 \). Then \( d \mid a \) and \( d \mid b \), so \( d \mid (ax + by) \) for any integers \( x \) and \( y \). Thus, \( ax + by \neq 1 \) for any \( x \) and \( y \).</li>
<li><strong>(\( \Leftarrow \))</strong> Suppose \( a \) and \( b \) are coprime. By the previous lemma, the residues of \( a \), \( 2a \), ..., \( (b-1)a \) modulo \( b \) are all distinct. Therefore, there exists an \( m \in \{1, 2, ..., b-1\} \) such that \( ma \equiv 1 \pmod{b} \). This means there exists an integer \( n \) such that \( ma = bn + 1 \), or equivalently, \( ma - bn = 1 \).</li>
</ul>
<h3 id="theorem-bézouts-identity"><a class="header" href="#theorem-bézouts-identity">Theorem: Bézout's Identity</a></h3>
<hr />
<p><em>For any integers \( a \) and \( b \), we have:
\(
a\mathbb{Z} + b \mathbb{Z} = \gcd(a, b)\mathbb{Z}
\)</em></p>
<hr />
<p><strong>Proof:</strong></p>
<p>This statement is equivalent to proving that \( ax + by = c \) has an integer solution if and only if \( c \) is a multiple of \( \gcd(a,b) \).</p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> If \( ax + by = c \) for some integers \( x \) and \( y \), then \( \gcd(a,b) \mid a \) and \( \gcd(a,b) \mid b \), so \( \gcd(a,b) \mid (ax + by) = c \).</li>
<li><strong>(\( \Leftarrow \))</strong> Let \( c = k\gcd(a,b) \) for some integer \( k \). We can write \( a = p\gcd(a,b) \) and \( b = q\gcd(a,b) \), where \( p \) and \( q \) are coprime. By the previous theorem, there exist integers \( m \) and \( n \) such that \( pm + qn = 1 \). Multiplying both sides by \( k\gcd(a,b) \), we get:
\[
akm + bkn = c
\]
Thus, \( x = km \) and \( y = kn \) are integer solutions to \( ax + by = c \).</li>
</ul>
<p>This theorem implies that for any integers \( a \), \( b \), and \( n \), the equation \( ax + by = n \) has an integer solution if and only if \( \gcd(a,b) \mid n \).</p>
<h3 id="theorem-223"><a class="header" href="#theorem-223">Theorem 2.2.3</a></h3>
<hr />
<p><em>\( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z}/m\mathbb{Z} \) if and only if \( \gcd(a,m) = 1 \).</em></p>
<hr />
<p><strong>Proof:</strong></p>
<ul>
<li><strong>(\( \Rightarrow \))</strong> Suppose \( a + m\mathbb{Z} \) is invertible in \( \mathbb{Z}/m\mathbb{Z} \). Then there exists an integer \( x \) such that \( ax \equiv 1 \pmod{m} \). Let \( g = \gcd(a,m) \). Since \( g \mid ax \) and \( g \mid (ax - 1) \), we must have \( g \mid 1 \), so \( g = 1 \).</li>
<li><strong>(\( \Leftarrow \))</strong> Suppose \( \gcd(a,m) = 1 \). By Bézout's identity, there exist integers \( x \) and \( y \) such that \( ax + my = 1 \). Thus, \( x + m\mathbb{Z} \) is the multiplicative inverse of \( a + m\mathbb{Z} \) in \( \mathbb{Z}/m\mathbb{Z} \).</li>
</ul>
<h3 id="definition-residue-class-ring"><a class="header" href="#definition-residue-class-ring">Definition: Residue Class Ring</a></h3>
<hr />
<p><em>\( (\mathbb{Z} / m \mathbb{Z}, +, \cdot) \) is a commutative ring where \( 1 + m \mathbb{Z} \) is the multiplicative identity element. This ring is called the residue class ring modulo \( m \).</em></p>
<hr />
<p><strong>Example:</strong> \( \mathbb{Z}/4\mathbb{Z} = \{0 + 4\mathbb{Z}, 1 + 4\mathbb{Z}, 2 + 4\mathbb{Z}, 3 + 4\mathbb{Z}\} \).</p>
<h3 id="definition-primitive-residue-class"><a class="header" href="#definition-primitive-residue-class">Definition: Primitive Residue Class</a></h3>
<hr />
<p><em>A residue class \( a + m\mathbb{Z} \) is called primitive if \( \gcd(a, m) = 1 \).</em></p>
<hr />
<p><strong>Example:</strong> In \( \mathbb{Z}/6\mathbb{Z} \), the primitive residue classes are \( 1 + 6\mathbb{Z} \) and \( 5 + 6\mathbb{Z} \).</p>
<h3 id="theorem-224"><a class="header" href="#theorem-224">Theorem 2.2.4</a></h3>
<hr />
<p><em>A residue ring \( \mathbb{Z} / m\mathbb{Z} \) is a field if and only if \( m \) is a prime number.</em></p>
<hr />
<p><strong>Proof:</strong> TBD</p>
<p><strong>Example:</strong> For \( m = 5 \), \( \mathbb{Z}/5\mathbb{Z} = \{0 + 5\mathbb{Z}, 1 + 5\mathbb{Z}, 2 + 5\mathbb{Z}, 3 + 5\mathbb{Z}, 4 + 5\mathbb{Z}\} \) forms a field because 5 is a prime number, and every non-zero element has a multiplicative inverse.</p>
<h3 id="definition-primitive-residue-class-group"><a class="header" href="#definition-primitive-residue-class-group">Definition: Primitive Residue Class Group</a></h3>
<hr />
<p><em>The group of all primitive residue classes modulo \( m \) is called the primitive residue class group, denoted by \( (\mathbb{Z}/m\mathbb{Z})^{\times} \).</em></p>
<hr />
<p><strong>Example:</strong> For \( m = 8 \), the set of all primitive residue classes is \( (\mathbb{Z}/8\mathbb{Z})^{\times} = \{1 + 8\mathbb{Z}, 3 + 8\mathbb{Z}, 5 + 8\mathbb{Z}, 7 + 8\mathbb{Z}\} \). These are the integers less than 8 that are coprime to 8 (i.e., \(\gcd(a, 8) = 1\)).</p>
<p>Contrast this with \( m = 9 \). The primitive residue class group is \((\mathbb{Z}/9\mathbb{Z})^{\times} = \{1 + 9\mathbb{Z}, 2 + 9\mathbb{Z}, 4 + 9\mathbb{Z}, 5 + 9\mathbb{Z}, 7 + 9\mathbb{Z}, 8 + 9\mathbb{Z}\}\), as these are the integers less than 9 that are coprime to 9.</p>
<h3 id="definition-eulers-totient-function"><a class="header" href="#definition-eulers-totient-function">Definition: Euler's Totient Function</a></h3>
<hr />
<p><em>Euler's totient function \(\phi(m)\) is equal to the order of the primitive residue class group modulo \(m\), which is the number of integers less than \(m\) and coprime to \(m\).</em></p>
<hr />
<p><strong>Example:</strong> For \(m = 12\), \(\phi(12) = 4\) because there are 4 integers less than 12 that are coprime to 12: \({1, 5, 7, 11}\).</p>
<p>For \(m = 10\), \(\phi(10) = 4\), as there are also 4 integers less than 10 that are coprime to 10: \({1, 3, 7, 9}\).</p>
<h3 id="definition-order-of-an-element-within-a-group"><a class="header" href="#definition-order-of-an-element-within-a-group">Definition: Order of an Element within a Group</a></h3>
<hr />
<p><em>The order of \(g \in G\) is the smallest natural number \(e\) such that \(g^{e} = 1\). We denote it as \(\text{order}_g(g)\)or \(\text{order } g\).</em></p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/7\mathbb{Z})^{\times}\), the element 3 has order 6 because \(3^6 \bmod 7 = 1\). In other words, \(3 \times 3 \times 3 \times 3 \times 3 \times 3 \bmod 7 = 1\), and 6 is the smallest such exponent.</p>
<h3 id="definition-subgroup"><a class="header" href="#definition-subgroup">Definition: Subgroup</a></h3>
<hr />
<p><em>A subset \(U \subseteq G\) is a subgroup of \(G\) if \(U\) itself is a group under the operation of \(G\).</em></p>
<hr />
<p><strong>Example:</strong> Consider \((\mathbb{Z}/8\mathbb{Z})^{\times} = \{1 + 8\mathbb{Z}, 3+ 8\mathbb{Z}, 5+ 8\mathbb{Z}, 7+ 8\mathbb{Z}\}\) under multiplication modulo 8. The subset \({1+ 8\mathbb{Z}, 7+ 8\mathbb{Z}}\) forms a subgroup because it satisfies the group properties: closed under multiplication, contains the identity element (1), and every element has an inverse (\(7 \times 7 \equiv 1 \bmod 8\)).</p>
<h3 id="definition-subgroup-generated-by-g"><a class="header" href="#definition-subgroup-generated-by-g">Definition: Subgroup Generated by \(g\)</a></h3>
<hr />
<p><em>The set \(\{g^{k} : k \in \mathbb{Z}\}\), for some element \(g \in G\), forms a subgroup of \(G\) and is called the subgroup generated by \(g\), denoted by \(\langle g \rangle\).</em></p>
<hr />
<p><strong>Example:</strong> Consider the group \((\mathbb{Z}/7\mathbb{Z})^{\times} = \{1+ 7\mathbb{Z}, 2+ 7\mathbb{Z}, 3+ 7\mathbb{Z}, 4+ 7\mathbb{Z}, 5+ 7\mathbb{Z}, 6+ 7\mathbb{Z}\}\) under multiplication modulo 7. If we take \(g = 3\), then \(\langle 3 +7\mathbb{Z} \rangle =\) \(\{3^1+7\mathbb{Z}, 3^2+7\mathbb{Z}, 3^3+7\mathbb{Z}, 3^4+7\mathbb{Z}, 3^5+7\mathbb{Z}, 3^6+7\mathbb{Z}\} \bmod 7 =\) \(\{3+7\mathbb{Z}, 2+7\mathbb{Z}, 6+7\mathbb{Z}, 4+7\mathbb{Z}, 5+7\mathbb{Z}, 1+7\mathbb{Z}\}\), which forms a subgroup generated by 3. This subgroup contains all elements of \((\mathbb{Z}/7\mathbb{Z})^{\times}\), making 3 a generator of the entire group.</p>
<p>If \(g\) has a finite order \(e\), we have that \(\langle g \rangle = \{g^{k}: 0 \leq k \leq e\}\), meaning \(e\) is the order of \(\langle g \rangle\).</p>
<h3 id="definition-cyclic-group"><a class="header" href="#definition-cyclic-group">Definition: Cyclic Group</a></h3>
<hr />
<p><em>A group \(G\) is called a cyclic group if there exists an element \(g \in G\) such that \(G = \langle g \rangle\). In this case, \(g\) is called a generator of \(G\).</em></p>
<hr />
<p><strong>Example:</strong> The group \((\mathbb{Z}/6\mathbb{Z})^{\times} = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\) under multiplication modulo 6 is a cyclic group. In this case, both 1 and 5 are generators of the group because \(\langle 5 +6\mathbb{Z} \rangle = \{(5^1 \bmod 6)+6\mathbb{Z} = 5 +6\mathbb{Z}, (5^2 \bmod 6)+6\mathbb{Z} = 1+6\mathbb{Z}\}\). Since 5 generates all the elements of the group, \(G\) is cyclic.</p>
<h3 id="theorem-225"><a class="header" href="#theorem-225">Theorem 2.2.5</a></h3>
<hr />
<p><em>If \(G\) is a finite cyclic group, it has \(\phi(|G|)\)generators, and each generator has order \(|G|\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Consider the group \((\mathbb{Z}/8\mathbb{Z})^{\times} = \{1+8\mathbb{Z}, 3+8\mathbb{Z}, 5+8\mathbb{Z}, 7+8\mathbb{Z}\}\). This group is cyclic, and \(\phi(8) = 4\). The generators of this group are \(\{1+8\mathbb{Z}, 3+8\mathbb{Z}, 5+8\mathbb{Z}, 7+8\mathbb{Z}\}\), each of which generates the entire group when raised to successive powers modulo 8. Each generator has the same order, which is \(|G| = 4\).</p>
<h3 id="theorem-226"><a class="header" href="#theorem-226">Theorem 2.2.6</a></h3>
<hr />
<p><em>If \(G\) is a finite cyclic group, the order of any subgroup of \(G\) divides the order of \(G\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Consider the cyclic group \((\mathbb{Z}/6\mathbb{Z})^{\times} = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\) under multiplication modulo 6. If we take the subgroup \(\langle 5+6\mathbb{Z} \rangle = \{1+6\mathbb{Z}, 5+6\mathbb{Z}\}\), this is a subgroup of order 2, and 2 divides the order of the original group, which is 6. This theorem generalizes this property: for any subgroup of a cyclic group, its order divides the order of the group.</p>
<h3 id="theorem-fermats-little-theorem"><a class="header" href="#theorem-fermats-little-theorem">Theorem: Fermat's Little Theorem</a></h3>
<hr />
<p><em>If \(\gcd(a, m) = 1\), then \(a^{\phi(m)} \equiv 1 \pmod{m}\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> Take \(a = 2\) and \(m = 5\). Since \(\gcd(2, 5) = 1\), Fermat's Little Theorem tells us that \(2^{\phi(5)} = 2^4 \equiv 1 \bmod 5\). Indeed, \(2^4 = 16\) and \(16 \bmod 5 = 1\).</p>
<p>This theorem suggests that \(a^{\phi(m) - 1} + m \mathbb{Z}\) is the inverse residue class of \(a + m \mathbb{Z}\).</p>
<h3 id="theorem-227"><a class="header" href="#theorem-227">Theorem 2.2.7</a></h3>
<hr />
<p><em>The order of any element in a group divides the order of the group.</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> In the group \((\mathbb{Z}/7\mathbb{Z})^{\times}\), consider the element \(3 + 7\mathbb{Z}\). The order of \(3 + 7\mathbb{Z}\) is 6, as \(3^6 \equiv 1 \bmod 7\). The order of the group itself is also 6, and indeed, the order of the element divides the order of the group.</p>
<h3 id="theorem-generalization-of-fermats-little-theorem"><a class="header" href="#theorem-generalization-of-fermats-little-theorem">Theorem: Generalization of Fermat's Little Theorem</a></h3>
<hr />
<p><em>For any element \(g \in G\), we have \(g^{|G|} = 1\).</em></p>
<hr />
<p><strong>Proof</strong>: TBD</p>
<p><strong>Example:</strong> In the group \((\mathbb{Z}/7\mathbb{Z})^{\times}\), for any element \(g\), such as \(g = 3 + 7\mathbb{Z}\), we have \(3^6 \equiv 1 \bmod 7\). This holds for any \(g \in (\mathbb{Z}/7\mathbb{Z})^{\times}\) because the order of the group is 6. Thus, \(g^{|G|} = 1\) is satisfied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polynomials"><a class="header" href="#polynomials">Polynomials</a></h1>
<h3 id="definition-polynomial"><a class="header" href="#definition-polynomial">Definition: Polynomial</a></h3>
<hr />
<p><em>A univariate polynomial over a commutative ring \(R\) with unity \(1\) is an expression of the form \(f(x) = a_n x^{n} + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0\), where \(x\) is a variable and coefficients \(a_0, \ldots, a_n\) belong to \(R\). The set of all polynomials over \(R\) in the variable \(x\) is denoted as \(R[x]\).</em></p>
<hr />
<p><strong>Example:</strong> In \(\mathbb{Z}[x]\), we have polynomials such as \(2x^3 + x + 1\), \(x\), and \(1\). In \(\mathbb{R}[x]\), we have polynomials like \(\pi x^2 - \sqrt{2}x + e\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A struct representing a polynomial over a finite field.
#[derive(Debug, Clone, PartialEq)]
pub struct Polynomial&lt;F: Field&gt; {
    /// Coefficients of the polynomial in increasing order of degree.
    pub coef: Vec&lt;F&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-degree"><a class="header" href="#definition-degree">Definition: Degree</a></h3>
<hr />
<p><em>The degree of a non-zero polynomial \(f(x) = a_n x^{n} + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0\), denoted as \(\deg f\), is the largest integer \(n\) such that \(a_n \neq 0\). The zero polynomial is defined to have degree \(-1\).</em></p>
<hr />
<p><strong>Example</strong></p>
<ul>
<li>\(\deg(2x^3 + x + 1) = 3\)</li>
<li>\(\deg(x) = 1\)</li>
<li>\(\deg(1) = 0\)</li>
<li>\(\deg(0) = -1\)</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    /// Removes trailing zeroes from a polynomial's coefficients.
    fn trim_trailing_zeros(poly: Vec&lt;F&gt;) -&gt; Vec&lt;F&gt; {
        let mut trimmed = poly;
        while trimmed.last() == Some(&amp;F::zero(None)) {
            trimmed.pop();
        }
        trimmed
    }

    /// Returns the degree of the polynomial.
    pub fn degree(&amp;self) -&gt; isize {
        let trimmed = Self::trim_trailing_zeros(self.poly.clone());
        if trimmed.is_empty() {
            -1
        } else {
            (trimmed.len() - 1) as isize
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-sum-of-polynomials"><a class="header" href="#definition-sum-of-polynomials">Definition: Sum of Polynomials</a></h3>
<hr />
<p><em>For polynomials \(f(x) = \sum_{i=0}^n a_i x^i\) and \(g(x) = \sum_{i=0}^m b_i x^i\), their sum is defined as: \((f + g)(x) = \sum_{i=0}^{\max(n,m)} (a_i + b_i) x^i\), where we set \(a_i = 0\) for \(i &gt; n\) and \(b_i = 0\) for \(i &gt; m\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = 2x^2 + 3x + 1\) and \(g(x) = x^3 - x + 4\). Then, \((f + g)(x) = x^3 + 2x^2 + 2x + 5\)</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn add_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        let max_len = std::cmp::max(self.coef.len(), other.coef.len());
        let mut result = Vec::with_capacity(max_len);

        let zero = F::zero();

        for i in 0..max_len {
            let a = self.coef.get(i).unwrap_or(&amp;zero);
            let b = other.coef.get(i).unwrap_or(&amp;zero);
            result.push(a.add_ref(b));
        }
        Polynomial {
            coef: Self::trim_trailing_zeros(result),
        }
    }
}

impl&lt;F: Field&gt; Add for Polynomial&lt;F&gt; {
    type Output = Self;

    fn add(self, other: Self) -&gt; Polynomial&lt;F&gt; {
        self.add_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-product-of-polynomials"><a class="header" href="#definition-product-of-polynomials">Definition: Product of polynomials</a></h3>
<hr />
<p><em>For polynomials \(f(x) = \sum_{i=0}^n a_i x^i\) and \(g(x) = \sum_{j=0}^m b_j x^j\), their product is defined as: \((fg)(x) = \sum_{k=0}^{n+m} c_k x^k\), where \(c_k = \sum_{i+j=k} a_i b_j\)</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x + 1\) and \(g(x) = x^2 - 1\). Then, \((fg)(x) = x^3 + x^2 - x - 1\)</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn mul_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        if self.is_zero() || other.is_zero() {
            return Polynomial::&lt;F&gt;::zero();
        }
        let mut result = vec![F::zero(); (self.degree() + other.degree() + 1) as usize];

        for (i, a) in self.coef.iter().enumerate() {
            for (j, b) in other.coef.iter().enumerate() {
                result[i + j] = result[i + j].add_ref(&amp;a.mul_ref(b));
            }
        }
        Polynomial {
            coef: Polynomial::&lt;F&gt;::trim_trailing_zeros(result),
        }
    }
}

impl&lt;F: Field&gt; Mul&lt;Polynomial&lt;F&gt;&gt; for Polynomial&lt;F&gt; {
    type Output = Self;

    fn mul(self, other: Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        self.mul_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lemma-231"><a class="header" href="#lemma-231">Lemma 2.3.1</a></h3>
<p>Let \(K\) be a field.</p>
<hr />
<p><em>Let \(f, g \in K[x]\) be non-zero polynomials. Then, \(\deg(fg) = \deg f + \deg g\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x^2 + 1\) and \(g(x) = x^3 - x\) in \(\mathbb{R}[x]\). Then, \(\deg(fg) = \deg(x^5 - x^3 + x^2 + 1) = 5 = 2 + 3 = \deg f + \deg g\)</p>
<h3 id="theorem-232"><a class="header" href="#theorem-232">Theorem 2.3.2</a></h3>
<p>We can also define division in the polynomial ring \(K[x]\).</p>
<hr />
<p><em>Let \(f, g \in K[x]\), with \(g \neq 0\). There exist unique polynomials \(q, r \in K[x]\) that satisfy \(f = qg + r\) and either \(\deg r &lt; \deg g\) or \(r = 0\).</em></p>
<hr />
<p><strong>Proof</strong>
TBD</p>
<p>\(q\) is called the quotient of \(f\) divided by \(g\), and \(r\) is called the remainder; we write \(r = f \bmod g\).</p>
<p><strong>Example:</strong> In \(\mathbb{R}[x]\), let \(f(x) = x^3 + 2x^2 - x + 3\) and \(g(x) = x^2 + 1\).  Then \(f = qg + r\) where \(q(x) = x + 2\) and \(r(x) = -3x + 1\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    fn div_rem_ref&lt;'b&gt;(&amp;self, other: &amp;'b Polynomial&lt;F&gt;) -&gt; (Polynomial&lt;F&gt;, Polynomial&lt;F&gt;) {
        if self.degree() &lt; other.degree() {
            return (Polynomial::zero(), self.clone());
        }

        let mut remainder_coeffs = Self::trim_trailing_zeros(self.coef.clone());
        let divisor_coeffs = Self::trim_trailing_zeros(other.coef.clone());
        let divisor_lead_inv = divisor_coeffs.last().unwrap().inverse();

        let mut quotient = vec![F::zero(); self.degree() as usize - other.degree() as usize + 1];

        while remainder_coeffs.len() &gt;= divisor_coeffs.len() {
            let lead_term = remainder_coeffs.last().unwrap().mul_ref(&amp;divisor_lead_inv);
            let deg_diff = remainder_coeffs.len() - divisor_coeffs.len();
            quotient[deg_diff] = lead_term.clone();

            for i in 0..divisor_coeffs.len() {
                remainder_coeffs[deg_diff + i] = remainder_coeffs[deg_diff + i]
                    .sub_ref(&amp;(lead_term.mul_ref(&amp;divisor_coeffs[i])));
            }
            remainder_coeffs = Self::trim_trailing_zeros(remainder_coeffs);
        }

        (
            Polynomial {
                coef: Self::trim_trailing_zeros(quotient),
            },
            Polynomial {
                coef: remainder_coeffs,
            },
        )
    }
}

impl&lt;F: Field&gt; Div for Polynomial&lt;F&gt; {
    type Output = Self;

    fn div(self, other: Polynomial&lt;F&gt;) -&gt; Polynomial&lt;F&gt; {
        self.div_rem_ref(&amp;other).0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="corollary"><a class="header" href="#corollary">Corollary</a></h3>
<hr />
<p><em>Let \(f \in K[x]\) be a non-zero polynomial, and \(a \in K\) such that \(f(a) = 0\). Then, there exists a polynomial \(q \in K[x]\) such that \(f(x) = (x - a)q(x)\). In other words, \((x - a)\) is a factor of \(f(x)\).</em></p>
<hr />
<p><strong>Example:</strong> Let \(f(x) = x^2 + 1 \in (\mathbb{Z}/2\mathbb{Z})[x]\). We have \(f(1) = 1^2 + 1 = 0\) in \(\mathbb{Z}/2\mathbb{Z}\), and indeed: \(x^2 + 1 = (x - 1)^2 = x^2 - 2x + 1 = x^2 + 1\) in \((\mathbb{Z}/2\mathbb{Z})[x]\)</p>
<h3 id="theorem-lagrange-interpolation"><a class="header" href="#theorem-lagrange-interpolation">Theorem: Lagrange Interpolation</a></h3>
<hr />
<p><em>A \(n\)-degre polynomial \(P(x)\) that goes through different \(n + 1\) points \(\{(x_1, y_1), (x_2, y_2), \cdots (x_{n + 1}, y_{n + 1})\}\) is uniquely represented as follows:</em></p>
<p>\[
P(x) = \sum^{n+1}_{i=1} y_i \frac{f_i(x)}{f_i(x_i)}
\]</p>
<p><em>, where \(f_i(x) = \prod_{k \neq i} (x - x_k)\)</em></p>
<hr />
<p><strong>Proof</strong> TBD</p>
<p><strong>Example:</strong> The quadratic polynomial that goes through \(\{(1, 0), (2, 3), (3, 8)\}\) is as follows:</p>
<p>\begin{align*}
P(x) = 0 \frac{(x - 2)(x - 3)}{(1 - 2) (1 - 3)} + 3 \frac{(x - 1)(x - 3)}{(2 - 1) (2 - 3)} + 8 \frac{(x - 1)(x - 2)}{(3 - 1) (3 - 2)} = x^{2} - 1
\end{align*}</p>
<p>Note that Lagrange interpolation finds the lowest degree of interpolating polynomial for the given vector.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field&gt; Polynomial&lt;F&gt; {
    pub fn interpolate(x_values: &amp;[F], y_values: &amp;[F]) -&gt; Polynomial&lt;F&gt; {
        let mut lagrange_polys = vec![];
        let numerators = Polynomial::from_monomials(x_values);

        for j in 0..x_values.len() {
            let mut denominator = F::one();
            for i in 0..x_values.len() {
                if i != j {
                    denominator = denominator * (x_values[j].sub_ref(&amp;x_values[i]));
                }
            }
            let cur_poly = numerators
                .clone()
                .div(Polynomial::from_monomials(&amp;[x_values[j].clone()]) * denominator);
            lagrange_polys.push(cur_poly);
        }

        let mut result = Polynomial { coef: vec![] };
        for (j, lagrange_poly) in lagrange_polys.iter().enumerate() {
            result = result + lagrange_poly.clone() * y_values[j].clone();
        }
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="proposition-homomorphisms-of-lagrange-interpolation"><a class="header" href="#proposition-homomorphisms-of-lagrange-interpolation">Proposition: Homomorphisms of Lagrange Interpolation</a></h3>
<p><em>Let \(L(v)\) and \(L(w)\) be the polynomial resulting from Lagrange Interpolation on the output (\(y\)) vector \(v\) and \(w\) for the same inputs (\(x\)). Then, the following properties hold:</em></p>
<ul>
<li><em>Additivity: \(L(v + w) = L(v) + L(w)\) for any vectors \(v\) and \(w\)</em></li>
<li><em>Scalar multiplication: \(L(\gamma v) = \gamma L(v)\) for any scalar \(\gamma\) and vector \(v\)</em></li>
</ul>
<p><strong>Proof</strong></p>
<p>Let \(v = (v_1, \ldots, v_n)\) and \(w = (w_1, \ldots, w_n)\) be vectors, and \(x_1, \ldots, x_n\) be the interpolation points.</p>
<p>\begin{align*}
L(v + w) &amp;= \sum_{i=1}^n (v_i + w_i) \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \sum_{i=1}^n v_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} + \sum_{i=1}^n w_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = L(v) + L(w) \\
L(\gamma v) &amp;= \sum_{i=1}^n (\gamma v_i) \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \gamma \sum_{i=1}^n v_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} = \gamma L(v)
\end{align*}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="galois-field"><a class="header" href="#galois-field">Galois Field</a></h1>
<p>We will now discuss the construction of finite fields with \(p^n\) elements, where \(p\) is a prime number and \(n\) is a positive integer. These fields are also known as Galois fields, denoted as \(GF(p^n)\). It is evident that \(\mathbb{Z}/p\mathbb{Z}\) is isomorphic to \(GF(p)\).</p>
<h3 id="definition-irreducible-polynomial"><a class="header" href="#definition-irreducible-polynomial">Definition: Irreducible Polynomial</a></h3>
<hr />
<p><em>A polynomial \(f \in (\mathbb{Z}/p\mathbb{Z})[X]\) of degree \(n\) is called irreducible over \(\mathbb{Z}/p\mathbb{Z}\) if it cannot be factored as a product of two polynomials of lower degree in \((\mathbb{Z}/p\mathbb{Z})[X]\).</em></p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/2\mathbb{Z})[X]\):</p>
<ul>
<li>\(X^2 + X + 1\) is irreducible</li>
<li>\(X^2 + 1 = (X + 1)^2\) is reducible</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IrreduciblePoly&lt;F: Field&gt;: Debug + Clone + Hash {
    fn modulus() -&gt; &amp;'static Polynomial&lt;F&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-residue-class-modulo-a-polynomial"><a class="header" href="#definition-residue-class-modulo-a-polynomial">Definition: Residue Class modulo a Polynomial</a></h3>
<p>To construct \(GF(p^n)\), we use an irreducible polynomial of degree \(n\) over \(\mathbb{Z}/p\mathbb{Z}\).</p>
<hr />
<p><em>For \(f, g \in (\mathbb{Z}/p\mathbb{Z})[X]\), the residue class of \(g \bmod f\) is the set of all polynomials \(h \in (\mathbb{Z}/p\mathbb{Z})[X]\) such that \(h \equiv g \pmod{f}\). This class is denoted as:</em></p>
<p>\[ g + f(\mathbb{Z}/p\mathbb{Z})[X] = \{g + hf : h \in (\mathbb{Z}/p\mathbb{Z})[X]\} \]</p>
<hr />
<p><strong>Example:</strong> In \((\mathbb{Z}/2\mathbb{Z})[X]\), with \(f(X) = X^2 + X + 1\), the residue classes \(\bmod f\) are:</p>
<ul>
<li>\(0 + f(\mathbb{Z}/2\mathbb{Z})[X] = \{0, X^2 + X + 1, X^2 + X, X^2 + 1, X^2, X + 1, X, 1\}\)</li>
<li>\(1 + f(\mathbb{Z}/2\mathbb{Z})[X] = \{1, X^2 + X, X^2 + 1, X^2, X + 1, X, 0, X^2 + X + 1\}\)</li>
<li>\(X + f(\mathbb{Z}/2\mathbb{Z})[X] = \{X, X^2 + 1, X^2, X^2 + X + 1, X + 1, 1, X^2 + X, 0\}\)</li>
<li>\((X + 1) + f(\mathbb{Z}/2\mathbb{Z})[X] = \{X + 1, X^2, X^2 + X + 1, X^2 + X, 1, 0, X^2 + 1, X\}\)</li>
</ul>
<p>These four residue classes form \(GF(4)\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt;
    ExtendedFieldElement&lt;M, P&gt;
{
    pub fn new(poly: Polynomial&lt;FiniteFieldElement&lt;M&gt;&gt;) -&gt; Self {
        let result = Self {
            poly: poly,
            _phantom: PhantomData,
        };
        result.reduce()
    }

    fn reduce(&amp;self) -&gt; Self {
        Self {
            poly: &amp;self.poly.reduce() % P::modulus(),
            _phantom: PhantomData,
        }
    }

    pub fn degree(&amp;self) -&gt; isize {
        P::modulus().degree()
    }

    pub fn from_base_field(value: FiniteFieldElement&lt;M&gt;) -&gt; Self {
        Self::new((Polynomial { coef: vec![value] }).reduce()).reduce()
    }
}

impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt; Field
    for ExtendedFieldElement&lt;M, P&gt;
{
    fn inverse(&amp;self) -&gt; Self {
        let mut lm = Polynomial::&lt;FiniteFieldElement&lt;M&gt;&gt;::one();
        let mut hm = Polynomial::zero();
        let mut low = self.poly.clone();
        let mut high = P::modulus().clone();

        while !low.is_zero() {
            let q = &amp;high / &amp;low;
            let r = &amp;high % &amp;low;
            let nm = hm - (&amp;lm * &amp;q);
            high = low;
            hm = lm;
            low = r;
            lm = nm;
        }

        Self::new(hm * high.coef[0].inverse())
    }

    fn div_ref(&amp;self, other: &amp;Self) -&gt; Self {
        self.mul_ref(&amp;other.inverse())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="theorem"><a class="header" href="#theorem">Theorem:</a></h3>
<hr />
<p><em>If \(f \in (\mathbb{Z}/p\mathbb{Z})[X]\) is an irreducible polynomial of degree \(n\), then the residue ring \((\mathbb{Z}/p\mathbb{Z})[X]/(f)\) is a field with \(p^n\) elements, isomorphic to \(GF(p^n)\).</em></p>
<hr />
<p><strong>Proof</strong> (Outline) The irreducibility of \(f\) ensures that \((f)\) is a maximal ideal in \((\mathbb{Z}/p\mathbb{Z})[X]\), making the quotient ring a field. The number of elements is \(p^n\) because there are \(p^n\) polynomials of degree less than \(n\) over \(\mathbb{Z}/p\mathbb{Z}\).</p>
<p>This construction allows us to represent elements of \(GF(p^n)\) as polynomials of degree less than \(n\) over \(\mathbb{Z}/p\mathbb{Z}\). Addition is performed coefficient-wise modulo \(p\), while multiplication is performed modulo the irreducible polynomial \(f\).</p>
<p><strong>Example:</strong> To construct \(GF(8)\), we can use the irreducible polynomial \(f(X) = X^3 + X + 1\) over \(\mathbb{Z}/2\mathbb{Z}\). The elements of \(GF(8)\) are represented by:
\[ \{0, 1, X, X+1, X^2, X^2+1, X^2+X, X^2+X+1\} \]
For instance, multiplication in \(GF(8)\):
\[ (X^2 + 1)(X + 1) = X^3 + X^2 + X + 1 \equiv X^2 \pmod{X^3 + X + 1} \]</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: ModulusValue + 'static, P: IrreduciblePoly&lt;FiniteFieldElement&lt;M&gt;&gt;&gt; Ring
    for ExtendedFieldElement&lt;M, P&gt;
{
    fn add_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly + &amp;other.poly)
    }

    fn mul_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly * &amp;other.poly)
    }

    fn sub_ref(&amp;self, other: &amp;Self) -&gt; Self {
        Self::new(&amp;self.poly - &amp;other.poly)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lemma-schwartz---zippel-lemma"><a class="header" href="#lemma-schwartz---zippel-lemma">Lemma: Schwartz - Zippel Lemma</a></h3>
<hr />
<p><em>Let \(\mathbb{F}\) be a field and \(P: F^m \rightarrow \mathbb{F}\) and \(Q: \mathbb{F}^m \rightarrow \mathbb{F}\) be two distinct multivariate polynomials of total degree at most \(n\). For any finite subset \(\mathbb{S} \subseteq \mathbb{F}\), we have:</em></p>
<p>\begin{align}
Pr_{u \sim \mathbb{S}^{m}}[P(u) = Q(u)] \leq \frac{n}{|\mathbb{S}|}
\end{align}</p>
<p><em>, where \(u\) is drawn uniformly at random from \(\mathbb{S}^m\).</em></p>
<hr />
<p><strong>Proof</strong> TBD</p>
<p>This lemma states that if \(\mathbb{S}\) is sufficiently large and \(n\) is relatively small, the probability that the two different polynomials return the same value for a randomly chosen input is negligibly small. In other words, if we observe \(P(u) = Q(u)\) for a random input \(u\), we can conclude with high probability that \(P\) and \(Q\) are identical polynomials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elliptic-curve"><a class="header" href="#elliptic-curve">Elliptic curve</a></h1>
<h3 id="definition-elliptic-curve"><a class="header" href="#definition-elliptic-curve">Definition: Elliptic Curve</a></h3>
<hr />
<p><em>An elliptic curve \(E\) over a finite field \(\mathbb{F}_{p}\) is defined by the equation:</em></p>
<p>\begin{equation}
y^2 = x^3 + a x + b
\end{equation}</p>
<p><em>, where \(a, b \in \mathbb{F}_{p}\) and the discriminant \(\Delta_{E} = 4a^3 + 27b^2 \neq 0\).</em></p>
<hr />
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait EllipticCurve: Debug + Clone + PartialEq {
    fn get_a() -&gt; BigInt;
    fn get_b() -&gt; BigInt;
}

#[derive(Debug, Clone, PartialEq)]
pub struct EllipticCurvePoint&lt;F: Field, E: EllipticCurve&gt; {
    pub x: Option&lt;F&gt;,
    pub y: Option&lt;F&gt;,
    _phantom: PhantomData&lt;E&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-mathbbf_p-rational-point"><a class="header" href="#definition-mathbbf_p-rational-point">Definition: \(\mathbb{F}_{p}\)-Rational Point</a></h3>
<hr />
<p><em>An \(\mathbb{F}_{p}\)-rational point on an elliptic curve \(E\) is a point \((x, y)\) where both \(x\) and \(y\) are elements of \(\mathbb{F}_{p}\) and satisfy the curve equation, or the point at infinity \(\mathcal{O}\).</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + 3x + 4\) over \(\mathbb{F}_7\), the \(\mathbb{F}_{7}\)-rational points are:
\(\{(0, 2), (0, 5), (1, 1), (1, 6), (2, 2), (2, 5), (5, 1), (5, 6), \mathcal{O}\}\)</p>
<h3 id="definition-the-point-at-infinity"><a class="header" href="#definition-the-point-at-infinity">Definition: The point at infinity</a></h3>
<hr />
<p>The point at infinity denoted \(\mathcal{O}\), is a special point on the elliptic curve that serves as the identity element for the group operation. It can be visualized as the point where all vertical lines on the curve meet.</p>
<hr />
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field, E: EllipticCurve&gt; EllipticCurvePoint&lt;F, E&gt; {
    pub fn point_at_infinity() -&gt; Self {
        EllipticCurvePoint {
            x: None,
            y: None,
            _phantom: PhantomData,
        }
    }

    pub fn is_point_at_infinity(&amp;self) -&gt; bool {
        self.x.is_none() || self.y.is_none()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-addition-on-elliptic-curve"><a class="header" href="#definition-addition-on-elliptic-curve">Definition: Addition on Elliptic Curve</a></h3>
<hr />
<p><em>For an elliptic curve \(E: y^2 = x^3 + ax + b\), the addition of points \(P\) and \(Q\) to get \(R = P + Q\) is defined as follows:</em></p>
<ul>
<li>
<p><em>If \(P = \mathcal{O}\), \(R = Q\).</em></p>
</li>
<li>
<p><em>If \(Q = \mathcal{O}\), \(R = P\).</em></p>
</li>
<li>
<p><em>Otherwise, let \(P = (x_P, y_P), Q = (x_Q, y_Q)\). Then:</em></p>
<ul>
<li><em>If \(y_P = -y_Q\), \(R = \mathcal{O}\)</em></li>
<li><em>If \(y_P \neq -y_Q\), \(R = (x_R = \lambda^2 - x_P - x_Q, y_R = \lambda(x_P - x_R) - y_P)\), where \(\lambda = \)</em> \( \begin{cases}
\frac{y_P - y_Q}{x_P - x_Q} \quad &amp;\hbox{If } (x_P \neq x_Q) \\
\frac{3^{2}_{P} + a}{2y_P} \quad &amp;\hbox{Otherwise}
\end{cases}\)</li>
</ul>
</li>
</ul>
<hr />
<p><strong>Example:</strong> On \(E: y^2 = x^3 + 2x + 3\) over \(\mathbb{F}_{7}\), let \(P = (5, 1)\) and \(Q = (4, 4)\). Then, \(P + Q = (0, 5)\), where \(\lambda = \frac{1 - 4}{5 - 4} \equiv 4 \bmod 7\).</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F: Field, E: EllipticCurve&gt; EllipticCurvePoint&lt;F, E&gt; {
    pub fn add_ref(&amp;self, other: &amp;Self) -&gt; Self {
        if self.is_point_at_infinity() {
            return other.clone();
        }
        if other.is_point_at_infinity() {
            return self.clone();
        }

        if self.x == other.x &amp;&amp; self.y == other.y {
            return self.double();
        } else if self.x == other.x {
            return Self::point_at_infinity();
        }

        let slope = self.line_slope(&amp;other);
        let x1 = self.x.as_ref().unwrap();
        let y1 = self.y.as_ref().unwrap();
        let x2 = other.x.as_ref().unwrap();
        let y2 = other.y.as_ref().unwrap();

        let new_x = slope.mul_ref(&amp;slope).sub_ref(&amp;x1).sub_ref(&amp;x2);
        let new_y = ((-slope.clone()).mul_ref(&amp;new_x)) + (&amp;slope.mul_ref(&amp;x1).sub_ref(&amp;y1));
        assert!(new_y == -slope.clone() * &amp;new_x + slope.mul_ref(&amp;x2).sub_ref(&amp;y2));

        Self::new(new_x, new_y)
    }
}

impl&lt;F: Field, E: EllipticCurve&gt; Add for EllipticCurvePoint&lt;F, E&gt; {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        self.add_ref(&amp;other)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="definition-mordell-weil-group"><a class="header" href="#definition-mordell-weil-group">Definition: Mordell-Weil Group</a></h3>
<hr />
<p><em>The Mordell-Weil group of an elliptic curve \(E\) is the group of rational points on \(E\) under the addition operation defined above.</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + x + 6\) over \(\mathbb{F}_{11}\), the Mordell-Weil group is the set of all \(\mathbb{F}_{11}\)-rational points on \(E\) with the elliptic curve addition operation.</p>
<h3 id="definition-group-order"><a class="header" href="#definition-group-order">Definition: Group Order</a></h3>
<hr />
<p><em>The group order of an elliptic curve \(E\) over \(\mathbb{F}_{p}\), denoted \(\#E(\mathbb{F}_{p})\), is the number of \(\mathbb{F}_{p}\)-rational points on \(E\), including the point at infinity.</em></p>
<hr />
<p>Example: For \(E: y^2 = x^3 + x + 6\) over \(\mathbb{F}_{11}\), \(\#E(\mathbb{F}_{11}) = 13\).</p>
<h3 id="theorem-hasse-weil"><a class="header" href="#theorem-hasse-weil">Theorem: Hasse-Weil</a></h3>
<hr />
<p><em>Let \(\#E(\mathbb{F}_{p})\) be the group order of the elliptic curve \(E\) over \(\mathbb{F}_{p}\). Then:</em></p>
<p>\begin{equation}
p + 1 - 2 \sqrt{p} \leq \#E \leq p + 1 + 2 \sqrt{p}
\end{equation}</p>
<hr />
<p><strong>Example:</strong> For an elliptic curve over \(\mathbb{F}_{23}\), the Hasse-Weil theorem guarantees that:</p>
<p>\begin{equation*}
23 + 1 - 2 \sqrt{23} \simeq 14.42 \#E(\mathbb{F}_{23}) \geq 23 + 1 + 2 \sqrt{23} \simeq 33.58
\end{equation*}</p>
<h3 id="definition-point-order"><a class="header" href="#definition-point-order">Definition: Point Order</a></h3>
<p>The order of a point \(P\) on an elliptic curve is the smallest positive integer \(n\) such that \(nP = \mathcal{O}\) (where \(nP\) denotes \(P\) added to itself \(n\) times). We also denote the set of points of order \(n\), also called \textit{torsion} group, by</p>
<p>\begin{equation}
E[n] = \{P \in E: [n]P = \mathcal{O}\}
\end{equation}</p>
<p>Example: On \(E: y^2 = x^3 + 2x + 2\) over \(\mathbb{F}_{17}\), the point \(P = (5, 1)\) has order 18 because \(18P = \mathcal{O}\), and no smaller positive multiple of \(P\) equals \(\mathcal{O}\).</p>
<p>The intuitive view is that if you continue to add points to themselves (doubling, tripling, etc.), the lines drawn between the prior point and the next point will eventually become more vertical. When the line becomes vertical, it does not intersect the elliptic curve at any finite point. In elliptic curve geometry, a vertical line is considered to "intersect" the curve at a special place called the "point at infinity," This point is like a north pole in geographic terms: no matter which direction you go, if the line becomes vertical (reaching infinitely high), it converges to this point.</p>
<h3 id="definition-field-extension"><a class="header" href="#definition-field-extension">Definition: Field Extension</a></h3>
<hr />
<p><em>Let \(F\) and \(L\) be fields. If \(F \subseteq L\) and the operations of \(F\) are the same as those of \(L\), we call \(L\) a field extension of \(F\). This is denoted as \(L/F\).</em></p>
<hr />
<p>A field extension \(L/F\) naturally gives \(L\) the structure of a vector space over \(F\). The dimension of this vector space is called the degree of the extension.</p>
<p><strong>Examples:</strong></p>
<ul>
<li>\(\mathbb{C}/\mathbb{R}\) is a field extension with basis \(\{1, i\}\) and degree 2.</li>
<li>\(\mathbb{R}/\mathbb{Q}\) is an infinite degree extension.</li>
<li>\(\mathbb{Q}(\sqrt{2})/\mathbb{Q}\) is a degree 2 extension with basis \(\{1, \sqrt{2}\}\).</li>
</ul>
<h3 id="definition-algebraic-extension"><a class="header" href="#definition-algebraic-extension">Definition: Algebraic Extension</a></h3>
<hr />
<p><em>A field extension \(L/K\) is called algebraic if every element \(\alpha \in L\) is algebraic over \(K\), i.e., \(\alpha\) is the root of some non-zero polynomial with coefficients in \(K\).</em></p>
<p><em>For an algebraic element \(\alpha \in L\) over \(K\), we denote by \(K(\alpha)\) the smallest field containing both \(K\) and \(\alpha\).</em></p>
<hr />
<p><strong>Example:</strong></p>
<ul>
<li>\(\mathbb{C}/\mathbb{R}\) is algebraic: any \(z = a + bi \in \mathbb{C}\) is a root of \(x^2 - 2ax + (a^2 + b^2) \in \mathbb{R}[x]\).</li>
<li>\(\mathbb{Q}(\sqrt[3]{2})/\mathbb{Q}\) is algebraic: \(\sqrt[3]{2}\) is a root of \(x^3 - 2 \in \mathbb{Q}[x]\).</li>
<li>\(\mathbb{R}/\mathbb{Q}\) is not algebraic (a field extension that is not algebraic is called \textit{transcendental}).</li>
</ul>
<h3 id="definition-field-of-rational-functions"><a class="header" href="#definition-field-of-rational-functions">Definition: Field of Rational Functions</a></h3>
<hr />
<p><em>Let \(K\) be a field and \(X\) be indeterminate. The field of rational functions over \(K\), denoted \(K(X)\), is defined as:</em></p>
<p>\begin{equation*}
K(X) = \left\{ \frac{f(X)}{g(X)} \middle|\ f(X), g(X) \in K[X], g(X) \neq 0 \right\}
\end{equation*}</p>
<p><em>where \(K[X]\) is the ring of polynomials in \(X\) with coefficients in \(K\).</em></p>
<hr />
<p>\(K(X)\) can be viewed as the field obtained by adjoining a letter \(X\) to \(K\). This construction generalizes to multiple variables, e.g., \(K(X,Y)\).</p>
<p>The concept of a function field naturally arises in the context of algebraic curves, particularly elliptic curves. Intuitively, the function field encapsulates the algebraic structure of rational functions on the curve.</p>
<p>We first construct the coordinate ring for an elliptic curve \(E: y^2 = x^3 + ax + b\). Consider functions \(X: E \to K\) and \(Y: E \to K\) that extract the \(x\) and \(y\) coordinates, respectively, from an arbitrary point \(P \in E\). These functions generate the polynomial ring \(K[X,Y]\), subject to the relation \(Y^2 = X^3 + aX + b\).</p>
<p>To put it simply, the function field is a field that consists of all functions that determine the value based on the point on the curve.</p>
<h3 id="definition-coordinate-ring-of-an-elliptic-curve"><a class="header" href="#definition-coordinate-ring-of-an-elliptic-curve">Definition: Coordinate Ring of an Elliptic Curve</a></h3>
<hr />
<p><em>The <strong>coordinate ring</strong> of an elliptic curve \(E: y^2 = x^3 + ax + b\) over a field \(K\) is defined as:</em>
\begin{equation}
K[E] = K[X, Y]/(Y^2 - X^3 - aX - b)
\end{equation}</p>
<hr />
<p>In other words, we can view \(K[E]\) as a ring representing all polynomial functions on \(E\). Recall that \(K[X, Y]\) is the polynomial ring in two variables \(X\) and \(Y\) over the field K, meaning that it contains all polynomials in \(X\) and \(Y\) with coefficients from \(K\). Then, the notation \(K[X, Y]/(Y^2 - X^3 - aX - b)\) denotes the quotient ring obtained by taking \(K[X, Y]\) and "modding out" by the ideal \((Y^2 - X^3 - aX - b)\).</p>
<p><strong>Example</strong> For example, for an elliptic curve \(E: y^2 = x^3 - x\) over \(\mathbb{Q}\), some elements of the coordinate ring \(\mathbb{Q}[E]\) include:</p>
<ul>
<li>Constants: \(3, -2, \frac{1}{7}, \ldots\)</li>
<li>Linear functions: \(X, Y, 2X+3Y, \ldots\)</li>
<li>Quadratic functions: \(X^2, XY, Y^2 (= X^3 - X), \ldots\)</li>
<li>Higher-degree functions: \(X^3, X^2Y, XY^2 (= X^4 - X^2), \ldots\)</li>
</ul>
<h3 id="definition-function-field-of-an-elliptic-curve"><a class="header" href="#definition-function-field-of-an-elliptic-curve">Definition: Function Field of an Elliptic Curve</a></h3>
<p>Then, the function field is defined as follows:</p>
<hr />
<p><em>Let \(E: y^2 = x^3 + ax + b\) be an elliptic curve over a field \(K\). The <strong>function field</strong> of \(E\), denoted \(K(E)\), is defined as:</em>
\begin{equation}
K(E) = \left\{\frac{f}{g} ,\middle|, f, g \in K[E], g \neq 0 \right\}
\end{equation}
<em>where \(K[E] = K[X, Y]/(Y^2 - X^3 - aX - b)\) is the coordinate ring of \(E\).</em></p>
<hr />
<p>\(K(E)\) can be viewed as the field of all rational functions on \(E\).</p>
<h3 id="definition-zeropole-of-a-function"><a class="header" href="#definition-zeropole-of-a-function">Definition: Zero/Pole of a Function</a></h3>
<hr />
<p><em>Let \(h \in K(E)\) be a non-zero function. A point \(P \in E\) is called a <strong>zero</strong> of \(h\) if \(h(P) = 0\).</em></p>
<hr />
<hr />
<p><em>Let \(h \in K(E)\) be a non-zero function. A point \(P \in E\) is called a <strong>pole</strong> of \(h\) if \(h\) is not defined at \(P\) or, equivalently if \(1/h\) has a zero at \(P\).</em></p>
<hr />
<p><strong>Example</strong> Consider the elliptic curve \(E: Y^2 = X^3 - X\) over a field \(K\) of characteristic \(\neq 2, 3\). Let \(P_{-1} = (-1, 0)\), \(P_0 = (0, 0)\), and \(P_1 = (1, 0)\) be the points where \(Y = 0\).</p>
<ul>
<li>The function \(Y \in K(E)\) has three simple zeros: \(P_{-1}\), \(P_0\), and \(P_1\).</li>
<li>The function \(X \in K(E)\) has a double zero at \(P_0\) (since \(P_0 = -P_0\)).</li>
<li>The function \(X - 1 \in K(E)\) has a simple zero at \(P_1\).</li>
<li>The function \(X^2 - 1 \in K(E)\) has two simple zeros at \(P_{-1}\) and \(P_1\).</li>
<li>The function \(\frac{Y}{X} \in K(E)\) has a simple zero at \(P_{-1}\) and a simple pole at \(P_0\).</li>
</ul>
<p>An important property of functions in \(K(E)\) is that they have the same number of zeros and poles when counted with multiplicity. This is a consequence of a more general result known as the Degree-Genus Formula.</p>
<h3 id="theorem-degree-genus-formula-for-elliptic-curves"><a class="header" href="#theorem-degree-genus-formula-for-elliptic-curves">Theorem: Degree-Genus Formula for Elliptic Curves</a></h3>
<hr />
<p><em>Let \(f \in K(E)\) be a non-zero rational function on an elliptic curve \(E\). Then:</em></p>
<p>\begin{equation}
\sum_{P \in E} ord_{P(f)} = 0
\end{equation}</p>
<p><em>, where \(ord_{P(f)}\) denotes the order of \(f\) at \(P\), which is positive for zeros and negative for poles.</em></p>
<hr />
<p>This theorem implies that the total number of zeros (counting multiplicity) equals the total number of poles for any non-zero function in \(K(E)\).</p>
<p>We now introduce a powerful tool for analyzing functions on elliptic curves: the concept of divisors.</p>
<h3 id="definition-divisor-of-a-function-on-an-elliptic-curve"><a class="header" href="#definition-divisor-of-a-function-on-an-elliptic-curve">Definition: Divisor of a Function on an Elliptic Curve</a></h3>
<hr />
<p><em>Let \(E: Y^2 = X^3 + AX + B\) be an elliptic curve over a field \(K\), and let \(f \in K(E)\) be a non-zero rational function on \(E\). The <strong>divisor</strong> of \(f\), denoted \(div(f)\), is defined as:</em>
\begin{equation}
div(f) = \sum_{P \in E} ord_P(f) [P]
\end{equation}
<em>, where \(ord_P(f)\) is the order of \(f\) at \(P\) (positive for zeros, negative for poles), and the sum is taken over all points \(P \in E\), including the point at infinity. This sum has only finitely many non-zero terms.</em></p>
<hr />
<p>Note that this \(\sum_{P \in E}\) is a symbolic summation, and we do not calculate the concrete numerical value of a divisor.</p>
<p><strong>Example</strong> Consider the elliptic curve \(E: Y^2 = X^3 - X\) over \(\mathbb{Q}\).</p>
<ul>
<li>For \(f = X\), we have \(div(X) = 2[(0,0)] - 2[\mathcal{O}]\).</li>
<li>For \(g = Y\), we have \(div(Y) = [(1,0)] + [(0,0)] + [(-1,0)] - 3[\mathcal{O}]\).</li>
<li>For \(h = \frac{X-1}{Y}\), we have \(div(h) = [(1,0)] - [(-1,0)]\).</li>
</ul>
<h3 id="definition-divisor-on-an-elliptic-curve"><a class="header" href="#definition-divisor-on-an-elliptic-curve">Definition: Divisor on an Elliptic Curve</a></h3>
<p>The concept of divisors can be extended to the elliptic curve itself:</p>
<hr />
<p><em>A <strong>divisor</strong> \(D\) on an elliptic curve \(E\) is a formal sum</em>
\begin{equation}
D = \sum_{P \in E} n_P [P]
\end{equation}
<em>where \(n_P \in \mathbb{Z}\) and \(n_P = 0\) for all but finitely many \(P\).</em></p>
<hr />
<p><strong>Example</strong> On the curve \(E: Y^2 = X^3 - X\):</p>
<ul>
<li>\(D_1 = 3[(0,0)] - 2[(1,1)] - [(2,\sqrt{6})]\) is a divisor.</li>
<li>\(D_2 = [(1,0)] + [(-1,0)] - 2[\mathcal{O}]\) is a divisor.</li>
<li>\(D_3 = \sum_{P \in E[2]} [P] - 4[\mathcal{O}]\) is a divisor (where \(E[2]\) are the 2-torsion points).</li>
</ul>
<p>To quantify the properties of divisors, we introduce two important metrics:</p>
<h3 id="definition-degreesum-of-a-divisor"><a class="header" href="#definition-degreesum-of-a-divisor">Definition: Degree/Sum of a Divisor</a></h3>
<hr />
<p><em>The <strong>degree</strong> of a divisor \(D = \sum_{P \in E} n_P [P]\) is defined as:</em>
\begin{equation}
deg(D) = \sum_{P \in E} n_P
\end{equation}</p>
<hr />
<hr />
<p><em>The <strong>sum</strong> of a divisor \(D = \sum_{P \in E} n_P [P]\) is defined as:</em>
\begin{equation}
Sum(D) = \sum_{P \in E} n_P P
\end{equation}
<em>where \(n_P P\) denotes the point addition of \(P\) to itself \(n_P\) times in the group law of \(E\).</em></p>
<hr />
<p><strong>Example</strong> For the divisors in the previous example:</p>
<ul>
<li>\(deg(D_1) = 3 - 2 - 1 = 0\)</li>
<li>\(deg(D_2) = 1 + 1 - 2 = 0\)</li>
<li>\(deg(D_3) = 4 - 4 = 0\)</li>
<li>\(Sum(D_2) = (1,0) + (-1,0) - 2\mathcal{O} = \mathcal{O}\) (since \((1,0)\) and \((-1,0)\) are 2-torsion points)</li>
</ul>
<h3 id="theorem-1"><a class="header" href="#theorem-1">Theorem</a></h3>
<p>The following theorem characterizes divisors of functions and provides a criterion for when a divisor is the divisor of a function:</p>
<hr />
<p><em>Let \(E\) be an elliptic curve over a field \(K\).</em></p>
<ul>
<li><em>If \(f, f' \in K(E)\) are non-zero rational functions on \(E\) with \(div(f) = div(f')\), then there exists a non-zero constant \(c \in K^*\) such that \(f = cf'\).</em></li>
<li><em>A divisor \(D\) on \(E\) is the divisor of a rational function on \(E\) if and only if \(deg(D) = 0\) and \(Sum(D) = \mathcal{O}\).</em></li>
</ul>
<hr />
<p><strong>Example</strong> On \(E: Y^2 = X^3 - X\):</p>
<ul>
<li>The function \(f = \frac{Y}{X}\) has \(div(f) = [(1,0)] + [(-1,0)] - 2[(0,0)]\). Note that \(deg(div(f)) = 0\) and \(Sum(div(f)) = (1,0) + (-1,0) - 2(0,0) = \mathcal{O}\).</li>
<li>The divisor \(D = 2[(1,1)] - [(2,\sqrt{6})] - [(0,0)]\) has \(deg(D) = 0\), but \(Sum(D) \neq \mathcal{O}\). Therefore, \(D\) is not the divisor of any rational function on \(E\).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pairing"><a class="header" href="#pairing">Pairing</a></h1>
<h3 id="definition-pairing"><a class="header" href="#definition-pairing">Definition: Pairing</a></h3>
<hr />
<p><em>Let \(G_1\) and \(G_2\) be cyclic groups under addition, both of prime order \(p\), with generators \(P\) and \(Q\) respectively:</em></p>
<p>\begin{align}
G_1 &amp;= \{0, P, 2P, ..., (p-1)P\} \
G_2 &amp;= \{0, Q, 2Q, ..., (p-1)Q\}
\end{align}</p>
<p><em>Let \(G_T\) be a cyclic group under multiplication, also of order \(p\). A pairing is a map \(e: G_1 \times G_2 \rightarrow G_T\) that satisfies the following bilinear property:</em></p>
<p>\begin{equation}
e(aP, bQ) = e(P, Q)^{ab}
\end{equation} <em>for all \(a, b \in \mathbb{Z}_p\).</em></p>
<hr />
<p>Imagine \(G_1\) represents length, \(G_2\) represents width, and \(G_T\) represents area. The pairing function \(e\) is like calculating the area: If you double the length and triple the width, the area becomes six times larger: \(e(2P, 3Q) = e(P, Q)^{6}\)</p>
<h3 id="definition-the-weil-pairing"><a class="header" href="#definition-the-weil-pairing">Definition: The Weil Pairing</a></h3>
<p>The Weil pairing is one of the bilinear pairings for elliptic curves. We begin with its formal definition.</p>
<hr />
<p><em>Let \(E\) be an elliptic curve and \(n\) be a positive integer. For points \(P, Q \in E[n]\), where \(E[n]\) denotes the \(n\)-torsion subgroup of \(E\), we define the Weil pairing \(e_n(P, Q)\) as follows:</em></p>
<p>Let \(f_P\) and \(f_Q\) be rational functions on \(E\) satisfying:
\begin{align}
div(f_P) &amp;= n[P] - n[\mathcal{O}] \
div(f_Q) &amp;= n[Q] - n[\mathcal{O}]
\end{align}</p>
<p><em>Then, for an arbitrary point \(S \in E\) such that \(S \notin \{\mathcal{O}, P, -Q, P-Q\}\), the Weil pairing is given by:</em></p>
<p>\begin{equation}
e_n(P, Q) = \frac{f_P(Q + S)}{f_P(S)} /\ \frac{f_Q(P - S)}{f_Q(-S)}
\end{equation}</p>
<hr />
<p>We introduce a crucial theorem about a specific rational function on elliptic curves to construct the functions required for the Weil pairing.</p>
<h3 id="theorem-2"><a class="header" href="#theorem-2">Theorem</a></h3>
<hr />
<p><em>Let \(E\) be an elliptic curve over a field \(K\), and let \(P = (x_P, y_P)\) and \(Q = (x_Q, y_Q)\) be non-zero points on \(E\). Define \(\lambda\) as:</em></p>
<p>\begin{equation}
\lambda = \begin{cases}
\hbox{slope of the line through \(P\) and \(Q\)} &amp;\quad \hbox{if \(P \neq Q\)} \\
\hbox{slope of the tangent line to \(E\) at \(P\)} &amp;\quad \hbox{if \(P = Q\)} \\
\infty &amp;\quad \hbox{if the line is vertical}
\end{cases}
\end{equation}</p>
<p><em>Then, the function \(g_{P,Q}: E \to K\) defined by:</em>
\begin{equation}
g_{P,Q} = \begin{cases}
\frac{y - y_P - \lambda(x - x_P)}{x + x_P + x_Q - \lambda^2} &amp;\quad \hbox{if } \lambda \neq \infty \\
x - x_P &amp;\quad \hbox{if } \lambda = \infty
\end{cases}
\end{equation} <em>has the following divisor:</em></p>
<p>\begin{equation}
div(g_{P,Q}) = [P] + [Q] - [P + Q] - [\mathcal{O}]
\end{equation}</p>
<hr />
<p><strong>Proof:</strong> We consider two cases based on the value of \(\lambda\).</p>
<p>Case 1: \(\lambda \neq \infty\)</p>
<p>Let \(y = \lambda x + v\) be the line through \(P\) and \(Q\) (or the tangent line at \(P\) if \(P = Q\)). This line intersects \(E\) at three points: \(P\), \(Q\), and \(-P-Q\). Thus,
\begin{equation}
div(y - \lambda x - v) = [P] + [Q] + [-P - Q] - 3[\mathcal{O}]
\end{equation}
Vertical lines intersect \(E\) at points and their negatives, so:
\begin{equation}
div(x - x_{P+Q}) = [P + Q] + [-P - Q] - 2[\mathcal{O}]
\end{equation}
It follows that \(g_{P,Q} = \frac{y - \lambda x - v}{x - x_{P+Q}}\) has the desired divisor.</p>
<p>Case 2: \(\lambda = \infty\)</p>
<p>In this case, \(P + Q = \mathcal{O}\), so we want \(g_{P,Q}\) to have divisor \([P] + [-P] - 2[\mathcal{O}]\). The function \(x - x_P\) has this divisor.
\end{proof}</p>
<h3 id="theorem-millers-algorithm"><a class="header" href="#theorem-millers-algorithm">Theorem: Miller's Algorithm</a></h3>
<hr />
<p><em>Let \(m \geq 1\) and write its binary expansion as:</em>
\begin{equation}
m = m_0 + m_1 \cdot 2 + m_2 \cdot 2^2 + \cdots + m_{n-1} \cdot 2^{n-1}
\end{equation}
<em>where \(m_i \in \{0, 1\}\) and \(m_{n-1} \neq 0\).</em></p>
<p><em>The following algorithm, using the function \(g_{P,Q}\) defined in the previous theorem, returns a function \(f_P\) whose divisor satisfies:</em></p>
<p>\begin{equation}
div(f_P) = m[P] - m[P] - (m - 1)[\mathcal{O}]
\end{equation}</p>
<p>===========================</p>
<p><strong>Miller's Algorithm</strong></p>
<ol>
<li>Set \(T = P\) and \(f = 1\)</li>
<li><strong>For</strong> \(i \gets n-2 \cdots 0\) <strong>do</strong></li>
<li>    Set \(f = f^2 \cdot g_{T, T}\)</li>
<li>    Set \(T = 2T\)</li>
<li>    <strong>If</strong> \(m_i = 1\) <strong>then</strong></li>
<li>        Set \(f = f \cdot g_{T, P}\)</li>
<li>        Set \(T = T + P\)</li>
<li>    <strong>End if</strong></li>
<li><strong>End for</strong></li>
<li><strong>Return</strong> \(f\)</li>
</ol>
<p>===========================</p>
<hr />
<p><strong>Proof:</strong> TBD</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_lambda&lt;F: Field, E: EllipticCurve&gt;(
    p: &amp;EllipticCurvePoint&lt;F, E&gt;,
    q: &amp;EllipticCurvePoint&lt;F, E&gt;,
    r: &amp;EllipticCurvePoint&lt;F, E&gt;,
) -&gt; F {
    let p_x = p.x.as_ref().unwrap();
    let p_y = p.y.as_ref().unwrap();
    let q_x = q.x.as_ref().unwrap();
    // let q_y = q.y.clone().unwrap();
    let r_x = r.x.as_ref().unwrap();
    let r_y = r.y.as_ref().unwrap();

    if (p == q &amp;&amp; *p_y == F::zero()) || (p != q &amp;&amp; *p_x == *q_x) {
        return r_x.sub_ref(&amp;p_x);
    }
    let slope = p.line_slope(&amp;q);
    let numerator = (r_y.sub_ref(&amp;p_y)).sub_ref(&amp;slope.mul_ref(&amp;(r_x.sub_ref(&amp;p_x))));
    let denominator = r_x
        .add_ref(&amp;p_x)
        .add_ref(&amp;q_x)
        .sub_ref(&amp;slope.mul_ref(&amp;slope));
    return numerator / denominator;
}

pub fn miller&lt;F: Field, E: EllipticCurve&gt;(
    p: &amp;EllipticCurvePoint&lt;F, E&gt;,
    q: &amp;EllipticCurvePoint&lt;F, E&gt;,
    m: &amp;BigInt,
) -&gt; (F, EllipticCurvePoint&lt;F, E&gt;) {
    if p == q {
        return (F::one(), p.clone());
    }

    let mut f = F::one();
    let mut t = p.clone();

    for i in (0..(m.bits() - 1)).rev() {
        f = (f.mul_ref(&amp;f)) * (get_lambda(&amp;t, &amp;t, &amp;q));
        t = t.add_ref(&amp;t);
        if m.bit(i) {
            f = f * (get_lambda(&amp;t, &amp;p, &amp;q));
            t = t.add_ref(&amp;p);
        }
    }

    (f, t)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h1>
<h3 id="assumption-discrete-logarithm-problem"><a class="header" href="#assumption-discrete-logarithm-problem">Assumption: Discrete Logarithm Problem</a></h3>
<hr />
<p><em>Let \(G\) be a finite cyclic group of order \(n\), with \(\gamma\) as its generator and \(1\) as the identity element. For any element \(\alpha \in G\), there is currently no known efficient (polynomial-time) algorithm to compute the smallest non-negative integer \(x\) such that \(\alpha = \gamma^{x}\).</em></p>
<hr />
<p>The Discrete Logarithm Problem can be thought of as a one-way function. It's easy to compute \(g^{x}\) given \(g\) and \(x\), but it's computationally difficult to find \(x\) given \(g\) and \(g^{x}\).</p>
<h3 id="assumption-elliptic-curve-discrete-logarithm-problem"><a class="header" href="#assumption-elliptic-curve-discrete-logarithm-problem">Assumption: Elliptic Curve Discrete Logarithm Problem</a></h3>
<hr />
<p><em>Let \(E\) be an elliptic curve defined over a finite field \(\mathbb{F}_q\), where \(q\) is a prime power. Let \(P\) be a point on \(E\) of point order \(n\), and let \(\langle P \rangle\) be the cyclic subgroup of \(E\) generated by \(P\). For any element \(Q \in \langle P \rangle\), there is currently no known efficient (polynomial-time) algorithm to compute the unique integer \(k\), \(0 \leq k &lt; n\), such that \(Q = kP\).</em></p>
<hr />
<p>This assumption is an elliptic curve version of the Discrete Logarithm Problem.</p>
<h3 id="assumption-knowledge-of-exponent-assumption"><a class="header" href="#assumption-knowledge-of-exponent-assumption">Assumption: Knowledge of Exponent Assumption</a></h3>
<hr />
<p><em>Let \(G\) be a cyclic group of prime order \(q\) with generator \(g \in G\). For any probabilistic polynomial-time algorithm \(\mathcal{A}\) that outputs:</em></p>
<p>\begin{equation}
\mathcal{A}(g, g^x) = (h, h') \quad s.t. \quad h' = h^x
\end{equation}
<em>, there exists an efficient extractor \(\mathcal{E}\) such that:</em>
\begin{equation}
\mathcal{E}(\mathcal{A}, g, g^x) = y \quad s.t. \quad h = g^y
\end{equation}</p>
<hr />
<p>This assumption states that if \(\mathcal{A}\) can compute the pair \((g^y, g^{xy})\) from \((g, g^x)\), then \(\mathcal{A}\) must "know" the value \(y\), in the sense that \(\mathcal{E}\) can extract \(y\) from \(\mathcal{A}\)'s internal state.
The Knowledge of Exponent Assumption is useful for constructing verifiable exponential calculation algorithms. Consider a scenario where Alice has a secret value \(a\), and Bob has a secret value \(b\). Bob wants to obtain \(g^{ab}\). This can be achieved through the following protocol:</p>
<p><strong>Verifiable Exponential Calculation Algorithm</strong></p>
<ol>
<li>Bob sends \((g, g'=g^{b})\) to Alice</li>
<li>Alice sends \((h=g^{a}, h'=g'^{a})\) to Bob</li>
<li>Bob checks \(h^{b} = h'\).</li>
</ol>
<p>Thanks to the Discrete Logarithm Assumption and the Knowledge of Exponent Assumption, the following properties hold:</p>
<ul>
<li>Bob cannot derive \(a\) from \((h, h')\).</li>
<li>Alice cannot derive \(b\) from \((g, g')\).</li>
<li>Alice cannot generate \((t, t')\) such that \(t \neq h\) and \(t^{b} = t'\).</li>
<li>If \(h^{b} = h'\), Bob can conclude that \(h\) is the power of \(g\).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-zk-snark"><a class="header" href="#basics-of-zk-snark">Basics of zk-SNARK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetization"><a class="header" href="#arithmetization">Arithmetization</a></h1>
<p>The ultimate goal of Zero-Knowledge Proofs (ZKP) is to allow the prover to demonstrate their knowledge to the verifier without revealing any additional information. This knowledge typically involves solving complex problems, such as finding a secret input value that corresponds to a given public hash. ZKP protocols usually convert these statements into polynomial constraints. This process is often called <strong>arithmetization</strong>.</p>
<p>To make the protocol flexible, we need to encode this knowledge in a specific format, and one common approach is using Boolean circuits. It's well-known that problems in P (those solvable in polynomial time) and NP (those where the solution can be verified in polynomial time) can be represented as Boolean circuits. This means adopting Boolean circuits allows us to handle both P and NP problems.</p>
<p>However, Boolean circuits are often large and inefficient. Even a simple operation, like adding two 256-bit integers, can require hundreds of Boolean operators. In contrast, arithmetic circuits—essentially systems of equations involving addition, multiplication, and equality—offer a much more compact representation. Additionally, any Boolean circuit can be converted into an arithmetic circuit. For instance, the Boolean expression \(z = x \land y\) can be represented as \(x(x-1) = 0\), \(y(y-1) = 0\), and \(z = xy\) in an arithmetic circuit. Furthermore, as we'll see in this section, converting arithmetic circuits into polynomial constraints allows for much faster evaluation.</p>
<h2 id="rank-1-constraint-system-r1cs"><a class="header" href="#rank-1-constraint-system-r1cs">Rank-1 Constraint System (R1CS)</a></h2>
<p>There are many formats to represent arithmetic circuits, and one of the most popular ones is R1CS (Rank-1 Constraint System), which represents arithmetic circuits as a set of equality constraints, each involving only one multiplication. In an arithmetic circuit, we call the concrete values assigned to the variables within the constraints witness. We first provide the formal definition of R1CS as follows:</p>
<h3 id="definition-r1cs"><a class="header" href="#definition-r1cs">Definition: R1CS</a></h3>
<p>An R1CS structure \(\mathcal{S}\) consists of:</p>
<ul>
<li>Size bounds \(m, d, \ell \in \mathbb{N}\) where \(d &gt; \ell\)</li>
<li>Three matrices \(O, L, R \in \mathbb{F}^{m \times d}\) with at most \(\Omega(\max(m, d))\) non-zero entries in total</li>
</ul>
<p>An R1CS instance includes a public input \(p \in \mathbb{F}^\ell\), while an R1CS witness is a vector \(w \in \mathbb{F}^{d - \ell - 1}\).
A structure-instance tuple \((S, p)\) is satisfied by a witness \(w\) if:
\begin{equation}
(L \cdot v) \circ (R \cdot v) - O \cdot v = \mathbf{0}
\end{equation}
where \(v = (1, w, p) \in \mathbb{F}^d\), \(\cdot\) denotes matrix-vector multiplication, and \(\circ\) is the Hadamard product.</p>
<p>The intuitive interpretation of each matrix is as follows:</p>
<ul>
<li>\(L\): Encodes the left input of each gate</li>
<li>\(R\): Encodes the right input of each gate</li>
<li>\(O\): Encodes the output of each gate</li>
<li>The leading 1 in the assignment vector allows for constant terms</li>
</ul>
<p><strong>Single Multiplication</strong></p>
<p>Let's consider a simple example where we want to prove \(z = x \cdot y\), with \(z = 3690\), \(x = 82\), and \(y = 45\).</p>
<ul>
<li><strong>Assignment vector</strong>: \((1, z, x, y) = (1, 3690, 82, 45)\)</li>
<li><strong>Number of witnesses</strong>: \(m = 4\)</li>
<li><strong>Number of constraints</strong>: \(d = 1\)</li>
</ul>
<p>The R1CS constraint for \(z = x \cdot y\) is satisfied when:</p>
<p>\begin{align*}
&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot v) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot v) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot v \\
=&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix} \\
=&amp; 82 \cdot 45 - 3690 \\
=&amp; 3690 - 3690 \\
=&amp; 0
\end{align*}</p>
<p>This example demonstrates how R1CS encodes a simple multiplication constraint:</p>
<ul>
<li>\(L = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\) selects \(x\) (left input)</li>
<li>\(R = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\) selects \(y\) (right input)</li>
<li>\(O = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}\) selects \(z\) (output)</li>
</ul>
<p><strong>Multiple Constraints</strong></p>
<p>Let's examine a more complex example: \(r = a \cdot b \cdot c \cdot d\). Since R1CS requires that each constraint contain only one multiplication, we need to break this down into multiple constraints:</p>
<p>\begin{align*}
z_1 &amp;= a \cdot b \\
z_2 &amp;= c \cdot d \\
r &amp;= z_1 \cdot z_2
\end{align*}</p>
<p>Note that alternative representations are possible, such as \(z_1 = ab, z_2 = z_1c, r = z_2d\). In this example, we use 7 variables \((r, a, b, c, d, z_1, z_2)\), so the dimension of the assignment vector will be \(m = 8\) (including the constant 1). We have three constraints, so \(n = 3\).
To construct the matrices \(L\), \(R\), and \(O\), we can interpret the constraints as linear combinations:</p>
<p>\begin{align*}
z_1 &amp;= (0 \cdot 1 + 0 \cdot r + 1 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot b \\
z_2 &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 1 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot d \\
r &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 1 \cdot z_1 + 0 \cdot z_2) \cdot z_2
\end{align*}</p>
<p>Thus, we can construct \(L\), \(R\), and \(O\) as follows:</p>
<p>\begin{equation*}
L = \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\end{equation*}
\begin{equation*}
R = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{equation*}
\begin{equation*}
O = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\end{equation*}</p>
<p>Where the columns in each matrix correspond to \((1, r, a, b, c, d, z_1, z_2)\).</p>
<p><strong>Addition with a Constant</strong></p>
<p>Let's examine the case \(z = x \cdot y + 3\). We can represent this as \(-3 + z = x \cdot y\). For the assignment vector \((1, z, x, y)\), we have:</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
-3 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}
\end{align*}</p>
<p>Note that the constant 3 appears in the \(O\) matrix with a negative sign, effectively moving it to the left side of the equation</p>
<p><strong>Multiplication with a Constant</strong></p>
<p>Now, let's consider \(z = 3x^2 + y\). The requirement of "one multiplication per constraint" doesn't apply to multiplication with a constant, as we can treat it as repeated addition.</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 3 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix}
\end{align*}</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;F: Field&gt;(a: &amp;Vec&lt;F&gt;, b: &amp;Vec&lt;F&gt;) -&gt; F {
    let mut result = F::zero();
    for (a_i, b_i) in a.iter().zip(b.iter()) {
        result = result + a_i.clone() * b_i.clone();
    }
    result
}

#[derive(Debug, Clone)]
pub struct R1CS&lt;F: Field&gt; {
    pub left: Vec&lt;Vec&lt;F&gt;&gt;,
    pub right: Vec&lt;Vec&lt;F&gt;&gt;,
    pub out: Vec&lt;Vec&lt;F&gt;&gt;,
    pub m: usize,
    pub d: usize,
}

impl&lt;F: Field&gt; R1CS&lt;F&gt; {
    pub fn new(left: Vec&lt;Vec&lt;F&gt;&gt;, right: Vec&lt;Vec&lt;F&gt;&gt;, out: Vec&lt;Vec&lt;F&gt;&gt;) -&gt; Self {
        let d = left.len();
        let m = if d == 0 { 0 } else { left[0].len() };
        R1CS {
            left,
            right,
            out,
            m,
            d,
        }
    }

    pub fn is_satisfied(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; bool {
        let zero = F::zero();
        self.left
            .iter()
            .zip(self.right.iter())
            .zip(self.out.iter())
            .all(|((l, r), o)| dot(&amp;l, &amp;a) * dot(&amp;r, &amp;a) - dot(&amp;o, &amp;a) == zero)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="quadratic-arithmetic-program-qap"><a class="header" href="#quadratic-arithmetic-program-qap">Quadratic Arithmetic Program (QAP)</a></h2>
<p>Recall that the prover aims to demonstrate knowledge of a witness \(w\) without revealing it. This is equivalent to knowing a vector \(a\) that satisfies \((L \cdot v) \circ (R \cdot v) = O \cdot v\), where \(\circ\) denotes the Hadamard (element-wise) product. However, evaluating this equivalence directly requires \(\Omega(d)\) operations, where \(d\) is the number of rows. To improve efficiency, we can convert this matrix comparison to a polynomial comparison, leveraging the Schwartz-Zippel Lemma, which allows us to check polynomial equality with \(\Omega(1)\) evaluations.</p>
<p><strong>Equivalence of Matrices</strong></p>
<p>Let's consider a simpler example to illustrate this concept. Suppose we want to test the equivalence \(Av = Bu\), where:</p>
<p>\begin{align*}
A = \begin{bmatrix}
2 &amp; 5 \\
3 &amp; 1 \\
\end{bmatrix},
B = \begin{bmatrix}
4 &amp; 1 \\
2 &amp; 3 \\
\end{bmatrix},
v = \begin{bmatrix}
3 \\ 1
\end{bmatrix},
u = \begin{bmatrix}
2 \\ 2
\end{bmatrix}
\end{align*}</p>
<p>The equivalence check can be represented as:</p>
<p>\begin{equation*}
\begin{bmatrix}
2 \\ 3
\end{bmatrix} \cdot 3 + \begin{bmatrix}
5 \\ 1
\end{bmatrix} \cdot 1 = \begin{bmatrix}
4 \\ 2
\end{bmatrix} \cdot 2 + \begin{bmatrix}
1 \\ 3
\end{bmatrix} \cdot 2
\end{equation*}</p>
<p>This matrix-vector equality check is equivalent to the following polynomial equality check:</p>
<p>\begin{equation*}
3 \cdot \lambda([(1, 2), (2, 3)]) + 1 \cdot \lambda([(1, 5), (2, 1)]) = 2 \cdot \lambda([(1, 4), (2, 2)]) + 2 \cdot \lambda([(1, 1), (2, 3)])
\end{equation*}</p>
<p>where \(\lambda\) denotes Lagrange Interpolation. In \(\mathbb{F}_{11}\) (field with 11 elements), we have:</p>
<p>\begin{align*}
\lambda([(1, 2), (2, 3)]) &amp;= x + 1 \\
\lambda([(1, 5), (2, 1)]) &amp;= 7x + 9 \\
\lambda([(1, 4), (2, 2)]) &amp;= 9x + 6 \\
\lambda([(1, 1), (2, 3)]) &amp;= 2x + 10
\end{align*}</p>
<p>The Schwartz-Zippel Lemma states that we need only one evaluation at a random point to check the equivalence of polynomials with high probability.</p>
<p><strong>Back to R1CS</strong></p>
<p>Let's thinks about how we can leverage the above method for the verification of R1CS. First, we can construct the interpolated polynomials for \(L \cdot v\), \(R \cdot v\), and \(O \cdot v\), denoted as \(\ell(x)\), \(r(x)\), and \(o(x)\), repectively, as follows:</p>
<p>\begin{align*}
\ell(x) &amp;= \sum^{d}_{i=1} v_i \ell_i(x) \quad \hbox{,where } \ell_i(x) := \lambda([(1, L_i,_1), (2, L_i,_2), \cdots,(m, L_i,_m)]) \\
r(x) &amp;= \sum^{d} _{i=1} v_i r_i(x) \quad \hbox{,where } r_i(x) := \lambda([(1, R_i,_1), (2, R_i,_2), \cdots,(m, R_i,_m)]) \\
o(x) &amp;= \sum^{d} _{i=1} v_i o_i(x) \quad \hbox{,where } o_i(x) := \lambda([(1, O_i,_1), (2, O_i,_2), \cdots,(m, O_i,_m)])
\end{align*}</p>
<p>However, the homomorphic property for multiplication doesn't hold for Lagrange Interpolation. While \(\ell(x)\), \(r(x)\), and \(o(x)\) are of degree at most \(m-1\), \(\ell(x) \cdot r(x)\) is of degree at most \(2m-2\). Thus, we don't have \(\ell(x) \cdot r(x) = o(x)\).</p>
<p>To address this discrepancy, we introduce a degree \(m\) polynomial \(t(x) = \prod_{i=1}^{m} (x - i)\). Given the constituion of the interpolated equations, we have that \(\forall{x} \in \{1,\cdots, d\}\) \(\ell(x) \cdot r(x) = o(x)\). This implies the following:</p>
<p>\begin{equation}
\forall{x} \in \{1,\cdots, m\} \quad \ell(x) \cdot r(x) - o(x) = 0
\end{equation}</p>
<p>Thus, we can factorize \(\ell(x) \cdot r(x) - o(x)\) into the product of \(t(x)\) and an appripriate polynomial \(h(x)\) such that \(\ell(x) \cdot r(x) - o(x) = t(x)h(x)\).</p>
<p>Then, we can then rewrite the equation as:</p>
<p>\begin{equation}
\ell(x) \cdot r(x) = o(x) + h(x) \cdot t(x)
\end{equation}</p>
<p>This formulation allows us to maintain the desired polynomial relationships while accounting for the degree differences.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct QAP&lt;'a, F: Field&gt; {
    pub r1cs: &amp;'a R1CS&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
}

impl&lt;'a, F: Field&gt; QAP&lt;'a, F&gt; {
    fn new(r1cs: &amp;'a R1CS&lt;F&gt;) -&gt; Self {
        QAP {
            r1cs: r1cs,
            t: Polynomial::&lt;F&gt;::from_monomials(
                &amp;(1..=r1cs.d).map(|i| F::from_value(i)).collect::&lt;Vec&lt;F&gt;&gt;(),
            ),
        }
    }

    fn generate_polynomials(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; (Polynomial&lt;F&gt;, Polynomial&lt;F&gt;, Polynomial&lt;F&gt;) {
        let left_dot_products = self
            .r1cs
            .left
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let right_dot_products = self
            .r1cs
            .right
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let out_dot_products = self
            .r1cs
            .out
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();

        let x = (1..=self.r1cs.m)
            .map(|i| F::from_value(i))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let left_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;left_dot_products);
        let right_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;right_dot_products);
        let out_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;out_dot_products);
        (
            left_interpolated_polynomial,
            right_interpolated_polynomial,
            out_interpolated_polynomial,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proving-single-polynomial"><a class="header" href="#proving-single-polynomial">Proving Single Polynomial</a></h1>
<p>Before dealing with all of \(\ell(x)\), \(r(x)\), and \(o(x)\) at once, we design a protocol that allows the Prover \(\mathcal{A}\) to convince the Verifier \(\mathcal{B}\) that \(\mathcal{A}\) knows a specific polynomial. Let's denote this polynomial of degree \(n\) with coefficients in a finite field as:</p>
<p>\begin{equation}
P(x) = c_0 + c_1 x + c_2 x^{2} + \cdots c_n x^{n}
\end{equation}</p>
<p>Assume \(P(x)\) has \(n\) roots, \(a_1, a_2, \ldots, a_n \in \mathbb{F}\), such that \(P(x) = (x - a_1)(x - a_2)\cdots(x - a_n)\). The Verifier \(\mathcal{B}\) knows \(m &lt; n\) roots of \(P(x)\), namely \(a_1, a_2, \ldots, a_m\). Let \(T(x) = (x - a_1)(x - a_2)\cdots(x - a_m)\). Note that the Prover also knows \(T(x)\).</p>
<p>The Prover's objective is to convince the Verifier that \(\mathcal{A}\) knows a polynomial \(H(x) = \frac{P(x)}{T(x)}\).</p>
<h2 id="naive-approach"><a class="header" href="#naive-approach">Naive Approach</a></h2>
<p>The simplest approach to prove that \(\mathcal{A}\) knows \(H(x)\) is as follows:</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) sends all possible values in \(\mathbb{F}\) to \(\mathcal{A}\).</li>
<li>\(\mathcal{A}\) computes and sends all possible outputs of \(H(x)\) and \(P(x)\).</li>
<li>\(\mathcal{B}\) checks whether \(H(a)T(a) = P(a)\) holds for any \(a\) in \(\mathbb{F}\).</li>
</ul>
<p>This protocol is highly inefficient, requiring \(\mathcal{O}(|\mathbb{F}|)\) evaluations and communications.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier&lt;F: Field&gt; {
    pub t: Polynomial&lt;F&gt;,
    pub known_roots: Vec&lt;F&gt;,
}

impl&lt;F: Field&gt; Prover&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover { p, t, h }
    }

    pub fn compute_all_values(&amp;self, modulus: i128) -&gt; (HashMap&lt;F, F&gt;, HashMap&lt;F, F&gt;) {
        let mut h_values = HashMap::new();
        let mut p_values = HashMap::new();

        for i in 0..modulus {
            let x = F::from_value(i);
            h_values.insert(x.clone(), self.h.eval(&amp;x));
            p_values.insert(x.clone(), self.p.eval(&amp;x));
        }

        (h_values, p_values)
    }
}

impl&lt;F: Field&gt; Verifier&lt;F&gt; {
    pub fn new(known_roots: Vec&lt;F&gt;) -&gt; Self {
        let t = Polynomial::from_monomials(&amp;known_roots);
        Verifier { t, known_roots }
    }

    pub fn verify(&amp;self, h_values: &amp;HashMap&lt;F, F&gt;, p_values: &amp;HashMap&lt;F, F&gt;) -&gt; bool {
        for (x, h_x) in h_values {
            let t_x = self.t.eval(x);
            let p_x = p_values.get(x).unwrap();
            if h_x.clone() * t_x != *p_x {
                return false;
            }
        }
        true
    }
}

pub fn naive_protocol&lt;F: Field&gt;(prover: &amp;Prover&lt;F&gt;, verifier: &amp;Verifier&lt;F&gt;, modulus: i128) -&gt; bool {
    // Step 1: Verifier sends all possible values (implicitly done by Prover computing all values)

    // Step 2: Prover computes and sends all possible outputs
    let (h_values, p_values) = prover.compute_all_values(modulus);

    // Step 3: Verifier checks whether H(a)T(a) = P(a) holds for any a in F
    verifier.verify(&amp;h_values, &amp;p_values)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="-schwartz-zippel-lemma"><a class="header" href="#-schwartz-zippel-lemma">\(+\) Schwartz-Zippel Lemma</a></h2>
<p>Instead of evaluating polynomials at all values in \(\mathbb{F}\), we can leverage the Schwartz-Zippel Lemma: if \(H(s) = \frac{P(s)}{T(s)}\) or equivalently \(H(s)T(s) = P(s)\) for a random element \(s\), we can conclude that \(H(x) = \frac{P(x)}{T(x)}\) with high probability. Thus, the Prover \(\mathcal{A}\) only needs to send evaluations of \(P(s)\) and \(H(s)\) for a random input \(s\) received from \(\mathcal{B}\).</p>
<p><strong>Protocol:</strong></p>
<ul>
<li><em>\(\mathcal{B}\) draws random \(s\) from \(\mathbb{F}\) and sends it to \(\mathcal{A}\).</em></li>
<li><em>\(\mathcal{A}\) computes \(h = H(s)\) and \(p = P(s)\) and send them to \(\mathcal{B}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(p = t h\), where \(t\) denotes \(T(s)\).</em></li>
</ul>
<p>This protocol is efficient, requiring only a constant number of evaluations and communications.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier&lt;F: Field&gt; {
    pub t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; Prover&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover { p, t, h }
    }

    pub fn compute_values(&amp;self, s: &amp;F) -&gt; (F, F) {
        let h_s = self.h.eval(s);
        let p_s = self.p.eval(s);
        (h_s, p_s)
    }
}

impl&lt;F: Field&gt; Verifier&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        Verifier { t }
    }

    pub fn generate_challenge(&amp;self) -&gt; F {
        F::random_element(&amp;[])
    }

    pub fn verify(&amp;self, s: &amp;F, h: &amp;F, p: &amp;F) -&gt; bool {
        let t_s = self.t.eval(s);
        h.clone() * t_s == *p
    }
}

pub fn schwartz_zippel_protocol&lt;F: Field&gt;(prover: &amp;Prover&lt;F&gt;, verifier: &amp;Verifier&lt;F&gt;) -&gt; bool {
    // Step 1: Verifier generates a random challenge
    let s = verifier.generate_challenge();

    // Step 2: Prover computes and sends h and p
    let (h, p) = prover.compute_values(&amp;s);

    // Step 3: Verifier checks whether p = t * h
    verifier.verify(&amp;s, &amp;h, &amp;p)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability:</strong></p>
<p>However, it is vulnerable to a malicious prover who could send an arbitrary value \(h'\) and the corresponding \(p'\) such that \(p' = h't\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simulating a malicious prover
pub struct MaliciousProver&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; MaliciousProver&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        MaliciousProver { t }
    }

    pub fn compute_malicious_values(&amp;self, s: &amp;F) -&gt; (F, F) {
        let h_prime = F::random_element(&amp;[]);
        let t_s = self.t.eval(s);
        let p_prime = h_prime.clone() * t_s;
        (h_prime, p_prime)
    }
}

pub fn malicious_schwartz_zippel_protocol&lt;F: Field&gt;(
    prover: &amp;MaliciousProver&lt;F&gt;,
    verifier: &amp;Verifier&lt;F&gt;,
) -&gt; bool {
    // Step 1: Verifier generates a random challenge
    let s = verifier.generate_challenge();

    // Step 2: Malicious Prover computes and sends h' and p'
    let (h_prime, p_prime) = prover.compute_malicious_values(&amp;s);

    // Step 3: Verifier checks whether p' = t * h'
    verifier.verify(&amp;s, &amp;h_prime, &amp;p_prime)
}

<span class="boring">}</span></code></pre></pre>
<h2 id="-discrete-logarithm-assumption"><a class="header" href="#-discrete-logarithm-assumption">\(+\) Discrete Logarithm Assumption</a></h2>
<p>To address this vulnerability, the Verifier must hide the randomly chosen input \(s\) from the Prover. This can be achieved using the discrete logarithm assumption: it is computationally hard to determine \(s\) from \(\alpha\), where \(\alpha = g^s \bmod p\). Thus, it's safe for the Verifier to send \(\alpha\), as the Prover cannot easily derive \(s\) from it.</p>
<p>An interesting property of polynomial exponentiation is:</p>
<p>\begin{align}
g^{P(x)} &amp;= g^{c_0 + c_1 x + c_2 x^{2} + \cdots c_n x^{n}} = g^{c_0} (g^{x})^{c_1}  (g^{(x^2)})^{c_2} \cdots (g^{(x^n)})^{c_n}
\end{align}</p>
<p>Instead of sending \(s\), the Verifier can send \(g\) and \(\alpha_{i} = g^{(s^i)}\) for \(i = 1, \cdots n\). BE CAREFUL THAT <strong>\(g^{(s^i)} \neq (g^s)^i\)</strong>. The Prover can still evaluate \(g^p = g^{P(s)}\) using these powers of \(g\):</p>
<p>\begin{equation}
g^{p} = g^{P(s)} = g^{c_0} \alpha_{1}^{c_1} (\alpha_{2})^{c_2} \cdots (\alpha_{n})^{c_n}
\end{equation}</p>
<p>Similarly, the Prover can evaluate \(g^h = g^{H(s)}\). The Verifier can then check \(p = ht \iff g^p = (g^h)^t\).</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly draw \(s\) from \(\mathbb{F}\).</li>
<li><em>\(\mathcal{B}\) computes and sends \(\{\alpha, \alpha_2, ..., \alpha_{n}\}\), where \(\alpha_i= g^{(s^{i})}\).</em></li>
<li><em>\(\mathcal{A}\) computes and sends \(u = g^{p}\) and \(v = g^{h}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(u = v^{t}\).</em></li>
</ul>
<p>This approach prevents the Prover from obtaining \(s\) or \(t = T(s)\), making it impossible to send fake \((h', p')\) such that \(p' = h't\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    g: F,
}

impl&lt;F: Field&gt; Prover&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover { p, t, h }
    }

    pub fn compute_values(&amp;self, alpha_powers: &amp;[F]) -&gt; (F, F) {
        let g_p = self.p.eval_with_powers(alpha_powers);
        let g_h = self.h.eval_with_powers(alpha_powers);
        (g_p, g_h)
    }
}

impl&lt;F: Field&gt; Verifier&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let mut rng = rand::thread_rng();
        let s = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));
        let g = F::from_value(generator);
        Verifier { t, s, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; Vec&lt;F&gt; {
        let mut alpha_powers = vec![];
        for i in 0..(max_degree + 1) {
            alpha_powers.push(
                self.g
                    .pow(self.s.clone().pow(i.to_bigint().unwrap()).get_value()),
            );
        }
        alpha_powers
    }

    pub fn verify(&amp;self, u: &amp;F, v: &amp;F) -&gt; bool {
        let t_s = self.t.eval(&amp;self.s);
        u == &amp;v.pow(t_s.get_value())
    }
}

pub fn discrete_log_protocol&lt;F: Field&gt;(prover: &amp;Prover&lt;F&gt;, verifier: &amp;Verifier&lt;F&gt;) -&gt; bool {
    // Step 1 &amp; 2: Verifier generates a challenge
    let max_degree = prover.p.degree();
    let alpha_powers = verifier.generate_challenge(max_degree as usize);

    // Step 3: Prover computes and sends u = g^p and v = g^h
    let (u, v) = prover.compute_values(&amp;alpha_powers);

    // Step 4: Verifier checks whether u = v^t
    verifier.verify(&amp;u, &amp;v)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Vulnerability:</strong></p>
<p>However, this protocol still has a flaw. Since the Prover can compute \(g^t = \alpha_{c_1}(\alpha_2)^{c_2}\cdots(\alpha_m)^{c_m}\), they could send fake values \(((g^{t})^{z}, g^{z})\) instead of \((g^p, g^h)\) for an arbitrary value \(z\). The verifier's check would still pass, and they could not detect this deception.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simulating a malicious prover
pub struct MaliciousProver&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
}

impl&lt;F: Field&gt; MaliciousProver&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;) -&gt; Self {
        MaliciousProver { t }
    }

    pub fn compute_malicious_values(&amp;self, alpha_powers: &amp;[F]) -&gt; (F, F) {
        let g_t = self.t.eval_with_powers(alpha_powers);
        let z = F::random_element(&amp;[]);
        let g = &amp;alpha_powers[0];
        let fake_v = g.pow(z.get_value());
        let fake_u = g_t.pow(z.get_value());
        (fake_u, fake_v)
    }
}

pub fn malicious_discrete_log_protocol&lt;F: Field&gt;(
    prover: &amp;MaliciousProver&lt;F&gt;,
    verifier: &amp;Verifier&lt;F&gt;,
) -&gt; bool {
    // Step 1 &amp; 2: Verifier generates a challenge
    let max_degree = prover.t.degree() as usize;
    let alpha_powers = verifier.generate_challenge(max_degree as usize);

    // Step 3: Malicious Prover computes and sends fake u and v
    let (fake_u, fake_v) = prover.compute_malicious_values(&amp;alpha_powers);

    // Step 4: Verifier checks whether u = v^t (which will pass for the fake values)
    verifier.verify(&amp;fake_u, &amp;fake_v)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="-knowledge-of-exponent-assumption"><a class="header" href="#-knowledge-of-exponent-assumption">\(+\) Knowledge of Exponent Assumption</a></h2>
<p>To address the vulnerability where the verifier \(\mathcal{B}\) cannot distinguish if \(v (= g^h)\) from the prover is a power of \(\alpha_i = g^{(s^i)}\), we can employ the Knowledge of Exponent Assumption. This approach involves the following steps:</p>
<ul>
<li>\(\mathcal{B}\) sends both \(\alpha_i\) and \(\alpha'_i = \alpha_i^r\) for a new random value \(r\).</li>
<li>The prover returns \(a = (\alpha_i)^{c_i}\) and \(a' = (\alpha'_i)^{c_i}\) for \(i = 1, ..., n\).</li>
<li>\(\mathcal{B}\) can conclude that \(a\) is a power of \(\alpha_i\) if \(a^r = a'\).</li>
</ul>
<p>Based on this assumption, we can design an improved protocol:</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly selects \(s\) and <em>\(r\)</em> from field \(\mathbb{F}\).</li>
<li>\(\mathcal{B}\) computes and sends \(\{\alpha_1, \alpha_2, ..., \alpha_{n}\}\) <em>and \(\{\alpha'_1, \alpha'_2, ..., \alpha'_{n}\}\), where \(\alpha_i = g^{(s^i)}\) and \(\alpha' = \alpha_{r} = g^{(s^{i})r}\).</em></li>
<li>\(\mathcal{A}\) computes and sends \(u = g^{p}\), \(v = g^{h}\), <em>and \(w = g^{p'}\), where \(g^{p'} = g^{rP(s)}\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(u^{r} = w\).</em></li>
<li>\(\mathcal{B}\) checks whether \(u = v^{t}\).</li>
</ul>
<p>The prover can compute \(g^{p'} = g^{rP(s)} = \alpha'^{c_1} (\alpha'^{2})^{c_2} \cdots (\alpha'^{n})^{c_n}\) using powers of \(\alpha'\). This protocol now satisfies the properties of a SNARK: completeness, soundness, and efficiency.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    r: F,
    g: F,
}

impl&lt;F: Field&gt; Prover&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover { p, t, h }
    }

    pub fn compute_values(&amp;self, alpha_powers: &amp;[F], alpha_prime_powers: &amp;[F]) -&gt; (F, F, F) {
        let g_p = self.p.eval_with_powers(alpha_powers);
        let g_h = self.h.eval_with_powers(alpha_powers);
        let g_p_prime = self.p.eval_with_powers(alpha_prime_powers);
        (g_p, g_h, g_p_prime)
    }
}

impl&lt;F: Field&gt; Verifier&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let mut rng = rand::thread_rng();
        let s = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));
        let r = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));
        let g = F::from_value(generator);
        Verifier { t, s, r, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; (Vec&lt;F&gt;, Vec&lt;F&gt;) {
        let mut alpha_powers = vec![];
        let mut alpha_prime_powers = vec![];

        for i in 0..(max_degree + 1) {
            alpha_powers.push(
                self.g
                    .pow(self.s.clone().pow(i.to_bigint().unwrap()).get_value()),
            );
            alpha_prime_powers.push(alpha_powers.last().unwrap().pow(self.r.get_value()));
        }

        (alpha_powers, alpha_prime_powers)
    }

    pub fn verify(&amp;self, u: &amp;F, v: &amp;F, w: &amp;F) -&gt; bool {
        let t_s = self.t.eval(&amp;self.s);
        let u_r = u.pow(self.r.clone().get_value());

        // Check 1: u^r = w
        let check1 = u_r == *w;

        // Check 2: u = v^t
        let check2 = *u == v.pow(t_s.get_value());

        check1 &amp;&amp; check2
    }
}

pub fn knowledge_of_exponent_protocol&lt;F: Field&gt;(
    prover: &amp;Prover&lt;F&gt;,
    verifier: &amp;Verifier&lt;F&gt;,
) -&gt; bool {
    // Step 1 &amp; 2: Verifier generates a challenge
    let max_degree = std::cmp::max(prover.p.degree(), prover.h.degree()) as usize;
    let (alpha_powers, alpha_prime_powers) = verifier.generate_challenge(max_degree + 1);

    // Step 3: Prover computes and sends u = g^p, v = g^h, and w = g^p'
    let (u, v, w) = prover.compute_values(&amp;alpha_powers, &amp;alpha_prime_powers);

    // Step 4 &amp; 5: Verifier checks whether u^r = w and u = v^t
    verifier.verify(&amp;u, &amp;v, &amp;w)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="-zero-knowledge"><a class="header" href="#-zero-knowledge">\(+\) Zero Knowledge</a></h2>
<p>To transform the above protocol into a zk-SNARK, we need to ensure that the verifier cannot learn anything about \(P(x)\) from the prover's information. This is achieved by having the prover obfuscate all information with a random secret value \(\delta\):</p>
<p><strong>Protocol:</strong></p>
<ul>
<li>\(\mathcal{B}\) randomly selects \(s\) and \(r\) from field \(\mathbb{F}\).</li>
<li>\(\mathcal{B}\) computes and sends \(\{\alpha_1, \alpha_2, ..., \alpha_{n}\}\) and \(\{\alpha_1', \alpha'_2, ..., \alpha'_{n}\}\), where \(\alpha_i = g^{(s^{i})}\) and \(\alpha_i' = \alpha_i^{r} = g^{(s^{i})r}\).</li>
<li><em>\(\mathcal{A}\) randomly selects \(\delta\) from field \(\mathbb{F}\).</em></li>
<li><em>\(\mathcal{A}\) computes and sends \(u' = (g^{p})^{\delta}\), \(v' = (g^{h})^{\delta}\), and \(w' = (g^{p'})^{\delta}\).</em></li>
<li>\(\mathcal{B}\) checks whether \(u'^{r} = w'\).</li>
<li>\(\mathcal{B}\) checks whether \(u' = v'^{t}\).</li>
</ul>
<p>By introducing the random value \(\delta\), the verifier can no longer learn anything about \(p\), \(h\), or \(w\), thus achieving zero knowledge.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F: Field&gt; {
    pub p: Polynomial&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
    pub h: Polynomial&lt;F&gt;,
}

pub struct Verifier&lt;F: Field&gt; {
    t: Polynomial&lt;F&gt;,
    s: F,
    r: F,
    g: F,
}

impl&lt;F: Field&gt; Prover&lt;F&gt; {
    pub fn new(p: Polynomial&lt;F&gt;, t: Polynomial&lt;F&gt;) -&gt; Self {
        let h = p.clone() / t.clone();
        Prover { p, t, h }
    }

    pub fn compute_values(&amp;self, alpha_powers: &amp;[F], alpha_prime_powers: &amp;[F]) -&gt; (F, F, F) {
        let mut rng = rand::thread_rng();
        let delta = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));

        let g_p = self.p.eval_with_powers(alpha_powers);
        let g_h = self.h.eval_with_powers(alpha_powers);
        let g_p_prime = self.p.eval_with_powers(alpha_prime_powers);

        let u_prime = g_p.pow(delta.get_value());
        let v_prime = g_h.pow(delta.get_value());
        let w_prime = g_p_prime.pow(delta.get_value());

        (u_prime, v_prime, w_prime)
    }
}

impl&lt;F: Field&gt; Verifier&lt;F&gt; {
    pub fn new(t: Polynomial&lt;F&gt;, generator: i128) -&gt; Self {
        let mut rng = rand::thread_rng();
        let s = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));
        let r = F::from_value(rng.gen_bigint_range(
            &amp;BigInt::zero(),
            &amp;BigInt::from(std::u64::MAX),
        ));
        let g = F::from_value(generator);
        Verifier { t, s, r, g }
    }

    pub fn generate_challenge(&amp;self, max_degree: usize) -&gt; (Vec&lt;F&gt;, Vec&lt;F&gt;) {
        let mut alpha_powers = vec![];
        let mut alpha_prime_powers = vec![];

        for i in 0..(max_degree + 1) {
            alpha_powers.push(
                self.g
                    .pow(self.s.clone().pow(i.to_bigint().unwrap()).get_value()),
            );
            alpha_prime_powers.push(alpha_powers.last().unwrap().pow(self.r.get_value()));
        }

        (alpha_powers, alpha_prime_powers)
    }

    pub fn verify(&amp;self, u_prime: &amp;F, v_prime: &amp;F, w_prime: &amp;F) -&gt; bool {
        let t_s = self.t.eval(&amp;self.s);
        let u_prime_r = u_prime.pow(self.r.clone().get_value());

        // Check 1: u'^r = w'
        let check1 = u_prime_r == *w_prime;

        // Check 2: u' = v'^t
        let check2 = *u_prime == v_prime.pow(t_s.get_value());

        check1 &amp;&amp; check2
    }
}

pub fn zk_protocol&lt;F: Field&gt;(prover: &amp;Prover&lt;F&gt;, verifier: &amp;Verifier&lt;F&gt;) -&gt; bool {
    // Step 1 &amp; 2: Verifier generates a challenge
    let max_degree = std::cmp::max(prover.p.degree(), prover.h.degree()) as usize;
    let (alpha_powers, alpha_prime_powers) = verifier.generate_challenge(max_degree + 1);

    // Step 3 &amp; 4: Prover computes and sends u' = (g^p)^δ, v' = (g^h)^δ, and w' = (g^p')^δ
    let (u_prime, v_prime, w_prime) = prover.compute_values(&amp;alpha_powers, &amp;alpha_prime_powers);

    // Step 5 &amp; 6: Verifier checks whether u'^r = w' and u' = v'^t
    verifier.verify(&amp;u_prime, &amp;v_prime, &amp;w_prime)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="-non-interactivity"><a class="header" href="#-non-interactivity">\(+\) Non-interactivity</a></h2>
<p>The previously described protocol requires each verifier to generate unique random values, which becomes inefficient when a prover needs to demonstrate knowledge to multiple verifiers. To address this, we aim to eliminate the interaction between the prover and verifier. One effective solution is the use of a trusted setup.</p>
<p><strong>Protocol (Trusted Setup):</strong></p>
<ul>
<li><em><strong>Secret Seed:</strong> A trusted third party generates the random values \(s\) and \(r\)</em></li>
<li><em><strong>Proof Key:</strong> Provided to the prover</em>
<ul>
<li><em>\(\{\alpha_1, \alpha_2, ..., \alpha_{n}\}\), where \(\alpha_{i} = g^{(s^i)}\)</em></li>
<li><em>\(\{\alpha'_1, \alpha'_2, ..., \alpha'_{n}\}\), where \(\alpha_i' = g^{(s^{i})r}\)</em></li>
</ul>
</li>
<li><em><strong>Verification Key:</strong> Distributed to verifiers</em>
<ul>
<li><em>\(g^{r}\)</em></li>
<li><em>\(g^{T(s)}\)</em></li>
</ul>
</li>
<li><em>After distribution, the original \(s\) and \(r\) values are securely destroyed.</em></li>
</ul>
<p>Then, the non-interactive protocol consists of two main parts: proof generation and verification.</p>
<p><strong>Protocol (Proof):</strong></p>
<ul>
<li><em>\(\mathcal{A}\) receives the proof key</em></li>
<li><em>\(\mathcal{A}\) randomly selects \(\delta\) from field \(\mathbb{F}\).</em></li>
<li><em>\(\mathcal{A}\) broadcast the proof \(\pi = (u' = (g^{p})^{\delta}, v' = (g^{h})^{\delta}, w' = (g^{p'})^{\delta})\)</em></li>
</ul>
<p>Since \(r\) is not shared and already destroyed, the verifier \(\mathcal{B}\) cannot calculate \(u'^{r}\) to check \(u'^{r} = w'\). Instead, the verifier can use a paring with bilinear mapping; \(u'^{r} = w'\) is equivalent to \(e(u' = (g^{p})^{\delta}, g^{r}) = e(w'=(g^{p'})^{\delta}, g)\).</p>
<p><strong>Protocol (Verification):</strong></p>
<ul>
<li><em>\(\mathcal{B}\) receives the verification key.</em></li>
<li><em>\(\mathcal{B}\) receives the proof \(\pi\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(e(u', g^{r}) = e(w', g)\).</em></li>
<li><em>\(\mathcal{B}\) checks whether \(e(u', g) = e (v', g^{T(s)})\).</em></li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProofKey {
    alpha: Vec&lt;G1Point&gt;,
    alpha_prime: Vec&lt;G1Point&gt;,
}

pub struct VerificationKey {
    g_r: G2Point,
    g_t_s: G2Point,
}

pub struct Proof {
    u_prime: G1Point,
    v_prime: G1Point,
    w_prime: G1Point,
}

pub struct TrustedSetup {
    proof_key: ProofKey,
    verification_key: VerificationKey,
}

impl TrustedSetup {
    pub fn generate(g1: &amp;G1Point, g2: &amp;G2Point, t: &amp;Polynomial&lt;Fq&gt;, n: usize) -&gt; Self {
        let mut rng = rand::thread_rng();
        let s = Fq::from_value(rng.gen_bigint_range(&amp;BigInt::zero(), &amp;BigInt::from(std::u32::MAX)));
        let r = Fq::from_value(rng.gen_bigint_range(&amp;BigInt::zero(), &amp;BigInt::from(std::u32::MAX)));

        let mut alpha = Vec::with_capacity(n);
        let mut alpha_prime = Vec::with_capacity(n);

        let mut s_power = Fq::one();
        for _ in 0..1 + n {
            alpha.push(g1.clone() * s_power.clone().get_value());
            alpha_prime.push(g1.clone() * (s_power.clone() * r.clone()).get_value());
            s_power = s_power * s.clone();
        }

        let g_r = g2.clone() * r.clone().get_value();
        let g_t_s = g2.clone() * t.eval(&amp;s).get_value();

        TrustedSetup {
            proof_key: ProofKey { alpha, alpha_prime },
            verification_key: VerificationKey { g_r, g_t_s },
        }
    }
}

pub struct Prover {
    pub p: Polynomial&lt;Fq&gt;,
    pub h: Polynomial&lt;Fq&gt;,
}

impl Prover {
    pub fn new(p: Polynomial&lt;Fq&gt;, t: Polynomial&lt;Fq&gt;) -&gt; Self {
        let h = p.clone() / t;
        Prover { p, h }
    }

    pub fn generate_proof(&amp;self, proof_key: &amp;ProofKey) -&gt; Proof {
        let mut rng = rand::thread_rng();
        let delta =
            Fq::from_value(rng.gen_bigint_range(&amp;BigInt::zero(), &amp;BigInt::from(std::u32::MAX)));

        let g_p = self.p.eval_with_powers_on_curve(&amp;proof_key.alpha);
        let g_h = self.h.eval_with_powers_on_curve(&amp;proof_key.alpha);
        let g_p_prime = self.p.eval_with_powers_on_curve(&amp;proof_key.alpha_prime);

        Proof {
            u_prime: g_p * delta.get_value(),
            v_prime: g_h * delta.get_value(),
            w_prime: g_p_prime * delta.get_value(),
        }
    }
}

pub struct Verifier {
    pub g1: G1Point,
    pub g2: G2Point,
}

impl Verifier {
    pub fn new(g1: G1Point, g2: G2Point) -&gt; Self {
        Verifier { g1, g2 }
    }

    pub fn verify(&amp;self, proof: &amp;Proof, vk: &amp;VerificationKey) -&gt; bool {
        // Check e(u', g^r) = e(w', g)
        let pairing1 = optimal_ate_pairing(&amp;proof.u_prime, &amp;vk.g_r);
        let pairing2 = optimal_ate_pairing(&amp;proof.w_prime, &amp;self.g2);
        let check1 = pairing1 == pairing2;

        // Check e(u', g^t) = e(v', g)
        let pairing3 = optimal_ate_pairing(&amp;proof.u_prime, &amp;self.g2);
        let pairing4 = optimal_ate_pairing(&amp;proof.v_prime, &amp;vk.g_t_s);
        let check2 = pairing3 == pairing4;

        check1 &amp;&amp; check2
    }
}

pub fn non_interactive_zkp_protocol(
    prover: &amp;Prover,
    verifier: &amp;Verifier,
    setup: &amp;TrustedSetup,
) -&gt; bool {
    let proof = prover.generate_proof(&amp;setup.proof_key);
    verifier.verify(&amp;proof, &amp;setup.verification_key)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bringing-it-all-together"><a class="header" href="#bringing-it-all-together">Bringing It All Together</a></h1>
<p>Let's recap the previous sections. First, the relationship between the inputs and outputs of any program can be expressed as a rank-one constraint system (R1CS) as follows:</p>
<p>\[
(L \cdot v) \circ (R \cdot v) - O \cdot v = 0<br />
\]</p>
<p>, where \(v\) is the concatenation of all inputs, outputs, and intermediate values. This allows us to transform the statement, "I know the input values \(x\) that make the program returns the output values \(y\)", into "I know \(v\), whose outputs components are \(y\), that satisfies the constraint system corresponding to the program".</p>
<p>Then, instead of separately checking each constraint (which corresponds to a row in the R1CS matrix), we can convert this into a more efficient polynomial-equivalence test.</p>
<h2 id="first-protocol-idea"><a class="header" href="#first-protocol-idea">First Protocol Idea</a></h2>
<p>The simplest protocol, based on the previous chapter, is as follows:</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\) and \(\alpha\).</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha \ell_i(s)},g^{\alpha r_i(s)},g^{\alpha o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}\)</li>
<li>\(g^{\alpha}\)</li>
</ul>
</li>
<li>After distribution, the original \(s\) and \(\alpha\) values are securely destroyed.</li>
</ul>
<p>Both the proof key and the verification key are publicly available, enabling anyone to generate and verify proofs based on the target program.</p>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Run the program to obtain the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x)\)</li>
<li>\(r(x) = \sum_{i=1}^{d} v_i r_{i}(x)\)</li>
<li>\(o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute \(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
<li>Evaluate each polynomial at \(s\).
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v_i} \)</li>
<li>\(g^{r(s)} = \prod^{d}_{i=1} (g^{r_i(s)})^{v_i} \)</li>
<li>\(g^{o(s)} = \prod^{d}_{i=1} (g^{o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate the shifted polynomials at \(s\).
<ul>
<li>\(g^{\alpha \ell(s)} = \prod^{d}_{i=1} (g^{\alpha \ell_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha r(s)} = \prod^{d}_{i=1} (g^{\alpha r_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha o(s)} = \prod^{d}_{i=1} (g^{\alpha o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Compute \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>Proof: \((g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha \ell(s)}, g^{\alpha r(s)}, g^{\alpha o(s)}, g^{h(s)})\)</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse the proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h})\)</li>
<li>Check the polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha}) = e(g^{\ell'}, g)\)</li>
<li>\(e(g^{r}, g^{\alpha}) = e(g^{r'}, g)\)</li>
<li>\(e(g^{o}, g^{\alpha}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Verify validity of the proof
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Vulnerability</strong></p>
<p>A critical issue with this protocol is that the checks may pass even if \(g^{\ell}\) is computed not from \(\{g^{\ell_i(s)}\}_{i \in [d]}\) but from \(\{g^{r_i(s)}\} _{i \in [d]}\), \(\{g^{o_i(s)}\} _{i \in [d]}\), or their combinations. The same issue applies to \(g^{r}\) and \(g^{o}\).</p>
<p>For example, if the prover sends \((g^{r(s)}, g^{\ell(s)}, g^{o(s)}, g^{\alpha r(s)}, g^{\alpha \ell(s)}, g^{\alpha o(s)}, g^{h(s)})\) as the proof, all the verification checks still pass, even although the proved statement differs from the original one.</p>
<h2 id="second-protocol-non-interchangibility"><a class="header" href="#second-protocol-non-interchangibility">Second Protocol: Non-Interchangibility</a></h2>
<p>To address the interchangeability issue, the next protocol uses distinct the different \(\alpha\)-shift for \(\ell\), \(r\), and \(o\).</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), <em>\(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\)</em>.</li>
<li><strong>Proof Key (for the prover):</strong>
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li><em>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</em></li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key (public):</strong>
<ul>
<li>\(g^{t(s)}\)</li>
<li><em>\(g^{\alpha_{\ell}}\), \(g^{\alpha_{r}}\), \(g^{\alpha_{o}}\)</em></li>
</ul>
</li>
<li>After distribution, the original \(s\), \(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\) values are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x)\)</li>
<li>\(r(x) = \sum_{i=1}^{d} v_i r_{i}(x)\)</li>
<li>\(o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute \(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
<li>Evaluate each polynomial at \(s\).
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v_i} \)</li>
<li>\(g^{r(s)} = \prod^{d}_{i=1} (g^{r_i(s)})^{v_i} \)</li>
<li>\(g^{o(s)} = \prod^{d}_{i=1} (g^{o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\).
<ul>
<li><em>\(g^{\alpha_{\ell} \ell(s)} = \prod^{d}_{i=1} (g^{\alpha _{\ell} \ell_i(s)})^{v_i} \)</em></li>
<li><em>\(g^{\alpha_{r} r(s)} = \prod^{d}_{i=1} (g^{\alpha _{r} r_i(s)})^{v_i} \)</em></li>
<li><em>\(g^{\alpha_{o} o(s)} = \prod^{d}_{i=1} (g^{\alpha _{o} o_i(s)})^{v_i} \)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>Proof: \((g^{\ell(s)}, g^{r(s)}, g^{o(s)},\) <em>\(g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)},\)</em> \(g^{h(s)})\)</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h})\)</li>
<li>Check polynomial restrictions
<ul>
<li><em>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g)\)</em></li>
<li><em>\(e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g)\)</em></li>
<li><em>\(e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Vulnerability</strong></p>
<p>This protocol resolves interchangeability but does not enforce consistency acros \(\ell\), \(r\), and \(o\). Variables \(v_i\) can still take different values in each polynoimal because verification checks are performed separately.</p>
<h2 id="thrid-protocol-variable-consistency"><a class="header" href="#thrid-protocol-variable-consistency">Thrid Protocol: Variable Consistency</a></h2>
<p>To achive the variable consistency, we employ a checksum mechanism. Specifically, we first draw a new random value \(\beta\) and define the checksum of \(v_i\) as \(g^{\beta(\ell_{i}(s) + r_i(s) + o_i(s))}\). Let \(v _{\ell, i}\), \(v _{r,i}\), \(v _{o,i}\), and \(v _{\beta,i}\) denote the \(i\)-th value of the assignment vectors for \(\ell\), \(r\), \(o\) and the checksum, respectively. If all of them are the same, the following equation holds:</p>
<p>\[
e(g^{v _{\ell, i} \ell_i(s)} g^{v _{r, i} r_i(s)} g^{v _{o, i} o_i(s)}, g^{\beta}) = e(g^{v _{\beta, i} \beta(\ell _{i}(s) + r _{i}(s) + o _{i}(s))}, g)
\]</p>
<p>Unfortunately, this condition is not strictly equivalent. For example, consider the case where \(\ell_i(x) = r_i(x)\). In this scenario, we have:</p>
<p>\begin{align*}
&amp;\beta(v _{\ell, i} \ell_i(s) + v _{r, i} r_i(s) + v _{o, i} o_i(s)) = v _{\beta, i} \beta (\ell _{i}(s) + r _{i}(s) + o _{i}(s)) \\
\iff &amp;\beta(v _{\ell, i} \ell_i(s) + v _{r, i} \ell_i(s) + v _{o, i} o_i(s)) = v _{\beta, i} \beta (2\ell _{i}(s) + o _{i}(s))
\end{align*}</p>
<p>This equation holds for arbitrary \(v _{r,i}\) and \(v _{o,i}\) if we set \(v _{\beta, i} = v _{o, i}\) and \(v _{\ell, i} = 2 v _{o, i} - v _{r, i}\).</p>
<p>To address this issue, we use distinct different \(\beta\) values for \(\ell\), \(r\) and \(o\). The consistency check then verifies the following equation:</p>
<p>\[
e(g^{v _{\ell, i} \ell _{i}(s)}, g^{\beta _{\ell}}) \cdot e(g^{v _{r, i} r _{i}(s)}, g^{\beta _{r}}) \cdot e(g^{v _{o, i} o _{i}(s)}, g^{\beta _{o}}) = e(g^{v _{\beta, i}(\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s))}, g)<br />
\]</p>
<p>The new protocol using the above variable-consistency check is as follows:</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), <em>\(\beta_{\ell}\), \(\beta_{r}\), and \(\beta_{o}\)</em>.</li>
<li><strong>Consistency Polynomial:</strong> <em>\(\{g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)}\} _{i \in [d]}\)</em></li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}\)</li>
<li>\(g^{\alpha_{\ell}}\), \(g^{\alpha_{r}}\), \(g^{\alpha_{o}}\)</li>
<li><em>\(g^{\beta_{\ell}}, g^{\beta_{r}}, g^{\beta_{o}}\)</em></li>
</ul>
</li>
<li>After distribution, the original \(s\), \(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\) values are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x)\)</li>
<li>\(r(x) = \sum_{i=1}^{d} v_i r_{i}(x)\)</li>
<li>\(o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute \(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v_i} \)</li>
<li>\(g^{r(s)} = \prod^{d}_{i=1} (g^{r_i(s)})^{v_i} \)</li>
<li>\(g^{o(s)} = \prod^{d}_{i=1} (g^{o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha_{\ell} \ell(s)} = \prod^{d}_{i=1} (g^{\alpha _{\ell} \ell_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{r} r(s)} = \prod^{d}_{i=1} (g^{\alpha _{r} r_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{o} o(s)} = \prod^{d}_{i=1} (g^{\alpha _{o} o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li><em>Evaluate each consistency polynomial at \(s\):</em>
<ul>
<li><em>\(g^{z(s)} = \prod^{d}_{i=1} (g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)})^{v _{i}}\)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>Proof: \((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) <em>\(g^{z(s)}\)</em> \()\)</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g)\)</li>
<li>\(e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g)\)</li>
<li>\(e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g^{\ell}, g^{\beta _{\ell}}) \cdot e(g^{r}, g^{\beta _{r}}) \cdot e(g^{o}, g^{\beta _{o}}) = e(g^{z}, g)\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p><strong>Vulnerability</strong></p>
<p>Despite these checks, the protocol is vulnerable to <strong>malleability</strong>. Specifically, a malicious prover can exploit the polynomial restriction check to introduce arbitrary constants, altering the proof witout detection.</p>
<p>Recall that the verifier validates whether the submitted \(g^{\ell}\) is actually calculated by \(\{g^{\ell _i(s)}\} _{i \in [d]}\) by checking \(e(g^{\ell}, g^{\alpha _{\ell}}) = e(g^{\ell'}, g)\). However, this process is not sound. Recall that the verification key is publicaly available, and the prover knows both of \(g^{\alpha _{\ell}}\) and \(g^{\beta _{\ell}}\). Here, suppose the prover submits \(g^{\ell} g^{c}\) and \(g^{\ell'} (g^{\alpha _{\ell}})^{c}\) insteads of \(g^{\ell}\) and \(g^{\ell'}\), where \(c\) is a constatn value. Then, the polynomial restriction check still passes:</p>
<p>\[
e(g^{\ell} g^{c}, g^{\alpha _{\ell}}) = e(g^{\alpha _{\ell} \ell + \alpha _{\ell} c}, g) = e(g^{\ell'}g^{\alpha _{\ell}c}, g) = e(g^{\ell'} (g^{\alpha _{\ell}})^{c}, g)
\]</p>
<p>In addition, if the prover submits \(g^{z} (g^{\beta _{\ell}})^{c}\) as the checksum, it also passes the polynomial checksum verification:</p>
<p>\[
e(g^{\ell} g^{c}, g^{\beta _{\ell}}) \cdot e(g^{r}, g^{\beta _{r}}) \cdot e(g^{o}, g^{\beta _{o}}) = e(g^{z} (g^{\beta _{\ell}})^{c}, g)
\]</p>
<p>This phenomenon also can occur for \(r\) and \(o\).</p>
<h2 id="forth-protocol-non-malleability"><a class="header" href="#forth-protocol-non-malleability">Forth Protocol: Non-Malleability</a></h2>
<p>One way to surrogate the above malleability is hiding \(g^{\beta _{\ell}}\), \(g^{\beta _{r}}\), and \(g^{\beta _{o}}\) by powering them with a new random value \(\eta\).</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), \(\beta_{\ell}\), \(\beta_{r}\), \(\beta_{o}\), and <em>\(\eta\)</em>.</li>
<li><strong>Consistency Polynomial:</strong> \(\{g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)}\} _{i \in [d]}\)</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li>\(\{g^{\ell_i(s)},g^{r_i(s)},g^{o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{\alpha_{\ell} \ell_i(s)},g^{\alpha_{r} r_i(s)},g^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li>\(g^{t(s)}\)</li>
<li>\(g^{\alpha_{\ell}}\), \(g^{\alpha_{r}}\), \(g^{\alpha_{o}}\)</li>
<li><em>\(g^{\beta_{\ell} \eta}, g^{\beta_{r} \eta}, g^{\beta_{o} \eta}\)</em></li>
</ul>
</li>
<li>After distribution, the original \(s\), \(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\) values are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x)\)</li>
<li>\(r(x) = \sum_{i=1}^{d} v_i r_{i}(x)\)</li>
<li>\(o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute \(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v_i} \)</li>
<li>\(g^{r(s)} = \prod^{d}_{i=1} (g^{r_i(s)})^{v_i} \)</li>
<li>\(g^{o(s)} = \prod^{d}_{i=1} (g^{o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha_{\ell} \ell(s)} = \prod^{d}_{i=1} (g^{\alpha _{\ell} \ell_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{r} r(s)} = \prod^{d}_{i=1} (g^{\alpha _{r} r_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{o} o(s)} = \prod^{d}_{i=1} (g^{\alpha _{o} o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each consistency polynomial at \(s\):
<ul>
<li>\(g^{z(s)} = \prod^{d}_{i=1} (g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)})^{v _{i}}\)</li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>Proof: \((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) \(g^{z(s)}\) \()\)</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li>\(e(g^{\ell}, g^{\alpha_{\ell}}) = e(g^{\ell'}, g)\)</li>
<li>\(e(g^{r}, g^{\alpha_{r}}) = e(g^{r'}, g)\)</li>
<li>\(e(g^{o}, g^{\alpha_{o}}) = e(g^{o'}, g)\)</li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g^{\ell}, g^{\beta _{\ell} \eta}) \cdot e(g^{r}, g^{\beta _{r} \eta}) \cdot e(g^{o}, g^{\beta _{o} \eta}) = e(g^{z}, g^{\eta})\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<h2 id="fifth-protocol-pinocchio"><a class="header" href="#fifth-protocol-pinocchio">Fifth Protocol: Pinocchio</a></h2>
<p>The above protocol introduces four expensive pairing operations. To make it faster, Pinocchio protocl randomizes the generators.</p>
<p><strong>Protocol (Setup)</strong></p>
<ul>
<li><strong>Interpolated Polynomial:</strong> Construct \(\{\ell_i, r_i, o_i\}_{i\in[d]}\) from \(L\), \(R\), and \(O\), respectively.</li>
<li><strong>Target Polynomial:</strong> \(t(x) = (x-1)(x-2) \cdots (x-m)\)</li>
<li><strong>Secret Seed:</strong> A trusted party generates the random value \(s\), \(\alpha_{\ell}\), \(\alpha_r\), \(\alpha_o\), \(\beta_{\ell}\), \(\beta_{r}\), \(\beta_{o}\), \(\eta\), <em>\(\rho _{\ell}\), and \(\rho _{r}\), and set \(\rho _{o} = \rho _{\ell} \rho _{r}\)</em>.</li>
<li><strong>Randized Generators:</strong> <em>\(g _{\ell} = g^{\rho _{\ell}}\), \(g _{r} = g^{\rho _{r}}\), and \(g _{o} = g^{\rho _{o}}\)</em></li>
<li><strong>Consistency Polynomial:</strong> \(\{g^{\beta _{\ell} \ell _{i}(s) + \beta _{r} r _{i}(s) + \beta _{o} o _{i}(s)}\} _{i \in [d]}\)</li>
<li><strong>Proof Key:</strong> Provided to the prover
<ul>
<li><em>\(\{g_{\ell}^{\ell_i(s)},g_{r}^{r_i(s)},g_{o}^{o_i(s)}\}_{i\in[d]}\)</em></li>
<li><em>\(\{g_{\ell}^{\alpha_{\ell} \ell_i(s)},g_{r}^{\alpha_{r} r_i(s)},g_{o}^{\alpha_{o} o_i(s)}\}_{i\in[d]}\)</em></li>
<li>\(\{g^{(s^j)}\}_{j\in[m]}\)</li>
</ul>
</li>
<li><strong>Verification Key:</strong>
<ul>
<li><em>\(g_{o}^{t(s)}\)</em></li>
<li>\(g^{\alpha_{\ell}}\), \(g^{\alpha_{r}}\), \(g^{\alpha_{o}}\)</li>
<li>\(g^{\beta_{\ell} \eta}, g^{\beta_{r} \eta}, g^{\beta_{o} \eta}\)</li>
</ul>
</li>
<li>After distribution, the original \(s\), \(\alpha_{\ell}\), \(\alpha_r\), and \(\alpha_o\) values are securely destroyed.</li>
</ul>
<p><strong>Protocol (Proving)</strong></p>
<ul>
<li>Execute the program and get the assignment vector \(v\).</li>
<li>Compute the linear-combinations of polynomials
<ul>
<li>\(\ell(x) = \sum_{i=1}^{d} v_i \ell_{i}(x)\)</li>
<li>\(r(x) = \sum_{i=1}^{d} v_i r_{i}(x)\)</li>
<li>\(o(x) = \sum_{i=1}^{d} v_i o_{i}(x)\)</li>
</ul>
</li>
<li>Compute \(h(x) = \frac{\ell(x) r(x) - o(x)}{t(x)}\)</li>
<li>Evaluate each polynomial at \(s\):
<ul>
<li>\(g^{\ell(s)} = \prod^{d}_{i=1} (g^{\ell_i(s)})^{v_i} \)</li>
<li>\(g^{r(s)} = \prod^{d}_{i=1} (g^{r_i(s)})^{v_i} \)</li>
<li>\(g^{o(s)} = \prod^{d}_{i=1} (g^{o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each shifted polynomial at \(s\):
<ul>
<li>\(g^{\alpha_{\ell} \ell(s)} = \prod^{d}_{i=1} (g^{\alpha _{\ell} \ell_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{r} r(s)} = \prod^{d}_{i=1} (g^{\alpha _{r} r_i(s)})^{v_i} \)</li>
<li>\(g^{\alpha_{o} o(s)} = \prod^{d}_{i=1} (g^{\alpha _{o} o_i(s)})^{v_i} \)</li>
</ul>
</li>
<li>Evaluate each consistency polynomial at \(s\):
<ul>
<li><em>\(g^{z(s)} = \prod^{d}_{i=1} (g _{\ell}^{\beta _{\ell} \ell _{i}(s)} \cdot g _{r}^{\beta _{r} r _{i}(s)} \cdot g _{o}^{\beta _{o} o _{i}(s)})^{v _{i}}\)</em></li>
</ul>
</li>
<li>Calculate \(g^{h(s)}\) from \(\{g^{(s^j)}\}_{j\in[m]}\)</li>
<li>Proof: \((\) \(g^{\ell(s)}, g^{r(s)}, g^{o(s)}, g^{\alpha_{\ell} \ell(s)}, g^{\alpha_{r} r(s)}, g^{\alpha_{o} o(s)}, g^{h(s)},\) \(g^{z(s)}\) \()\)</li>
</ul>
<p><strong>Protocol (Verification)</strong></p>
<ul>
<li>Parse proof as \((g^{\ell}, g^r, g^o, g^{\ell'}, g^{r'}, g^{o'}, g^{h}, g^{z})\)</li>
<li>Check polynomial restrictions
<ul>
<li><em>\(e(g _{\ell}^{\ell}, g^{\alpha _{\ell}}) = e(g _{\ell}^{\ell'}, g)\)</em></li>
<li><em>\(e(g _{r}^{r}, g^{\alpha _{r}}) = e(g _{r}^{r'}, g)\)</em></li>
<li><em>\(e(g _{o}^{o}, g^{\alpha _{o}}) = e(g _{o}^{o'}, g)\)</em></li>
</ul>
</li>
<li>Check variable consistency
<ul>
<li><em>\(e(g _{\ell}^{\ell} \cdot g _{r}^{r} \cdot g _{o}^{o}) = e(g^{z}, g^{\eta})\)</em></li>
</ul>
</li>
<li>Validity check
<ul>
<li>\(e(g^{\ell}, g^{r}) = e(g^t,g^h) \cdot e(g^o, g)\)</li>
</ul>
</li>
</ul>
<p>This protocol reduces two pairing operations.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
