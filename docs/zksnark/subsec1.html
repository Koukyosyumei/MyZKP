<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Arithmetization - Book of MyZKP</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../number_theory/index.html"><strong aria-hidden="true">2.</strong> Basics of Number Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../number_theory/subsec1.html"><strong aria-hidden="true">2.1.</strong> Computation Rule and Properties</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec2.html"><strong aria-hidden="true">2.2.</strong> Semigroup, Group, Ring, and Field</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec3.html"><strong aria-hidden="true">2.3.</strong> Polynomials</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec4.html"><strong aria-hidden="true">2.4.</strong> Galois Field</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec5.html"><strong aria-hidden="true">2.5.</strong> Elliptic Curve</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec6.html"><strong aria-hidden="true">2.6.</strong> Pairing</a></li><li class="chapter-item expanded "><a href="../number_theory/subsec7.html"><strong aria-hidden="true">2.7.</strong> Useful Assumptions</a></li></ol></li><li class="chapter-item expanded "><a href="../polynomial_commitment/index.html"><strong aria-hidden="true">3.</strong> Basics of Polynomial Commitment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../polynomial_commitment/kzg.html"><strong aria-hidden="true">3.1.</strong> KZG</a></li><li class="chapter-item expanded "><a href="../polynomial_commitment/gemini.html"><strong aria-hidden="true">3.2.</strong> Gemini</a></li></ol></li><li class="chapter-item expanded "><a href="../zksnark/index.html"><strong aria-hidden="true">4.</strong> Basics of zk-SNARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../zksnark/subsec1.html" class="active"><strong aria-hidden="true">4.1.</strong> Arithmetization</a></li><li class="chapter-item expanded "><a href="../zksnark/subsec2.html"><strong aria-hidden="true">4.2.</strong> Proving Single Polynomial</a></li><li class="chapter-item expanded "><a href="../zksnark/subsec3.html"><strong aria-hidden="true">4.3.</strong> Bringing It All Together: SNARK</a></li></ol></li><li class="chapter-item expanded "><a href="../zkstark/index.html"><strong aria-hidden="true">5.</strong> Basics of zk-STARKS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../zkstark/subsec1.html"><strong aria-hidden="true">5.1.</strong> FRI</a></li></ol></li><li class="chapter-item expanded "><a href="../zkvm/index.html"><strong aria-hidden="true">6.</strong> Basics of zkVM</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book of MyZKP</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Koukyosyumei/MyZKP/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="arithmetization"><a class="header" href="#arithmetization">Arithmetization</a></h1>
<p>The ultimate goal of Zero-Knowledge Proofs (ZKP) is to allow the prover to demonstrate their knowledge to the verifier without revealing any additional information. This knowledge typically involves solving complex problems, such as finding a secret input value that corresponds to a given public hash. ZKP protocols usually convert these statements into polynomial constraints. This process is often called <strong>arithmetization</strong>.</p>
<p>To make the protocol flexible, we need to encode this knowledge in a specific format, and one common approach is using Boolean circuits. It's well-known that problems in P (those solvable in polynomial time) and NP (those where the solution can be verified in polynomial time) can be represented as Boolean circuits. This means adopting Boolean circuits allows us to handle both P and NP problems.</p>
<p>However, Boolean circuits are often large and inefficient. Even a simple operation, like adding two 256-bit integers, can require hundreds of Boolean operators. In contrast, arithmetic circuits—essentially systems of equations involving addition, multiplication, and equality—offer a much more compact representation. Additionally, any Boolean circuit can be converted into an arithmetic circuit. For instance, the Boolean expression \(z = x \land y\) can be represented as \(x(x-1) = 0\), \(y(y-1) = 0\), and \(z = xy\) in an arithmetic circuit. Furthermore, as we'll see in this section, converting arithmetic circuits into polynomial constraints allows for much faster evaluation.</p>
<h2 id="rank-1-constraint-system-r1cs"><a class="header" href="#rank-1-constraint-system-r1cs">Rank-1 Constraint System (R1CS)</a></h2>
<p>There are many formats to represent arithmetic circuits, and one of the most popular ones is R1CS (Rank-1 Constraint System), which represents arithmetic circuits as a set of equality constraints, each involving only one multiplication. In an arithmetic circuit, we call the concrete values assigned to the variables within the constraints witness. We first provide the formal definition of R1CS as follows:</p>
<h3 id="definition-r1cs"><a class="header" href="#definition-r1cs">Definition: R1CS</a></h3>
<p>An R1CS structure \(\mathcal{S}\) consists of:</p>
<ul>
<li>Size bounds \(m, d, \ell \in \mathbb{N}\) where \(d &gt; \ell\)</li>
<li>Three matrices \(O, L, R \in \mathbb{F}^{m \times d}\) with at most \(\Omega(\max(m, d))\) non-zero entries in total</li>
</ul>
<p>An R1CS instance includes a public input \(p \in \mathbb{F}^\ell\), while an R1CS witness is a vector \(w \in \mathbb{F}^{d - \ell - 1}\).
A structure-instance tuple \((S, p)\) is satisfied by a witness \(w\) if:
\begin{equation}
(L \cdot v) \circ (R \cdot v) - O \cdot v = \mathbf{0}
\end{equation}
where \(v = (1, w, p) \in \mathbb{F}^d\), \(\cdot\) denotes matrix-vector multiplication, and \(\circ\) is the Hadamard product.</p>
<p>The intuitive interpretation of each matrix is as follows:</p>
<ul>
<li>\(L\): Encodes the left input of each gate</li>
<li>\(R\): Encodes the right input of each gate</li>
<li>\(O\): Encodes the output of each gate</li>
<li>The leading 1 in the assignment vector allows for constant terms</li>
</ul>
<p><strong>Single Multiplication</strong></p>
<p>Let's consider a simple example where we want to prove \(z = x \cdot y\), with \(z = 3690\), \(x = 82\), and \(y = 45\).</p>
<ul>
<li><strong>Assignment vector</strong>: \((1, z, x, y) = (1, 3690, 82, 45)\)</li>
<li><strong>Number of witnesses</strong>: \(m = 4\)</li>
<li><strong>Number of constraints</strong>: \(d = 1\)</li>
</ul>
<p>The R1CS constraint for \(z = x \cdot y\) is satisfied when:</p>
<p>\begin{align*}
&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot v) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot v) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot v \\
=&amp;(\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) \circ (\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix}) - \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix}
1 \\ 3690 \\ 82 \\ 45
\end{bmatrix} \\
=&amp; 82 \cdot 45 - 3690 \\
=&amp; 3690 - 3690 \\
=&amp; 0
\end{align*}</p>
<p>This example demonstrates how R1CS encodes a simple multiplication constraint:</p>
<ul>
<li>\(L = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\) selects \(x\) (left input)</li>
<li>\(R = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\) selects \(y\) (right input)</li>
<li>\(O = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}\) selects \(z\) (output)</li>
</ul>
<p><strong>Multiple Constraints</strong></p>
<p>Let's examine a more complex example: \(r = a \cdot b \cdot c \cdot d\). Since R1CS requires that each constraint contain only one multiplication, we need to break this down into multiple constraints:</p>
<p>\begin{align*}
z_1 &amp;= a \cdot b \\
z_2 &amp;= c \cdot d \\
r &amp;= z_1 \cdot z_2
\end{align*}</p>
<p>Note that alternative representations are possible, such as \(z_1 = ab, z_2 = z_1c, r = z_2d\). In this example, we use 7 variables \((r, a, b, c, d, z_1, z_2)\), so the dimension of the assignment vector will be \(m = 8\) (including the constant 1). We have three constraints, so \(n = 3\).
To construct the matrices \(L\), \(R\), and \(O\), we can interpret the constraints as linear combinations:</p>
<p>\begin{align*}
z_1 &amp;= (0 \cdot 1 + 0 \cdot r + 1 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot b \\
z_2 &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 1 \cdot c + 0 \cdot d + 0 \cdot z_1 + 0 \cdot z_2) \cdot d \\
r &amp;= (0 \cdot 1 + 0 \cdot r + 0 \cdot v + 0 \cdot b + 0 \cdot c + 0 \cdot d + 1 \cdot z_1 + 0 \cdot z_2) \cdot z_2
\end{align*}</p>
<p>Thus, we can construct \(L\), \(R\), and \(O\) as follows:</p>
<p>\begin{equation*}
L = \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\end{equation*}
\begin{equation*}
R = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{equation*}
\begin{equation*}
O = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\end{equation*}</p>
<p>Where the columns in each matrix correspond to \((1, r, a, b, c, d, z_1, z_2)\).</p>
<p><strong>Addition with a Constant</strong></p>
<p>Let's examine the case \(z = x \cdot y + 3\). We can represent this as \(-3 + z = x \cdot y\). For the assignment vector \((1, z, x, y)\), we have:</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
-3 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}
\end{align*}</p>
<p>Note that the constant 3 appears in the \(O\) matrix with a negative sign, effectively moving it to the left side of the equation</p>
<p><strong>Multiplication with a Constant</strong></p>
<p>Now, let's consider \(z = 3x^2 + y\). The requirement of "one multiplication per constraint" doesn't apply to multiplication with a constant, as we can treat it as repeated addition.</p>
<p>\begin{align*}
L &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 3 &amp; 0
\end{bmatrix} \\
R &amp;= \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix} \\
O &amp;= \begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix}
\end{align*}</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;F: Field&gt;(a: &amp;Vec&lt;F&gt;, b: &amp;Vec&lt;F&gt;) -&gt; F {
    let mut result = F::zero();
    for (a_i, b_i) in a.iter().zip(b.iter()) {
        result = result + a_i.clone() * b_i.clone();
    }
    result
}

#[derive(Debug, Clone)]
pub struct R1CS&lt;F: Field&gt; {
    pub left: Vec&lt;Vec&lt;F&gt;&gt;,
    pub right: Vec&lt;Vec&lt;F&gt;&gt;,
    pub out: Vec&lt;Vec&lt;F&gt;&gt;,
    pub m: usize,
    pub d: usize,
}

impl&lt;F: Field&gt; R1CS&lt;F&gt; {
    pub fn new(left: Vec&lt;Vec&lt;F&gt;&gt;, right: Vec&lt;Vec&lt;F&gt;&gt;, out: Vec&lt;Vec&lt;F&gt;&gt;) -&gt; Self {
        let d = left.len();
        let m = if d == 0 { 0 } else { left[0].len() };
        R1CS {
            left,
            right,
            out,
            m,
            d,
        }
    }

    pub fn is_satisfied(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; bool {
        let zero = F::zero();
        self.left
            .iter()
            .zip(self.right.iter())
            .zip(self.out.iter())
            .all(|((l, r), o)| dot(&amp;l, &amp;a) * dot(&amp;r, &amp;a) - dot(&amp;o, &amp;a) == zero)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="quadratic-arithmetic-program-qap"><a class="header" href="#quadratic-arithmetic-program-qap">Quadratic Arithmetic Program (QAP)</a></h2>
<p>Recall that the prover aims to demonstrate knowledge of a witness \(w\) without revealing it. This is equivalent to knowing a vector \(a\) that satisfies \((L \cdot v) \circ (R \cdot v) = O \cdot v\), where \(\circ\) denotes the Hadamard (element-wise) product. However, evaluating this equivalence directly requires \(\Omega(d)\) operations, where \(d\) is the number of rows. To improve efficiency, we can convert this matrix comparison to a polynomial comparison, leveraging the Schwartz-Zippel Lemma, which allows us to check polynomial equality with \(\Omega(1)\) evaluations.</p>
<p><strong>Equivalence of Matrices</strong></p>
<p>Let's consider a simpler example to illustrate this concept. Suppose we want to test the equivalence \(Av = Bu\), where:</p>
<p>\begin{align*}
A = \begin{bmatrix}
2 &amp; 5 \\
3 &amp; 1 \\
\end{bmatrix},
B = \begin{bmatrix}
4 &amp; 1 \\
2 &amp; 3 \\
\end{bmatrix},
v = \begin{bmatrix}
3 \\ 1
\end{bmatrix},
u = \begin{bmatrix}
2 \\ 2
\end{bmatrix}
\end{align*}</p>
<p>The equivalence check can be represented as:</p>
<p>\begin{equation*}
\begin{bmatrix}
2 \\ 3
\end{bmatrix} \cdot 3 + \begin{bmatrix}
5 \\ 1
\end{bmatrix} \cdot 1 = \begin{bmatrix}
4 \\ 2
\end{bmatrix} \cdot 2 + \begin{bmatrix}
1 \\ 3
\end{bmatrix} \cdot 2
\end{equation*}</p>
<p>This matrix-vector equality check is equivalent to the following polynomial equality check:</p>
<p>\begin{equation*}
3 \cdot \lambda([(1, 2), (2, 3)]) + 1 \cdot \lambda([(1, 5), (2, 1)]) = 2 \cdot \lambda([(1, 4), (2, 2)]) + 2 \cdot \lambda([(1, 1), (2, 3)])
\end{equation*}</p>
<p>where \(\lambda\) denotes Lagrange Interpolation. In \(\mathbb{F}_{11}\) (field with 11 elements), we have:</p>
<p>\begin{align*}
\lambda([(1, 2), (2, 3)]) &amp;= x + 1 \\
\lambda([(1, 5), (2, 1)]) &amp;= 7x + 9 \\
\lambda([(1, 4), (2, 2)]) &amp;= 9x + 6 \\
\lambda([(1, 1), (2, 3)]) &amp;= 2x + 10
\end{align*}</p>
<p>The Schwartz-Zippel Lemma states that we need only one evaluation at a random point to check the equivalence of polynomials with high probability.</p>
<p><strong>Back to R1CS</strong></p>
<p>Let's thinks about how we can leverage the above method for the verification of R1CS. First, we can construct the interpolated polynomials for \(L \cdot v\), \(R \cdot v\), and \(O \cdot v\), denoted as \(\ell(x)\), \(r(x)\), and \(o(x)\), repectively, as follows:</p>
<p>\begin{align*}
\ell(x) &amp;= \sum^{d}_{i=1} v_i \ell_i(x) \quad \hbox{,where } \ell_i(x) := \lambda([(1, L_i,_1), (2, L_i,_2), \cdots,(m, L_i,_m)]) \\
r(x) &amp;= \sum^{d} _{i=1} v_i r_i(x) \quad \hbox{,where } r_i(x) := \lambda([(1, R_i,_1), (2, R_i,_2), \cdots,(m, R_i,_m)]) \\
o(x) &amp;= \sum^{d} _{i=1} v_i o_i(x) \quad \hbox{,where } o_i(x) := \lambda([(1, O_i,_1), (2, O_i,_2), \cdots,(m, O_i,_m)])
\end{align*}</p>
<p>However, the homomorphic property for multiplication doesn't hold for Lagrange Interpolation. While \(\ell(x)\), \(r(x)\), and \(o(x)\) are of degree at most \(m-1\), \(\ell(x) \cdot r(x)\) is of degree at most \(2m-2\). Thus, we don't have \(\ell(x) \cdot r(x) = o(x)\).</p>
<p>To address this discrepancy, we introduce a degree \(m\) polynomial \(t(x) = \prod_{i=1}^{m} (x - i)\). Given the constituion of the interpolated equations, we have that \(\forall{x} \in \{1,\cdots, d\}\) \(\ell(x) \cdot r(x) = o(x)\). This implies the following:</p>
<p>\begin{equation}
\forall{x} \in \{1,\cdots, m\} \quad \ell(x) \cdot r(x) - o(x) = 0
\end{equation}</p>
<p>Thus, we can factorize \(\ell(x) \cdot r(x) - o(x)\) into the product of \(t(x)\) and an appripriate polynomial \(h(x)\) such that \(\ell(x) \cdot r(x) - o(x) = t(x)h(x)\).</p>
<p>Then, we can then rewrite the equation as:</p>
<p>\begin{equation}
\ell(x) \cdot r(x) = o(x) + h(x) \cdot t(x)
\end{equation}</p>
<p>This formulation allows us to maintain the desired polynomial relationships while accounting for the degree differences.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct QAP&lt;'a, F: Field&gt; {
    pub r1cs: &amp;'a R1CS&lt;F&gt;,
    pub t: Polynomial&lt;F&gt;,
}

impl&lt;'a, F: Field&gt; QAP&lt;'a, F&gt; {
    fn new(r1cs: &amp;'a R1CS&lt;F&gt;) -&gt; Self {
        QAP {
            r1cs: r1cs,
            t: Polynomial::&lt;F&gt;::from_monomials(
                &amp;(1..=r1cs.d).map(|i| F::from_value(i)).collect::&lt;Vec&lt;F&gt;&gt;(),
            ),
        }
    }

    fn generate_polynomials(&amp;self, a: &amp;Vec&lt;F&gt;) -&gt; (Polynomial&lt;F&gt;, Polynomial&lt;F&gt;, Polynomial&lt;F&gt;) {
        let left_dot_products = self
            .r1cs
            .left
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let right_dot_products = self
            .r1cs
            .right
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let out_dot_products = self
            .r1cs
            .out
            .iter()
            .map(|v| dot(&amp;v, &amp;a))
            .collect::&lt;Vec&lt;F&gt;&gt;();

        let x = (1..=self.r1cs.m)
            .map(|i| F::from_value(i))
            .collect::&lt;Vec&lt;F&gt;&gt;();
        let left_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;left_dot_products);
        let right_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;right_dot_products);
        let out_interpolated_polynomial = Polynomial::&lt;F&gt;::interpolate(&amp;x, &amp;out_dot_products);
        (
            left_interpolated_polynomial,
            right_interpolated_polynomial,
            out_interpolated_polynomial,
        )
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../zksnark/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../zksnark/subsec2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../zksnark/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../zksnark/subsec2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
